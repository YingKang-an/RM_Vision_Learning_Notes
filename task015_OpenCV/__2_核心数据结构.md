# OpenCV 核心数据类型

## 一、Mat 类 - 图像存储的核心

1. **Mat 是 OpenCV 的核心数据结构**，用于存储图像和矩阵数据
2. **支持多种数据类型**：从 8 位无符号整数到 64 位浮点数
3. **自动内存管理**：使用引用计数机制，避免内存泄漏
4. **高效的数据访问**：提供多种访问方法适应不同场景
5. **丰富的数学运算**：支持矩阵运算、统计计算等
6. **灵活的 ROI 操作**：可以方便地操作图像的子区域

### Mat 类属性和方法详解

#### Mat 属性

| 属性 | 类型 | 说明 | 示例 |
|------|------|------|------|
| `data` | `uchar*` | 指向矩阵数据的指针（原始数据） | `mat.data` |
| `dims` | `int` | 矩阵的维数（2D图像为2） | `mat.dims` |
| `rows` | `int` | 矩阵的行数（高度） | `mat.rows` |
| `cols` | `int` | 矩阵的列数（宽度） | `mat.cols` |
| `size` | `MatSize` | 返回一个可以访问各维大小的对象 | `mat.size[i]` |
| `step` | `size_t*` | 每个维度的步长（字节） | `mat.step` |
| `step1` | `size_t*` | 每个维度的步长（元素个数） | `mat.step1(i)` |
| `elemSize` | `size_t` | 每个元素的大小（字节） | `mat.elemSize()` |
| `elemSize1` | `size_t` | 每个通道的大小（字节） | `mat.elemSize1()` |
| `type` | `int` | 矩阵元素的类型（如CV_8UC3） | `mat.type()` |
| `depth` | `int` | 矩阵元素的深度（如CV_8U） | `mat.depth()` |
| `channels` | `int` | 矩阵的通道数 | `mat.channels()` |
| `flags` | `int` | 包含矩阵类型和连续性等标志 | `mat.flags` |
| `total` | `size_t` | 矩阵元素的总数 | `mat.total()` |
| `refcount` | `int*` | 引用计数指针（用于内存管理） | `mat.refcount` |
| `datastart` | `uchar*` | 指向数据块开始的指针 | `mat.datastart` |
| `dataend` | `uchar*` | 指向数据块结束的指针 | `mat.dataend` |
| `datalimit` | `uchar*` | 指向分配内存结束的指针 | `mat.datalimit` |

#### Mat 方法

##### 构造函数和析构函数

| 方法 | 说明 | 示例 |
|------|------|------|
| `Mat()` | 默认构造函数 | `Mat m;` |
| `Mat(int rows, int cols, int type)` | 指定行、列和类型 | `Mat(480,640,CV_8UC3)` |
| `Mat(Size size, int type)` | 使用Size指定大小 | `Mat(Size(640,480),CV_8UC3)` |
| `Mat(int rows, int cols, int type, const Scalar& s)` | 指定大小、类型和初始值 | `Mat(100,100,CV_8UC3,Scalar(255,0,0))` |
| `Mat(const Mat& m)` | 复制构造函数（浅拷贝） | `Mat m2(m1);` |
| `Mat(const Mat& m, const Range& rowRange, const Range& colRange)` | 从原矩阵创建子矩阵 | `Mat roi(m, Range(0,10), Range(0,10))` |
| `Mat(const Mat& m, const Rect& roi)` | 从矩形区域创建子矩阵 | `Mat roi(m, Rect(0,0,100,100))` |
| `~Mat()` | 析构函数 | 自动调用 |

##### 创建和初始化方法

| 方法 | 说明 | 示例 |
|------|------|------|
| `create(int rows, int cols, int type)` | 重新分配矩阵内存 | `mat.create(100,100,CV_8UC3)` |
| `create(Size size, int type)` | 使用Size重新分配内存 | `mat.create(Size(100,100),CV_8UC3)` |
| `zeros(int rows, int cols, int type)` | 静态方法：创建全零矩阵 | `Mat::zeros(3,3,CV_8UC1)` |
| `zeros(Size size, int type)` | 静态方法：创建全零矩阵 | `Mat::zeros(Size(3,3),CV_8UC1)` |
| `ones(int rows, int cols, int type)` | 静态方法：创建全一矩阵 | `Mat::ones(3,3,CV_32FC1)` |
| `ones(Size size, int type)` | 静态方法：创建全一矩阵 | `Mat::ones(Size(3,3),CV_32FC1)` |
| `eye(int rows, int cols, int type)` | 静态方法：创建单位矩阵 | `Mat::eye(3,3,CV_32FC1)` |
| `eye(Size size, int type)` | 静态方法：创建单位矩阵 | `Mat::eye(Size(3,3),CV_32FC1)` |
| `setTo(const Scalar& s)` | 设置所有元素为指定值 | `mat.setTo(Scalar(255,0,0))` |
| `setTo(const Scalar& s, InputArray mask)` | 带掩码的设置 | `mat.setTo(Scalar(0), mask)` |
| `copyTo(OutputArray m)` | 复制到目标矩阵 | `mat.copyTo(dst)` |
| `copyTo(OutputArray m, InputArray mask)` | 带掩码的复制 | `mat.copyTo(dst, mask)` |
| `clone()` | 深拷贝 | `Mat m2 = mat.clone()` |

##### 类型转换方法

| 方法 | 说明 | 示例 |
|------|------|------|
| `convertTo(OutputArray m, int rtype, double alpha=1, double beta=0)` | 类型转换并缩放 | `mat.convertTo(dst,CV_32FC1,1/255.0)` |
| `reshape(int cn, int rows=0)` | 改变矩阵形状而不复制数据 | `mat.reshape(0,1)` |
| `t()` | 转置矩阵 | `Mat t = mat.t()` |
| `inv(int method=DECOMP_LU)` | 矩阵求逆 | `Mat inv = mat.inv()` |
| `diag(int d=0)` | 提取对角线 | `Mat d = mat.diag()` |

##### 元素访问方法

| 方法 | 说明 | 示例 |
|------|------|------|
| `at<T>(int row, int col)` | 类型安全访问元素 | `mat.at<uchar>(i,j)` |
| `at<T>(Point pt)` | 通过点访问元素 | `mat.at<Vec3b>(pt)` |
| `ptr<T>(int row)` | 获取指定行的指针 | `uchar* row = mat.ptr<uchar>(i)` |
| `ptr<T>(int row, int col)` | 获取指定位置指针 | |
| `begin<T>()` | 获取迭代器开始 | `auto it = mat.begin<Vec3b>()` |
| `end<T>()` | 获取迭代器结束 | `auto end = mat.end<Vec3b>()` |
| `forEach<T>(callback)` | 并行遍历所有元素 | `mat.forEach<Vec3b>([](){})` |

##### 属性查询方法

| 方法 | 说明 | 示例 |
|------|------|------|
| `empty()` | 判断矩阵是否为空 | `if(mat.empty())` |
| `isContinuous()` | 判断是否连续存储 | `if(mat.isContinuous())` |
| `isSubmatrix()` | 判断是否为子矩阵 | `if(mat.isSubmatrix())` |
| `checkVector(int elemChannels, int depth=-1, bool requireContinuous=true)` | 检查矩阵是否可以被视为向量 | `mat.checkVector(3,CV_8U)` |

##### 矩阵运算方法

| 方法 | 说明 | 示例 |
|------|------|------|
| `mul(InputArray m, double scale=1)` | 逐元素乘法 | `mat1.mul(mat2)` |
| `dot(InputArray m)` | 点积运算 | `mat1.dot(mat2)` |
| `cross(InputArray m)` | 叉积运算 | `mat1.cross(mat2)` |
| `operator+` | 矩阵加法 | `mat1 + mat2` |
| `operator-` | 矩阵减法 | `mat1 - mat2` |
| `operator*` | 矩阵乘法或标量乘法 | `mat * 2` |
| `operator/` | 矩阵除法或标量除法 | `mat / 2` |
| `operator+=` | 复合加法赋值 | `mat1 += mat2` |
| `operator-=` | 复合减法赋值 | `mat1 -= mat2` |
| `operator*=` | 复合乘法赋值 | `mat *= 2` |
| `operator/=` | 复合除法赋值 | `mat /= 2` |

##### ROI（感兴趣区域）操作

| 方法 | 说明 | 示例 |
|------|------|------|
| `operator()(const Rect& roi)` | 获取矩形区域 | `mat(Rect(0,0,100,100))` |
| `operator()(const Range& rowRange, const Range& colRange)` | 获取范围区域 | `mat(Range(0,10),Range(0,10))` |
| `row(int y)` | 获取指定行 | `mat.row(0)` |
| `col(int x)` | 获取指定列 | `mat.col(0)` |
| `rowRange(int startrow, int endrow)` | 获取行范围 | `mat.rowRange(0,10)` |
| `rowRange(const Range& r)` | 获取行范围 | `mat.rowRange(Range(0,10))` |
| `colRange(int startcol, int endcol)` | 获取列范围 | `mat.colRange(0,10)` |
| `colRange(const Range& r)` | 获取列范围 | `mat.colRange(Range(0,10))` |

### Mat 类常用编程示例

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>
#include <chrono>
#include <vector>

void printMatInfo(const cv::Mat& mat, const std::string& name) {
    std::cout << "\n=== " << name << " 信息 ===" << std::endl;
    std::cout << "尺寸: " << mat.cols << "×" << mat.rows << " 像素" << std::endl;
    std::cout << "通道数: " << mat.channels() << std::endl;
    std::cout << "类型: " << mat.type() << std::endl;
    std::cout << "总像素数: " << mat.total() << std::endl;
    std::cout << "是否为空: " << (mat.empty() ? "是" : "否") << std::endl;
    std::cout << "是否连续存储: " << (mat.isContinuous() ? "是" : "否") << std::endl;
}

int main() {
    std::cout << "========== Mat 类综合示例 ==========" << std::endl;
    
    // ============================================
    // 1. 创建和初始化 Mat
    // ============================================
    
    std::cout << "\n1. 创建和初始化 Mat:" << std::endl;
    
    // 1.1 创建不同尺寸和类型的矩阵
    cv::Mat gray_img(480, 640, CV_8UC1);           // 灰度图像
    cv::Mat color_img(480, 640, CV_8UC3);          // 彩色图像
    cv::Mat float_img(100, 100, CV_32FC1);         // 浮点图像
    
    // 1.2 使用不同方法初始化
    cv::Mat zeros_mat = cv::Mat::zeros(3, 3, CV_8UC1);
    cv::Mat ones_mat = cv::Mat::ones(3, 3, CV_32FC1);
    cv::Mat eye_mat = cv::Mat::eye(3, 3, CV_32FC1);
    
    // 1.3 使用标量初始化
    cv::Mat blue_img(300, 400, CV_8UC3, cv::Scalar(255, 0, 0));
    cv::Mat red_img(300, 400, CV_8UC3);
    red_img.setTo(cv::Scalar(0, 0, 255));
    
    // 1.4 从数组创建
    float data[9] = {1, 2, 3, 4, 5, 6, 7, 8, 9};
    cv::Mat mat_from_array(3, 3, CV_32FC1, data);
    
    // 1.5 创建多维矩阵
    int sizes[] = {3, 4, 5};  // 3维：3×4×5
    cv::Mat nd_mat(3, sizes, CV_8UC1, cv::Scalar(0));
    
    std::cout << "3D矩阵维度: " << nd_mat.dims << std::endl;
    for (int i = 0; i < nd_mat.dims; i++) {
        std::cout << "  维度 " << i << " 大小: " << nd_mat.size[i] << std::endl;
    }
    
    // ============================================
    // 2. 矩阵属性和信息
    // ============================================
    
    std::cout << "\n2. 矩阵属性和信息:" << std::endl;
    
    printMatInfo(gray_img, "灰度图像");
    printMatInfo(color_img, "彩色图像");
    printMatInfo(float_img, "浮点图像");
    
    // 计算内存大小
    std::cout << "\n彩色图像内存计算:" << std::endl;
    std::cout << "每个元素大小: " << color_img.elemSize() << " 字节" << std::endl;
    std::cout << "每个通道大小: " << color_img.elemSize1() << " 字节" << std::endl;
    std::cout << "总内存: " << color_img.total() * color_img.elemSize() << " 字节" << std::endl;
    std::cout << "每行字节数: " << color_img.step << " 字节" << std::endl;
    std::cout << "每行元素数: " << color_img.step1() << " 元素" << std::endl;
    
    // ============================================
    // 3. 像素访问方法比较
    // ============================================
    
    std::cout << "\n3. 像素访问方法比较:" << std::endl;
    
    cv::Mat test_img(1000, 1000, CV_8UC3);
    
    // 方法1：使用at<>() - 最安全但较慢
    auto start = std::chrono::high_resolution_clock::now();
    for (int i = 0; i < test_img.rows; i++) {
        for (int j = 0; j < test_img.cols; j++) {
            cv::Vec3b& pixel = test_img.at<cv::Vec3b>(i, j);
            pixel[0] = (i + j) % 256;  // B
            pixel[1] = (i * 2) % 256;  // G
            pixel[2] = (j * 2) % 256;  // R
        }
    }
    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
    std::cout << "at<>() 方法用时: " << duration.count() << " ms" << std::endl;
    
    // 方法2：使用ptr<>() - 较快
    test_img.setTo(0);
    start = std::chrono::high_resolution_clock::now();
    for (int i = 0; i < test_img.rows; i++) {
        cv::Vec3b* row = test_img.ptr<cv::Vec3b>(i);
        for (int j = 0; j < test_img.cols; j++) {
            row[j][0] = (i + j) % 256;
            row[j][1] = (i * 2) % 256;
            row[j][2] = (j * 2) % 256;
        }
    }
    end = std::chrono::high_resolution_clock::now();
    duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
    std::cout << "ptr<>() 方法用时: " << duration.count() << " ms" << std::endl;
    
    // 方法3：使用data指针 - 最快但要小心
    test_img.setTo(0);
    start = std::chrono::high_resolution_clock::now();
    if (test_img.isContinuous()) {
        int total = test_img.rows * test_img.cols * test_img.channels();
        uchar* data_ptr = test_img.data;
        for (int i = 0; i < total; i += 3) {
            data_ptr[i] = i % 256;      // B
            data_ptr[i + 1] = (i * 2) % 256; // G
            data_ptr[i + 2] = (i * 3) % 256; // R
        }
    }
    end = std::chrono::high_resolution_clock::now();
    duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
    std::cout << "data指针方法用时: " << duration.count() << " ms" << std::endl;
    
    // 方法4：使用迭代器
    test_img.setTo(0);
    start = std::chrono::high_resolution_clock::now();
    cv::MatIterator_<cv::Vec3b> it = test_img.begin<cv::Vec3b>();
    cv::MatIterator_<cv::Vec3b> end_it = test_img.end<cv::Vec3b>();
    int idx = 0;
    for (; it != end_it; ++it, ++idx) {
        (*it)[0] = idx % 256;
        (*it)[1] = (idx * 2) % 256;
        (*it)[2] = (idx * 3) % 256;
    }
    end = std::chrono::high_resolution_clock::now();
    duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
    std::cout << "迭代器方法用时: " << duration.count() << " ms" << std::endl;
    
    // 方法5：使用forEach并行处理
    test_img.setTo(0);
    start = std::chrono::high_resolution_clock::now();
    test_img.forEach<cv::Vec3b>([](cv::Vec3b& pixel, const int* position) {
        pixel[0] = (position[0] + position[1]) % 256;
        pixel[1] = (position[0] * 2) % 256;
        pixel[2] = (position[1] * 2) % 256;
    });
    end = std::chrono::high_resolution_clock::now();
    duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
    std::cout << "forEach方法用时: " << duration.count() << " ms" << std::endl;
    
    // ============================================
    // 4. ROI（感兴趣区域）操作
    // ============================================
    
    std::cout << "\n4. ROI（感兴趣区域）操作:" << std::endl;
    
    cv::Mat image(500, 500, CV_8UC3, cv::Scalar(255, 255, 255));
    
    // 4.1 使用Rect获取ROI
    cv::Rect roi_rect(100, 100, 200, 150);
    cv::Mat roi_by_rect = image(roi_rect);
    roi_by_rect.setTo(cv::Scalar(0, 0, 255));  // 设置为红色
    
    // 4.2 使用Range获取ROI
    cv::Range row_range(300, 400);
    cv::Range col_range(200, 350);
    cv::Mat roi_by_range = image(row_range, col_range);
    roi_by_range.setTo(cv::Scalar(255, 0, 0));  // 设置为蓝色
    
    // 4.3 获取行和列
    cv::Mat row_10 = image.row(10);  // 第10行
    row_10.setTo(cv::Scalar(0, 255, 0));  // 设置为绿色
    
    cv::Mat col_20 = image.col(20);  // 第20列
    col_20.setTo(cv::Scalar(0, 255, 0));  // 设置为绿色
    
    // 4.4 多行和多列
    cv::Mat rows_150_to_200 = image.rowRange(150, 200);
    rows_150_to_200.setTo(cv::Scalar(255, 255, 0));  // 设置为黄色
    
    cv::Mat cols_400_to_450 = image.colRange(400, 450);
    cols_400_to_450.setTo(cv::Scalar(255, 0, 255));  // 设置为洋红色
    
    // ============================================
    // 5. 矩阵运算
    // ============================================
    
    std::cout << "\n5. 矩阵运算:" << std::endl;
    
    // 5.1 创建测试矩阵
    cv::Mat A = (cv::Mat_<float>(2, 3) << 1, 2, 3, 4, 5, 6);
    cv::Mat B = (cv::Mat_<float>(2, 3) << 6, 5, 4, 3, 2, 1);
    
    std::cout << "矩阵 A:\n" << A << std::endl;
    std::cout << "矩阵 B:\n" << B << std::endl;
    
    // 5.2 基本运算
    cv::Mat C = A + B;  // 加法
    cv::Mat D = A - B;  // 减法
    cv::Mat E = A * 2;  // 标量乘法
    cv::Mat F = A / 2;  // 标量除法
    
    std::cout << "A + B:\n" << C << std::endl;
    std::cout << "A - B:\n" << D << std::endl;
    std::cout << "A * 2:\n" << E << std::endl;
    std::cout << "A / 2:\n" << F << std::endl;
    
    // 5.3 逐元素乘法
    cv::Mat G = A.mul(B);
    std::cout << "A.mul(B) (逐元素乘法):\n" << G << std::endl;
    
    // 5.4 点积（需要是向量）
    cv::Mat vec1 = (cv::Mat_<float>(1, 3) << 1, 2, 3);
    cv::Mat vec2 = (cv::Mat_<float>(1, 3) << 4, 5, 6);
    double dot_result = vec1.dot(vec2);
    std::cout << "向量点积: " << dot_result << std::endl;
    
    // 5.5 矩阵乘法
    cv::Mat M1 = (cv::Mat_<float>(2, 3) << 1, 2, 3, 4, 5, 6);
    cv::Mat M2 = (cv::Mat_<float>(3, 2) << 7, 8, 9, 10, 11, 12);
    cv::Mat M3 = M1 * M2;  // 2×3 * 3×2 = 2×2
    std::cout << "矩阵乘法 M1 * M2:\n" << M3 << std::endl;
    
    // 5.6 转置
    cv::Mat T = A.t();
    std::cout << "A 的转置:\n" << T << std::endl;
    
    // 5.7 求逆（需要方阵）
    cv::Mat inv_mat = (cv::Mat_<float>(2, 2) << 4, 7, 2, 6);
    cv::Mat inv_result = inv_mat.inv();
    std::cout << "矩阵:\n" << inv_mat << std::endl;
    std::cout << "逆矩阵:\n" << inv_result << std::endl;
    
    // 验证逆矩阵
    cv::Mat identity = inv_mat * inv_result;
    std::cout << "矩阵 × 逆矩阵 ≈ 单位矩阵:\n" << identity << std::endl;
    
    // ============================================
    // 6. 类型转换和变形
    // ============================================
    
    std::cout << "\n6. 类型转换和变形:" << std::endl;
    
    // 6.1 类型转换
    cv::Mat uint8_mat(3, 3, CV_8UC1, cv::Scalar(100));
    cv::Mat float_mat;
    uint8_mat.convertTo(float_mat, CV_32FC1, 1/255.0);
    
    std::cout << "uint8 矩阵:\n" << uint8_mat << std::endl;
    std::cout << "转换为 float (除以255):\n" << float_mat << std::endl;
    
    // 6.2 矩阵变形
    cv::Mat original(4, 3, CV_8UC1);
    cv::randu(original, 0, 255);
    
    std::cout << "原始矩阵 (4×3):\n" << original << std::endl;
    
    // 改变形状但不改变通道数
    cv::Mat reshaped = original.reshape(0, 2, 6);  // 2×6
    std::cout << "变形为 2×6:\n" << reshaped << std::endl;
    
    // 改变通道数
    cv::Mat gray(2, 2, CV_8UC1, cv::Scalar(100));
    cv::Mat color = gray.reshape(3, 0);  // 转换为3通道
    std::cout << "1通道矩阵:\n" << gray << std::endl;
    std::cout << "转换为3通道后大小: " << color.rows << "×" << color.cols 
              << "×" << color.channels() << std::endl;
    
    // ============================================
    // 7. 图像处理综合应用
    // ============================================
    
    std::cout << "\n7. 图像处理综合应用:" << std::endl;
    
    // 7.1 创建测试图像
    cv::Mat test_image(400, 600, CV_8UC3);
    
    // 创建渐变背景
    for (int i = 0; i < test_image.rows; i++) {
        for (int j = 0; j < test_image.cols; j++) {
            cv::Vec3b& pixel = test_image.at<cv::Vec3b>(i, j);
            pixel[0] = static_cast<uchar>(255 * j / test_image.cols);      // B
            pixel[1] = static_cast<uchar>(255 * i / test_image.rows);      // G
            pixel[2] = static_cast<uchar>(255 * (1.0 - j / (double)test_image.cols)); // R
        }
    }
    
    // 7.2 图像混合
    cv::Mat overlay(test_image.size(), test_image.type(), cv::Scalar(0, 255, 255)); // 黄色
    
    double alpha = 0.3;
    cv::Mat blended;
    cv::addWeighted(test_image, 1 - alpha, overlay, alpha, 0, blended);
    
    // 7.3 图像裁剪和缩放
    cv::Rect crop_rect(100, 100, 200, 150);
    cv::Mat cropped = blended(crop_rect);
    
    cv::Mat resized;
    cv::resize(cropped, resized, cv::Size(400, 300));
    
    // 7.4 颜色空间转换
    cv::Mat hsv_image;
    cv::cvtColor(test_image, hsv_image, cv::COLOR_BGR2HSV);
    
    // 7.5 通道分离和合并
    std::vector<cv::Mat> channels;
    cv::split(test_image, channels);
    
    // 增强蓝色通道
    channels[0] = channels[0] * 1.5;
    
    cv::Mat enhanced;
    cv::merge(channels, enhanced);
    
    // 7.6 统计信息
    cv::Scalar mean_val = cv::mean(test_image);
    cv::Scalar stddev_val;
    cv::meanStdDev(test_image, mean_val, stddev_val);
    
    std::cout << "图像均值 (B,G,R): " << mean_val << std::endl;
    std::cout << "图像标准差 (B,G,R): " << stddev_val << std::endl;
    
    // 查找最大值和最小值
    double min_val, max_val;
    cv::Point min_loc, max_loc;
    cv::Mat gray_test;
    cv::cvtColor(test_image, gray_test, cv::COLOR_BGR2GRAY);
    cv::minMaxLoc(gray_test, &min_val, &max_val, &min_loc, &max_loc);
    
    std::cout << "灰度图最小值: " << min_val << " 在位置 (" << min_loc.x << ", " << min_loc.y << ")" << std::endl;
    std::cout << "灰度图最大值: " << max_val << " 在位置 (" << max_loc.x << ", " << max_loc.y << ")" << std::endl;
    
    // 7.7 图像旋转
    cv::Mat rotated;
    cv::Point2f center(test_image.cols / 2.0, test_image.rows / 2.0);
    cv::Mat rot_mat = cv::getRotationMatrix2D(center, 30, 1.0);  // 旋转30度
    cv::warpAffine(test_image, rotated, rot_mat, test_image.size());
    
    // ============================================
    // 8. 显示结果
    // ============================================
    
    cv::imshow("原始图像", test_image);
    cv::imshow("混合图像", blended);
    cv::imshow("裁剪并缩放", resized);
    cv::imshow("增强蓝色", enhanced);
    cv::imshow("旋转图像", rotated);
    
    // 显示各个通道
    cv::imshow("蓝色通道", channels[0]);
    cv::imshow("绿色通道", channels[1]);
    cv::imshow("红色通道", channels[2]);
    
    // 显示统计信息
    cv::Mat stats_display(200, 600, CV_8UC3, cv::Scalar(255, 255, 255));
    std::string stats_text = "均值: " + std::to_string(mean_val[0]) + ", " 
                           + std::to_string(mean_val[1]) + ", " 
                           + std::to_string(mean_val[2]);
    cv::putText(stats_display, stats_text, cv::Point(10, 30), 
               cv::FONT_HERSHEY_SIMPLEX, 0.7, cv::Scalar(0, 0, 0), 2);
    
    stats_text = "最亮点: (" + std::to_string(max_loc.x) + ", " 
                + std::to_string(max_loc.y) + ") 值: " + std::to_string(max_val);
    cv::putText(stats_display, stats_text, cv::Point(10, 70), 
               cv::FONT_HERSHEY_SIMPLEX, 0.7, cv::Scalar(0, 0, 0), 2);
    
    cv::imshow("统计信息", stats_display);
    
    cv::waitKey(0);
    
    // ============================================
    // 9. 文件I/O操作
    // ============================================
    
    std::cout << "\n9. 文件I/O操作:" << std::endl;
    
    // 9.1 保存图像
    cv::imwrite("test_image.jpg", test_image);
    cv::imwrite("test_image.png", test_image);
    cv::imwrite("test_image.tiff", test_image);
    
    // 9.2 保存浮点数据
    cv::FileStorage fs("matrix_data.yml", cv::FileStorage::WRITE);
    fs << "MatrixA" << A;
    fs << "MatrixB" << B;
    fs.release();
    
    std::cout << "图像和矩阵数据已保存到文件" << std::endl;
    
    // 9.3 读取数据
    cv::FileStorage fs2("matrix_data.yml", cv::FileStorage::READ);
    cv::Mat loaded_A, loaded_B;
    fs2["MatrixA"] >> loaded_A;
    fs2["MatrixB"] >> loaded_B;
    fs2.release();
    
    std::cout << "从文件读取的矩阵 A:\n" << loaded_A << std::endl;
    std::cout << "从文件读取的矩阵 B:\n" << loaded_B << std::endl;
    
    // ============================================
    // 10. 高级特性：自定义矩阵运算
    // ============================================
    
    std::cout << "\n10. 高级特性：自定义矩阵运算:" << std::endl;
    
    // 10.1 使用cv::transform进行矩阵变换
    cv::Mat src_points = (cv::Mat_<float>(5, 2) << 
        1, 2,
        3, 4,
        5, 6,
        7, 8,
        9, 10);
    
    cv::Mat transform_mat = (cv::Mat_<float>(2, 3) << 
        1, 0, 10,  // x' = x + 10
        0, 1, 20); // y' = y + 20
    
    cv::Mat dst_points;
    cv::transform(src_points, dst_points, transform_mat);
    
    std::cout << "原始点:\n" << src_points << std::endl;
    std::cout << "变换矩阵:\n" << transform_mat << std::endl;
    std::cout << "变换后点:\n" << dst_points << std::endl;
    
    // 10.2 使用cv::reduce进行矩阵归约
    cv::Mat reduce_src = (cv::Mat_<float>(3, 3) << 
        1, 2, 3,
        4, 5, 6,
        7, 8, 9);
    
    cv::Mat row_sum, col_sum;
    cv::reduce(reduce_src, row_sum, 1, cv::REDUCE_SUM);  // 按行求和
    cv::reduce(reduce_src, col_sum, 0, cv::REDUCE_SUM);  // 按列求和
    
    std::cout << "原始矩阵:\n" << reduce_src << std::endl;
    std::cout << "行求和:\n" << row_sum << std::endl;
    std::cout << "列求和:\n" << col_sum << std::endl;
    
    // 10.3 使用cv::sort排序
    cv::Mat sort_src = (cv::Mat_<float>(1, 5) << 5, 2, 8, 1, 4);
    cv::Mat sorted_values, sorted_indices;
    cv::sort(sort_src, sorted_values, cv::SORT_ASCENDING);
    cv::sortIdx(sort_src, sorted_indices, cv::SORT_ASCENDING);
    
    std::cout << "原始数组: " << sort_src << std::endl;
    std::cout << "排序后值: " << sorted_values << std::endl;
    std::cout << "排序后索引: " << sorted_indices << std::endl;
    
    return 0;
}
```

#### 最佳实践

1. **像素访问选择**：
   - 安全性优先：使用 `at<>()`
   - 性能优先：使用 `ptr<>()`
   - 批量操作：使用 `forEach()` 并行处理

2. **内存管理**：
   - 使用 `clone()` 进行深拷贝
   - 使用 `copyTo()` 复制数据到现有矩阵
   - ROI 操作是浅拷贝，共享内存

3. **类型转换**：
   - 使用 `convertTo()` 进行类型转换和缩放
   - 图像显示前通常需要转换为 CV_8U 类型

4. **性能优化**：
   - 减少不必要的拷贝
   - 使用连续内存加速访问
   - 利用并行处理提高性能

Mat 类是 OpenCV 编程的基础，掌握它的属性和方法对于高效地进行计算机视觉开发至关重要。


## 二、几何类型详解

### 2.1 Point（点）- 坐标表示

**中文解释：**
Point 用于表示二维或三维空间中的**一个点**，主要用于：
- 图像坐标（x, y）
- 特征点位置
- 几何计算

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>

int main() {
    std::cout << "=== Point 类型详解 ===" << std::endl;
    
    // ============================================
    // 1. Point 的不同精度类型
    // ============================================
    
    std::cout << "1. Point 的精度类型:" << std::endl;
    std::cout << "   Point 是模板类 Point_<T> 的别名" << std::endl;
    std::cout << "   T 可以是 int, float, double 等" << std::endl;
    
    // 1.1 Point（整数点，最常用）
    cv::Point pt_int(100, 200);      // x=100, y=200（整数）
    std::cout << "\n   cv::Point (整数点):" << std::endl;
    std::cout << "     等价于 Point2i 或 Point_<int>" << std::endl;
    std::cout << "     用于像素坐标（只能是整数）" << std::endl;
    std::cout << "     示例: (" << pt_int.x << ", " << pt_int.y << ")" << std::endl;
    
    // 1.2 Point2f（浮点数点）
    cv::Point2f pt_float(100.5f, 200.7f);  // x=100.5, y=200.7（浮点数）
    std::cout << "\n   cv::Point2f (浮点数点):" << std::endl;
    std::cout << "     等价于 Point_<float>" << std::endl;
    std::cout << "     用于精确坐标（亚像素精度）" << std::endl;
    std::cout << "     示例: (" << pt_float.x << ", " << pt_float.y << ")" << std::endl;
    
    // 1.3 Point2d（双精度点）
    cv::Point2d pt_double(100.5, 200.7);   // 双精度
    std::cout << "\n   cv::Point2d (双精度点):" << std::endl;
    std::cout << "     等价于 Point_<double>" << std::endl;
    std::cout << "     用于高精度计算" << std::endl;
    
    // 1.4 Point3i（三维整数点）
    cv::Point3i pt_3d(100, 200, 300);      // x,y,z 坐标
    std::cout << "\n   cv::Point3i (三维整数点):" << std::endl;
    std::cout << "     用于3D空间坐标" << std::endl;
    std::cout << "     示例: (" << pt_3d.x << ", " << pt_3d.y << ", " << pt_3d.z << ")" << std::endl;
    
    // ============================================
    // 2. Point 的常用操作
    // ============================================
    
    std::cout << "\n\n2. Point 的运算:" << std::endl;
    
    cv::Point p1(10, 20);
    cv::Point p2(30, 40);
    
    // 2.1 点与点的运算
    cv::Point p_add = p1 + p2;       // (40, 60) - 点相加
    cv::Point p_sub = p2 - p1;       // (20, 20) - 点相减
    cv::Point p_neg = -p1;           // (-10, -20) - 取负
    
    std::cout << "   p1 + p2 = (" << p_add.x << ", " << p_add.y << ")" << std::endl;
    std::cout << "   p2 - p1 = (" << p_sub.x << ", " << p_sub.y << ")" << std::endl;
    
    // 2.2 点与标量的运算
    cv::Point p_mul = p1 * 2;        // (20, 40) - 乘以标量
    cv::Point p_div = p1 / 2;        // (5, 10) - 除以标量
    
    std::cout << "   p1 * 2 = (" << p_mul.x << ", " << p_mul.y << ")" << std::endl;
    std::cout << "   p1 / 2 = (" << p_div.x << ", " << p_div.y << ")" << std::endl;
    
    // 2.3 点积（内积）- 数学计算
    int dot_product = p1.dot(p2);    // 10*30 + 20*40 = 300 + 800 = 1100
    std::cout << "\n   点积（内积） p1·p2 = " << dot_product << std::endl;
    std::cout << "   公式: x1*x2 + y1*y2" << std::endl;
    std::cout << "   几何意义: 两个向量的乘积，与夹角相关" << std::endl;
    
    // 2.4 叉积（外积）- 2D叉积返回标量
    double cross_product = p1.cross(p2);  // 10*40 - 20*30 = 400 - 600 = -200
    std::cout << "\n   叉积（外积） p1×p2 = " << cross_product << std::endl;
    std::cout << "   公式: x1*y2 - y1*x2" << std::endl;
    std::cout << "   几何意义: 两个向量围成的平行四边形面积" << std::endl;
    std::cout << "   可以判断两个向量的旋转方向" << std::endl;
    
    // ============================================
    // 3. Point 的实用函数
    // ============================================
    
    std::cout << "\n\n3. Point 的实用函数:" << std::endl;
    
    // 3.1 计算两点间距离
    double distance = cv::norm(p2 - p1);  // 欧几里得距离
    std::cout << "   距离 p1 到 p2: " << distance << " 像素" << std::endl;
    std::cout << "   公式: sqrt((x2-x1)² + (y2-y1)²)" << std::endl;
    
    // 3.2 计算距离平方（更快，避免开方）
    double dist_sq = (p2 - p1).ddot(p2 - p1);
    std::cout << "   距离平方: " << dist_sq << " (用于比较时更快)" << std::endl;
    
    // 3.3 判断点是否在矩形内
    cv::Rect rect(0, 0, 100, 100);  // 矩形：左上角(0,0)，宽100，高100
    cv::Point inside(50, 50);
    cv::Point outside(150, 150);
    
    std::cout << "\n   点(50,50)在矩形(0,0,100,100)内吗？" 
              << (rect.contains(inside) ? "是" : "否") << std::endl;
    std::cout << "   点(150,150)在矩形内吗？" 
              << (rect.contains(outside) ? "是" : "否") << std::endl;
    
    return 0;
}
```

### 2.1 Point 属性和方法

#### Point 属性

| 属性 | 类型 | 说明 | 示例 |
|------|------|------|------|
| `x` | `T` | 点的x坐标 | `pt.x` |
| `y` | `T` | 点的y坐标 | `pt.y` |
| `z` | `T` | 点的z坐标（仅Point3） | `pt3.z` |

#### Point 方法

| 方法 | 返回类型 | 说明 | 示例 |
|------|----------|------|------|
| `dot(pt)` | `T` | 点积运算 | `p1.dot(p2)` |
| `ddot(pt)` | `double` | 双精度点积 | `p1.ddot(p2)` |
| `cross(pt)` | `T` | 叉积运算 | `p1.cross(p2)` |
| `inside(rect)` | `bool` | 判断点是否在矩形内 | `pt.inside(rect)` |
| `operator+` | `Point` | 点加法 | `p1 + p2` |
| `operator-` | `Point` | 点减法 | `p1 - p2` |
| `operator*` | `Point` | 与标量乘法 | `p * 2` |
| `operator/` | `Point` | 与标量除法 | `p / 2` |
| `operator-` (一元) | `Point` | 取负 | `-p` |
| `operator+=` | `Point&` | 复合加法赋值 | `p1 += p2` |
| `operator-=` | `Point&` | 复合减法赋值 | `p1 -= p2` |
| `operator*=` | `Point&` | 复合乘法赋值 | `p *= 2` |
| `operator/=` | `Point&` | 复合除法赋值 | `p /= 2` |
| `operator==` | `bool` | 相等比较 | `p1 == p2` |
| `operator!=` | `bool` | 不等比较 | `p1 != p2` |

### 2.1 Point 常用编程示例

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>
#include <vector>

int main() {
    // 1. 创建不同类型的点
    cv::Point pt1(100, 200);              // 整数点
    cv::Point2f pt2(100.5f, 200.5f);      // 浮点数点
    cv::Point3i pt3(100, 200, 300);       // 3D点
    
    std::cout << "Point1: (" << pt1.x << ", " << pt1.y << ")" << std::endl;
    std::cout << "Point2: (" << pt2.x << ", " << pt2.y << ")" << std::endl;
    std::cout << "Point3: (" << pt3.x << ", " << pt3.y << ", " << pt3.z << ")" << std::endl;
    
    // 2. 点运算
    cv::Point p1(10, 20);
    cv::Point p2(30, 40);
    
    // 基本运算
    cv::Point sum = p1 + p2;
    cv::Point diff = p2 - p1;
    cv::Point scaled = p1 * 2;
    
    std::cout << "p1 + p2 = (" << sum.x << ", " << sum.y << ")" << std::endl;
    std::cout << "p2 - p1 = (" << diff.x << ", " << diff.y << ")" << std::endl;
    std::cout << "p1 * 2 = (" << scaled.x << ", " << scaled.y << ")" << std::endl;
    
    // 3. 数学运算
    double dot_result = p1.dot(p2);               // 点积
    double cross_result = p1.cross(p2);           // 叉积
    double distance = cv::norm(p2 - p1);          // 距离
    
    std::cout << "p1·p2 = " << dot_result << std::endl;
    std::cout << "p1×p2 = " << cross_result << std::endl;
    std::cout << "距离 = " << distance << std::endl;
    
    // 4. 判断点是否在矩形内
    cv::Rect rect(0, 0, 100, 100);
    cv::Point inside_pt(50, 50);
    cv::Point outside_pt(150, 150);
    
    if (rect.contains(inside_pt)) {
        std::cout << "点(50,50)在矩形内" << std::endl;
    }
    
    if (!rect.contains(outside_pt)) {
        std::cout << "点(150,150)不在矩形内" << std::endl;
    }
    
    // 5. 存储点集合
    std::vector<cv::Point> points;
    points.push_back(cv::Point(10, 20));
    points.push_back(cv::Point(30, 40));
    points.push_back(cv::Point(50, 60));
    
    // 计算点集中心
    cv::Point center(0, 0);
    for (const auto& pt : points) {
        center += pt;
    }
    center.x /= points.size();
    center.y /= points.size();
    
    std::cout << "点集中心: (" << center.x << ", " << center.y << ")" << std::endl;
    
    // 6. 在图像上绘制点
    cv::Mat image(300, 400, CV_8UC3, cv::Scalar(255, 255, 255));
    
    // 绘制单个点
    cv::circle(image, cv::Point(100, 100), 5, cv::Scalar(0, 0, 255), -1);
    
    // 绘制点集
    for (const auto& pt : points) {
        cv::circle(image, pt, 3, cv::Scalar(255, 0, 0), -1);
    }
    
    // 绘制中心点
    cv::circle(image, center, 7, cv::Scalar(0, 255, 0), -1);
    
    cv::imshow("Points", image);
    cv::waitKey(0);
    
    return 0;
}
```

### 2.2 Size（尺寸）- 宽高表示

**中文解释：**
Size 表示二维尺寸，包含**宽度**和**高度**：
- 用于图像尺寸（宽×高）
- 用于矩形大小
- 与Point类似，但语义不同（Size是尺寸，Point是位置）

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>

int main() {
    std::cout << "=== Size 类型详解 ===" << std::endl;
    
    // ============================================
    // 1. Size 的不同精度类型
    // ============================================
    
    std::cout << "1. Size 的精度类型:" << std::endl;
    
    // 1.1 Size（整数尺寸，最常用）
    cv::Size sz_int(640, 480);      // 宽度=640，高度=480
    std::cout << "\n   cv::Size (整数尺寸):" << std::endl;
    std::cout << "     等价于 Size2i 或 Size_<int>" << std::endl;
    std::cout << "     用于图像尺寸、矩形大小" << std::endl;
    std::cout << "     示例: 宽度=" << sz_int.width << ", 高度=" << sz_int.height << std::endl;
    
    // 1.2 Size2f（浮点数尺寸）
    cv::Size2f sz_float(640.5f, 480.5f);
    std::cout << "\n   cv::Size2f (浮点数尺寸):" << std::endl;
    std::cout << "     用于需要小数精度的尺寸" << std::endl;
    
    // ============================================
    // 2. Size 的常用操作
    // ============================================
    
    std::cout << "\n\n2. Size 的运算:" << std::endl;
    
    cv::Size s1(100, 200);
    cv::Size s2(50, 100);
    
    // 2.1 尺寸加减
    cv::Size s_add = s1 + s2;       // (150, 300)
    cv::Size s_sub = s1 - s2;       // (50, 100)
    
    std::cout << "   s1 + s2 = 宽度" << s_add.width << ", 高度" << s_add.height << std::endl;
    std::cout << "   s1 - s2 = 宽度" << s_sub.width << ", 高度" << s_sub.height << std::endl;
    
    // 2.2 尺寸缩放
    cv::Size s_mul = s1 * 2;        // (200, 400) - 放大2倍
    cv::Size s_div = s1 / 2;        // (50, 100)  - 缩小2倍
    
    std::cout << "   s1 * 2 = 宽度" << s_mul.width << ", 高度" << s_mul.height << std::endl;
    std::cout << "   s1 / 2 = 宽度" << s_div.width << ", 高度" << s_div.height << std::endl;
    
    // 2.3 计算面积
    int area = s1.area();           // 100 * 200 = 20000
    std::cout << "\n   s1 的面积 = " << area << " 像素" << std::endl;
    std::cout << "   公式: width × height" << std::endl;
    
    // 2.4 判断是否为空尺寸
    cv::Size empty_size;
    cv::Size non_empty(100, 100);
    
    std::cout << "\n   尺寸判断:" << std::endl;
    std::cout << "   empty_size.empty() = " << empty_size.empty() << " (宽度或高度为0)" << std::endl;
    std::cout << "   non_empty.empty() = " << non_empty.empty() << std::endl;
    
    // 2.5 计算宽高比
    double aspect_ratio = static_cast<double>(s1.width) / s1.height;
    std::cout << "\n   s1 的宽高比 = " << aspect_ratio << std::endl;
    std::cout << "   公式: width ÷ height" << std::endl;
    std::cout << "   常见宽高比: 4:3=1.333, 16:9=1.777, 1:1=1.0" << std::endl;
    
    // ============================================
    // 3. Size 的实际应用
    // ============================================
    
    std::cout << "\n\n3. Size 的实际应用:" << std::endl;
    
    // 3.1 创建指定尺寸的图像
    cv::Size image_size(800, 600);
    cv::Mat image(image_size, CV_8UC3, cv::Scalar(0, 0, 255));  // 红色
    
    std::cout << "   创建 " << image_size.width << "×" << image_size.height << " 的红色图像" << std::endl;
    
    // 3.2 图像缩放计算
    cv::Size original(1920, 1080);  // 全高清
    cv::Size half_size(original.width / 2, original.height / 2);  // 960×540
    cv::Size double_size(original.width * 2, original.height * 2); // 3840×2160
    
    std::cout << "\n   图像缩放:" << std::endl;
    std::cout << "   原始: " << original.width << "×" << original.height << std::endl;
    std::cout << "   一半: " << half_size.width << "×" << half_size.height << std::endl;
    std::cout << "   双倍: " << double_size.width << "×" << double_size.height << std::endl;
    
    return 0;
}
```

### 2.2 Size 属性和方法

#### Size 属性

| 属性 | 类型 | 说明 | 示例 |
|------|------|------|------|
| `width` | `T` | 尺寸的宽度 | `size.width` |
| `height` | `T` | 尺寸的高度 | `size.height` |

#### Size 方法

| 方法 | 返回类型 | 说明 | 示例 |
|------|----------|------|------|
| `area()` | `T` | 计算面积（宽×高） | `size.area()` |
| `empty()` | `bool` | 判断尺寸是否为空（宽或高为0） | `size.empty()` |
| `aspectRatio()` | `double` | 计算宽高比（宽度/高度） | `size.aspectRatio()` |
| `operator+` | `Size` | 尺寸加法 | `s1 + s2` |
| `operator-` | `Size` | 尺寸减法 | `s1 - s2` |
| `operator*` | `Size` | 与标量乘法 | `s * 2` |
| `operator/` | `Size` | 与标量除法 | `s / 2` |
| `operator+=` | `Size&` | 复合加法赋值 | `s1 += s2` |
| `operator-=` | `Size&` | 复合减法赋值 | `s1 -= s2` |
| `operator*=` | `Size&` | 复合乘法赋值 | `s *= 2` |
| `operator/=` | `Size&` | 复合除法赋值 | `s /= 2` |
| `operator==` | `bool` | 相等比较 | `s1 == s2` |
| `operator!=` | `bool` | 不等比较 | `s1 != s2` |

### 2.2 Size 常用编程示例

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>

int main() {
    // 1. 创建不同尺寸
    cv::Size size1(640, 480);      // 标准VGA尺寸
    cv::Size size2(1920, 1080);    // 全高清尺寸
    cv::Size2f size3(640.5f, 480.5f);  // 浮点数尺寸
    
    std::cout << "Size1: " << size1.width << "×" << size1.height << std::endl;
    std::cout << "Size2: " << size2.width << "×" << size2.height << std::endl;
    std::cout << "Size3: " << size3.width << "×" << size3.height << std::endl;
    
    // 2. 计算面积
    int area1 = size1.area();
    int area2 = size2.area();
    
    std::cout << "Size1面积: " << area1 << " 像素" << std::endl;
    std::cout << "Size2面积: " << area2 << " 像素" << std::endl;
    
    // 3. 判断尺寸是否为空
    cv::Size empty_size(0, 0);
    cv::Size valid_size(100, 100);
    
    if (empty_size.empty()) {
        std::cout << "empty_size是空的" << std::endl;
    }
    
    if (!valid_size.empty()) {
        std::cout << "valid_size不是空的" << std::endl;
    }
    
    // 4. 尺寸运算
    cv::Size s1(100, 200);
    cv::Size s2(50, 100);
    
    cv::Size sum = s1 + s2;       // (150, 300)
    cv::Size diff = s1 - s2;      // (50, 100)
    cv::Size scaled = s1 * 2;     // (200, 400)
    
    std::cout << "s1 + s2 = " << sum.width << "×" << sum.height << std::endl;
    std::cout << "s1 - s2 = " << diff.width << "×" << diff.height << std::endl;
    std::cout << "s1 * 2 = " << scaled.width << "×" << scaled.height << std::endl;
    
    // 5. 计算宽高比
    double aspect1 = static_cast<double>(size1.width) / size1.height;
    double aspect2 = static_cast<double>(size2.width) / size2.height;
    
    std::cout << "Size1宽高比: " << aspect1 << " (4:3)" << std::endl;
    std::cout << "Size2宽高比: " << aspect2 << " (16:9)" << std::endl;
    
    // 6. 创建图像
    cv::Size image_size(400, 300);
    cv::Mat image(image_size, CV_8UC3);
    
    // 根据尺寸计算图像中心
    cv::Point center(image_size.width / 2, image_size.height / 2);
    
    // 绘制中心圆
    image.setTo(cv::Scalar(255, 255, 255));  // 白色背景
    cv::circle(image, center, 50, cv::Scalar(0, 0, 255), -1);  // 红色圆
    
    // 在图像上显示尺寸信息
    std::string text = "Size: " + std::to_string(image_size.width) + 
                      "×" + std::to_string(image_size.height);
    cv::putText(image, text, cv::Point(10, 30), 
                cv::FONT_HERSHEY_SIMPLEX, 0.7, cv::Scalar(0, 0, 0), 2);
    
    // 显示图像
    cv::imshow("Image with Size", image);
    cv::waitKey(0);
    
    // 7. 尺寸转换
    cv::Size original(800, 600);
    
    // 缩放一半
    cv::Size half(original.width / 2, original.height / 2);
    
    // 等比例缩放，保持宽高比
    double scale = 0.75;
    cv::Size scaled_proportional(original.width * scale, original.height * scale);
    
    std::cout << "原始尺寸: " << original.width << "×" << original.height << std::endl;
    std::cout << "一半尺寸: " << half.width << "×" << half.height << std::endl;
    std::cout << "75%尺寸: " << scaled_proportional.width << "×" << scaled_proportional.height << std::endl;
    
    return 0;
}
```

### 2.3 Rect（矩形）- 区域表示

**中文解释：**
Rect 表示一个矩形区域，包含：
- **位置**：左上角坐标 (x, y)
- **尺寸**：宽度 (width) 和高度 (height)

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>

int main() {
    std::cout << "=== Rect 类型详解 ===" << std::endl;
    
    // ============================================
    // 1. Rect 的创建方法
    // ============================================
    
    std::cout << "1. Rect 的创建方法:" << std::endl;
    
    // 方法1：直接指定 x, y, width, height
    cv::Rect rect1(100, 100, 200, 150);
    std::cout << "\n   方法1: Rect(x, y, width, height)" << std::endl;
    std::cout << "   Rect(100, 100, 200, 150)" << std::endl;
    std::cout << "   左上角: (100, 100)" << std::endl;
    std::cout << "   宽度: 200, 高度: 150" << std::endl;
    
    // 方法2：使用 Point 和 Size
    cv::Point top_left(100, 100);
    cv::Size rect_size(200, 150);
    cv::Rect rect2(top_left, rect_size);
    
    std::cout << "\n   方法2: Rect(Point, Size)" << std::endl;
    std::cout << "   更清晰，知道哪个是位置，哪个是尺寸" << std::endl;
    
    // 方法3：使用两个对角点
    cv::Point pt1(100, 100);
    cv::Point pt2(300, 250);  // x+width=300, y+height=250
    cv::Rect rect3(pt1, pt2);
    
    std::cout << "\n   方法3: Rect(Point1, Point2)" << std::endl;
    std::cout << "   Point2.x 必须 > Point1.x" << std::endl;
    std::cout << "   Point2.y 必须 > Point1.y" << std::endl;
    
    // ============================================
    // 2. Rect 的属性访问
    // ============================================
    
    std::cout << "\n\n2. Rect 的属性:" << std::endl;
    
    cv::Rect rect(100, 100, 200, 150);
    
    std::cout << "   基本属性:" << std::endl;
    std::cout << "   x = " << rect.x << " (左上角x坐标)" << std::endl;
    std::cout << "   y = " << rect.y << " (左上角y坐标)" << std::endl;
    std::cout << "   width = " << rect.width << " (矩形宽度)" << std::endl;
    std::cout << "   height = " << rect.height << " (矩形高度)" << std::endl;
    
    // 计算属性
    std::cout << "\n   计算属性:" << std::endl;
    
    cv::Point tl = rect.tl();  // 左上角 (top-left)
    cv::Point br = rect.br();  // 右下角 (bottom-right)
    
    std::cout << "   rect.tl() = (" << tl.x << ", " << tl.y << ") 左上角" << std::endl;
    std::cout << "   rect.br() = (" << br.x << ", " << br.y << ") 右下角" << std::endl;
    std::cout << "   注意: br.x = x + width, br.y = y + height" << std::endl;
    
    // 面积计算
    int area = rect.area();  // 200 * 150 = 30000
    std::cout << "   rect.area() = " << area << " 像素" << std::endl;
    
    // 中心点计算
    cv::Point center(rect.x + rect.width/2, rect.y + rect.height/2);
    std::cout << "   中心点 = (" << center.x << ", " << center.y << ")" << std::endl;
    
    // ============================================
    // 3. Rect 的运算（重要！）
    // ============================================
    
    std::cout << "\n\n3. Rect 的运算:" << std::endl;
    
    cv::Rect r1(0, 0, 100, 100);
    cv::Rect r2(50, 50, 100, 100);
    
    // 3.1 交集（两个矩形重叠的部分）
    cv::Rect intersect = r1 & r2;
    std::cout << "   交集 r1 & r2:" << std::endl;
    std::cout << "   矩形1: (0,0,100,100)" << std::endl;
    std::cout << "   矩形2: (50,50,100,100)" << std::endl;
    std::cout << "   交集: (" << intersect.x << "," << intersect.y 
              << "," << intersect.width << "," << intersect.height << ")" << std::endl;
    std::cout << "   重叠面积: " << intersect.area() << " 像素" << std::endl;
    
    // 3.2 并集（包含两个矩形的最小矩形）
    cv::Rect union_rect = r1 | r2;
    std::cout << "\n   并集 r1 | r2:" << std::endl;
    std::cout << "   并集: (" << union_rect.x << "," << union_rect.y 
              << "," << union_rect.width << "," << union_rect.height << ")" << std::endl;
    
    // 3.3 判断点是否在矩形内
    cv::Point inside_pt(50, 50);
    cv::Point outside_pt(150, 150);
    
    std::cout << "\n   点包含判断:" << std::endl;
    std::cout << "   点(50,50) 在矩形内？" << (r1.contains(inside_pt) ? "是" : "否") << std::endl;
    std::cout << "   点(150,150)在矩形内？" << (r1.contains(outside_pt) ? "是" : "否") << std::endl;
    
    // 3.4 矩形平移
    cv::Rect moved = r1 + cv::Point(25, 25);
    std::cout << "\n   矩形平移:" << std::endl;
    std::cout << "   原矩形: (0,0,100,100)" << std::endl;
    std::cout << "   平移(25,25): (" << moved.x << "," << moved.y 
              << "," << moved.width << "," << moved.height << ")" << std::endl;
    
    // 3.5 矩形缩放
    cv::Rect enlarged = r1 + cv::Size(50, 50);
    std::cout << "\n   矩形缩放:" << std::endl;
    std::cout << "   原矩形: (0,0,100,100)" << std::endl;
    std::cout << "   放大50: (" << enlarged.x << "," << enlarged.y 
              << "," << enlarged.width << "," << enlarged.height << ")" << std::endl;
    
    return 0;
}
```

### 2.3 Rect 属性和方法

#### Rect 属性

| 属性 | 类型 | 说明 | 示例 |
|------|------|------|------|
| `x` | `int` | 矩形左上角的x坐标 | `rect.x` |
| `y` | `int` | 矩形左上角的y坐标 | `rect.y` |
| `width` | `int` | 矩形的宽度 | `rect.width` |
| `height` | `int` | 矩形的高度 | `rect.height` |

#### Rect 方法

| 方法 | 返回类型 | 说明 | 示例 |
|------|----------|------|------|
| `area()` | `int` | 计算矩形面积 | `rect.area()` |
| `tl()` | `Point` | 获取左上角点 | `rect.tl()` |
| `br()` | `Point` | 获取右下角点 | `rect.br()` |
| `size()` | `Size` | 获取矩形尺寸 | `rect.size()` |
| `contains(Point)` | `bool` | 判断点是否在矩形内 | `rect.contains(pt)` |
| `contains(Rect)` | `bool` | 判断矩形是否包含另一个矩形 | `rect1.contains(rect2)` |
| `empty()` | `bool` | 判断矩形是否为空（宽或高≤0） | `rect.empty()` |
| `operator&` | `Rect` | 计算两个矩形的交集 | `rect1 & rect2` |
| `operator|` | `Rect` | 计算两个矩形的并集 | `rect1 \| rect2` |
| `operator+=` (Point) | `Rect&` | 平移矩形 | `rect += Point(10, 10)` |
| `operator+=` (Size) | `Rect&` | 缩放矩形 | `rect += Size(10, 10)` |
| `operator+` (Point) | `Rect` | 返回平移后的矩形 | `rect + Point(10, 10)` |
| `operator+` (Size) | `Rect` | 返回缩放后的矩形 | `rect + Size(10, 10)` |
| `operator==` | `bool` | 相等比较 | `rect1 == rect2` |
| `operator!=` | `bool` | 不等比较 | `rect1 != rect2` |

### 2.3 Rect 常用编程示例

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>
#include <vector>

int main() {
    // 1. 创建矩形
    cv::Rect rect1(50, 50, 200, 150);           // 方法1：直接指定
    cv::Rect rect2(cv::Point(100, 100), cv::Size(300, 200));  // 方法2：使用Point和Size
    cv::Rect rect3(cv::Point(50, 50), cv::Point(250, 200));   // 方法3：使用两个点
    
    std::cout << "Rect1: (" << rect1.x << ", " << rect1.y << ", "
              << rect1.width << ", " << rect1.height << ")" << std::endl;
    std::cout << "Rect2: (" << rect2.x << ", " << rect2.y << ", "
              << rect2.width << ", " << rect2.height << ")" << std::endl;
    std::cout << "Rect3: (" << rect3.x << ", " << rect3.y << ", "
              << rect3.width << ", " << rect3.height << ")" << std::endl;
    
    // 2. 获取矩形属性
    cv::Point top_left = rect1.tl();    // 左上角
    cv::Point bottom_right = rect1.br(); // 右下角
    cv::Size rect_size = rect1.size();  // 尺寸
    int area = rect1.area();            // 面积
    
    std::cout << "左上角: (" << top_left.x << ", " << top_left.y << ")" << std::endl;
    std::cout << "右下角: (" << bottom_right.x << ", " << bottom_right.y << ")" << std::endl;
    std::cout << "尺寸: " << rect_size.width << "×" << rect_size.height << std::endl;
    std::cout << "面积: " << area << " 像素" << std::endl;
    
    // 3. 判断点是否在矩形内
    cv::Point inside_pt(100, 100);
    cv::Point outside_pt(300, 300);
    
    if (rect1.contains(inside_pt)) {
        std::cout << "点(100,100)在矩形内" << std::endl;
    }
    
    if (!rect1.contains(outside_pt)) {
        std::cout << "点(300,300)不在矩形内" << std::endl;
    }
    
    // 4. 矩形运算
    cv::Rect r1(0, 0, 100, 100);
    cv::Rect r2(50, 50, 100, 100);
    
    // 交集
    cv::Rect intersect = r1 & r2;
    std::cout << "交集: (" << intersect.x << ", " << intersect.y << ", "
              << intersect.width << ", " << intersect.height << ")" << std::endl;
    
    // 并集
    cv::Rect union_rect = r1 | r2;
    std::cout << "并集: (" << union_rect.x << ", " << union_rect.y << ", "
              << union_rect.width << ", " << union_rect.height << ")" << std::endl;
    
    // 平移矩形
    cv::Rect moved = r1 + cv::Point(25, 25);
    std::cout << "平移后: (" << moved.x << ", " << moved.y << ", "
              << moved.width << ", " << moved.height << ")" << std::endl;
    
    // 缩放矩形
    cv::Rect enlarged = r1 + cv::Size(50, 50);
    std::cout << "放大后: (" << enlarged.x << ", " << enlarged.y << ", "
              << enlarged.width << ", " << enlarged.height << ")" << std::endl;
    
    // 5. 在图像上绘制矩形
    cv::Mat image(400, 600, CV_8UC3, cv::Scalar(255, 255, 255));
    
    // 绘制矩形
    cv::rectangle(image, rect1, cv::Scalar(0, 0, 255), 2);      // 红色边框
    cv::rectangle(image, rect2, cv::Scalar(255, 0, 0), -1);     // 蓝色填充
    
    // 绘制交集区域
    cv::rectangle(image, intersect, cv::Scalar(0, 255, 0), 2);  // 绿色边框
    
    // 在矩形中心标记点
    cv::Point center1(rect1.x + rect1.width/2, rect1.y + rect1.height/2);
    cv::Point center2(rect2.x + rect2.width/2, rect2.y + rect2.height/2);
    
    cv::circle(image, center1, 5, cv::Scalar(0, 0, 0), -1);
    cv::circle(image, center2, 5, cv::Scalar(0, 0, 0), -1);
    
    // 6. 矩形在图像处理中的应用 - ROI（感兴趣区域）
    cv::Mat original = cv::imread("example.jpg");
    if (!original.empty()) {
        // 定义脸部区域（假设坐标）
        cv::Rect face_roi(100, 100, 200, 250);
        
        // 提取ROI（注意：这是浅拷贝，共享数据）
        cv::Mat face = original(face_roi);
        
        // 对ROI进行处理（例如：高斯模糊）
        cv::GaussianBlur(face, face, cv::Size(15, 15), 0);
        
        // 显示结果
        cv::imshow("Original with Blurred Face", original);
        cv::waitKey(0);
    }
    
    // 7. 矩形集合操作
    std::vector<cv::Rect> rectangles;
    rectangles.push_back(cv::Rect(10, 10, 50, 50));
    rectangles.push_back(cv::Rect(30, 30, 60, 60));
    rectangles.push_back(cv::Rect(70, 70, 80, 80));
    
    // 计算包围所有矩形的边界框
    if (!rectangles.empty()) {
        cv::Rect bounding_box = rectangles[0];
        for (size_t i = 1; i < rectangles.size(); i++) {
            bounding_box = bounding_box | rectangles[i];
        }
        
        std::cout << "边界框: (" << bounding_box.x << ", " << bounding_box.y << ", "
                  << bounding_box.width << ", " << bounding_box.height << ")" << std::endl;
    }
    
    cv::imshow("Rectangles", image);
    cv::waitKey(0);
    
    return 0;
}
```

### 2.4 Scalar（标量）- 颜色表示

**中文解释：**
Scalar 是一个4元素向量，主要用于：
1. **表示BGR颜色**（3个或4个值）
2. **表示像素值**（灰度图像1个值）
3. **进行数学运算**

**重要：OpenCV使用BGR顺序，不是RGB！**

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>

int main() {
    std::cout << "=== Scalar 类型详解 ===" << std::endl;
    
    // ============================================
    // 1. Scalar 的颜色表示
    // ============================================
    
    std::cout << "1. Scalar 的颜色表示（BGR顺序）:" << std::endl;
    std::cout << "   格式: Scalar(蓝色, 绿色, 红色 [, 透明度])" << std::endl;
    std::cout << "   OpenCV使用BGR顺序，不是RGB！" << std::endl;
    
    // 基本颜色
    cv::Scalar blue(255, 0, 0);      // 纯蓝色：B=255, G=0, R=0
    cv::Scalar green(0, 255, 0);     // 纯绿色：B=0, G=255, R=0
    cv::Scalar red(0, 0, 255);       // 纯红色：B=0, G=0, R=255
    cv::Scalar white(255, 255, 255); // 白色：B=255, G=255, R=255
    cv::Scalar black(0, 0, 0);       // 黑色：B=0, G=0, R=0
    
    std::cout << "\n   基本颜色:" << std::endl;
    std::cout << "   蓝色: Scalar(255, 0, 0)" << std::endl;
    std::cout << "   绿色: Scalar(0, 255, 0)" << std::endl;
    std::cout << "   红色: Scalar(0, 0, 255)" << std::endl;
    std::cout << "   白色: Scalar(255, 255, 255)" << std::endl;
    std::cout << "   黑色: Scalar(0, 0, 0)" << std::endl;
    
    // 灰度值（单通道）
    cv::Scalar gray128(128);        // 所有通道=128（灰色）
    cv::Scalar gray64(64, 64, 64);  // 等价写法
    
    std::cout << "\n   灰度值:" << std::endl;
    std::cout << "   灰色: Scalar(128) 或 Scalar(128,128,128)" << std::endl;
    std::cout << "   Scalar(单值) 表示所有通道相同" << std::endl;
    
    // 带透明度的颜色（4通道）
    cv::Scalar semi_blue(255, 0, 0, 128);  // 半透明蓝色
    std::cout << "\n   带透明度:" << std::endl;
    std::cout << "   半透明蓝色: Scalar(255, 0, 0, 128)" << std::endl;
    std::cout << "   透明度: 0=完全透明, 255=完全不透明" << std::endl;
    
    // ============================================
    // 2. Scalar 的数学运算
    // ============================================
    
    std::cout << "\n\n2. Scalar 的数学运算:" << std::endl;
    
    cv::Scalar s1(100, 150, 200);
    cv::Scalar s2(50, 50, 50);
    
    // 2.1 加减运算
    cv::Scalar sum = s1 + s2;   // (150, 200, 250)
    cv::Scalar diff = s1 - s2;  // (50, 100, 150)
    
    std::cout << "   s1 + s2 = (" << sum[0] << ", " << sum[1] << ", " << sum[2] << ")" << std::endl;
    std::cout << "   s1 - s2 = (" << diff[0] << ", " << diff[1] << ", " << diff[2] << ")" << std::endl;
    
    // 2.2 标量乘法
    cv::Scalar scaled = s1 * 1.5;  // (150, 225, 300)
    std::cout << "   s1 * 1.5 = (" << scaled[0] << ", " << scaled[1] << ", " << scaled[2] << ")" << std::endl;
    
    // 2.3 逐元素乘法
    cv::Scalar mul = s1.mul(s2);   // (5000, 7500, 10000)
    std::cout << "   s1.mul(s2) = 逐元素相乘" << std::endl;
    std::cout << "   公式: (100×50, 150×50, 200×50)" << std::endl;
    
    // 2.4 点积（内积）
    double dot = s1.dot(s2);       // 100×50 + 150×50 + 200×50 = 22500
    std::cout << "\n   点积 s1·s2 = " << dot << std::endl;
    
    // ============================================
    // 3. Scalar 的实际应用
    // ============================================
    
    std::cout << "\n\n3. Scalar 的实际应用:" << std::endl;
    
    // 3.1 创建纯色图像
    cv::Mat blue_image(300, 400, CV_8UC3, cv::Scalar(255, 0, 0));
    std::cout << "   创建蓝色图像: Mat(300,400,CV_8UC3, Scalar(255,0,0))" << std::endl;
    
    // 3.2 设置图像颜色
    cv::Mat image(300, 400, CV_8UC3);
    image.setTo(cv::Scalar(0, 0, 255));  // 设置为红色
    std::cout << "   设置图像颜色: image.setTo(Scalar(0,0,255))" << std::endl;
    
    // 3.3 颜色混合
    cv::Scalar color1(255, 0, 0);   // 蓝色
    cv::Scalar color2(0, 0, 255);   // 红色
    cv::Scalar mixed = color1 * 0.7 + color2 * 0.3;  // 70%蓝 + 30%红
    
    std::cout << "\n   颜色混合:" << std::endl;
    std::cout << "   蓝色×0.7 + 红色×0.3" << std::endl;
    std::cout << "   结果: B=" << mixed[0] << ", G=" << mixed[1] << ", R=" << mixed[2] << std::endl;
    std::cout << "   (178, 0, 76) 是蓝紫色" << std::endl;
    
    // 3.4 访问和修改
    cv::Scalar color(100, 150, 200, 255);
    std::cout << "\n   Scalar 元素访问:" << std::endl;
    std::cout << "   color[0] = " << color[0] << " (蓝色)" << std::endl;
    std::cout << "   color[1] = " << color[1] << " (绿色)" << std::endl;
    std::cout << "   color[2] = " << color[2] << " (红色)" << std::endl;
    std::cout << "   color[3] = " << color[3] << " (透明度)" << std::endl;
    
    return 0;
}
```

### 2.4 Scalar 属性和方法

#### Scalar 属性

Scalar 是模板类 `Scalar_<T>` 的别名，其中 T 通常是 double 类型。它本质上是一个4元素向量。

| 特性 | 说明 | 示例 |
|------|------|------|
| 元素访问 | 通过下标运算符访问4个元素 | `scalar[0]`, `scalar[1]`, `scalar[2]`, `scalar[3]` |
| 默认值 | 未指定的元素默认为0 | `Scalar(255,0,0)` 等价于 `Scalar(255,0,0,0)` |

#### Scalar 方法

| 方法 | 返回类型 | 说明 | 示例 |
|------|----------|------|------|
| `operator[]` | `T&` | 访问指定位置的元素 | `scalar[0] = 255` |
| `mul(s)` | `Scalar` | 逐元素乘法 | `s1.mul(s2)` |
| `conj()` | `Scalar` | 返回共轭（对复数有效） | `s.conj()` |
| `dot(s)` | `T` | 点积运算 | `s1.dot(s2)` |
| `operator+` | `Scalar` | 标量加法 | `s1 + s2` |
| `operator-` | `Scalar` | 标量减法 | `s1 - s2` |
| `operator*` | `Scalar` | 与数值乘法 | `s * 2.0` |
| `operator/` | `Scalar` | 与数值除法 | `s / 2.0` |
| `operator==` | `bool` | 相等比较 | `s1 == s2` |
| `operator!=` | `bool` | 不等比较 | `s1 != s2` |
| `isReal()` | `bool` | 判断是否为实数（虚部全为0） | `s.isReal()` |

### 2.4 Scalar 常用编程示例

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>
#include <iomanip>

int main() {
    // 1. 创建不同颜色
    cv::Scalar blue(255, 0, 0);           // 蓝色
    cv::Scalar green(0, 255, 0);          // 绿色
    cv::Scalar red(0, 0, 255);            // 红色
    cv::Scalar white(255, 255, 255);      // 白色
    cv::Scalar black(0, 0, 0);            // 黑色
    cv::Scalar gray(128);                 // 灰色（单值）
    cv::Scalar yellow(0, 255, 255);       // 黄色（绿色+红色）
    cv::Scalar magenta(255, 0, 255);      // 洋红色（蓝色+红色）
    cv::Scalar cyan(255, 255, 0);         // 青色（蓝色+绿色）
    cv::Scalar semi_transparent(0, 0, 255, 128); // 半透明红色
    
    std::cout << "蓝色: B=" << (int)blue[0] << ", G=" << (int)blue[1] 
              << ", R=" << (int)blue[2] << std::endl;
    std::cout << "灰色: B=" << (int)gray[0] << ", G=" << (int)gray[1] 
              << ", R=" << (int)gray[2] << std::endl;
    
    // 2. 创建纯色图像
    cv::Mat blue_image(300, 400, CV_8UC3, blue);
    cv::Mat red_image(300, 400, CV_8UC3, red);
    cv::Mat gradient_image(300, 400, CV_8UC3);
    
    // 3. 设置图像颜色
    cv::Mat image(300, 400, CV_8UC3);
    image.setTo(blue);  // 设置为蓝色
    cv::rectangle(image, cv::Rect(50, 50, 100, 100), red, -1);  // 绘制红色矩形
    
    // 4. 颜色混合
    // 线性插值：color = (1-alpha)*color1 + alpha*color2
    cv::Scalar color1(255, 0, 0);   // 蓝色
    cv::Scalar color2(0, 0, 255);   // 红色
    
    for (int i = 0; i <= 10; i++) {
        double alpha = i / 10.0;
        cv::Scalar mixed = color1 * (1.0 - alpha) + color2 * alpha;
        
        std::cout << "Alpha=" << std::fixed << std::setprecision(1) << alpha 
                  << ": B=" << std::setw(3) << (int)mixed[0]
                  << ", G=" << std::setw(3) << (int)mixed[1]
                  << ", R=" << std::setw(3) << (int)mixed[2] << std::endl;
    }
    
    // 5. 数学运算
    cv::Scalar s1(100, 150, 200);
    cv::Scalar s2(50, 75, 100);
    
    cv::Scalar sum = s1 + s2;           // 加法
    cv::Scalar diff = s1 - s2;          // 减法
    cv::Scalar scaled = s1 * 1.5;       // 标量乘法
    cv::Scalar elementwise_mul = s1.mul(s2);  // 逐元素乘法
    double dot_product = s1.dot(s2);    // 点积
    
    std::cout << "\n数学运算:" << std::endl;
    std::cout << "s1 + s2 = (" << sum[0] << ", " << sum[1] << ", " << sum[2] << ")" << std::endl;
    std::cout << "s1 - s2 = (" << diff[0] << ", " << diff[1] << ", " << diff[2] << ")" << std::endl;
    std::cout << "s1 * 1.5 = (" << scaled[0] << ", " << scaled[1] << ", " << scaled[2] << ")" << std::endl;
    std::cout << "s1.mul(s2) = (" << elementwise_mul[0] << ", " << elementwise_mul[1] 
              << ", " << elementwise_mul[2] << ")" << std::endl;
    std::cout << "s1·s2 = " << dot_product << std::endl;
    
    // 6. 创建渐变图像
    for (int y = 0; y < gradient_image.rows; y++) {
        for (int x = 0; x < gradient_image.cols; x++) {
            // 水平渐变：从左到右从蓝色变为红色
            double ratio = static_cast<double>(x) / gradient_image.cols;
            cv::Scalar pixel_color = blue * (1.0 - ratio) + red * ratio;
            
            gradient_image.at<cv::Vec3b>(y, x) = cv::Vec3b(
                static_cast<uchar>(pixel_color[0]),
                static_cast<uchar>(pixel_color[1]),
                static_cast<uchar>(pixel_color[2])
            );
        }
    }
    
    // 7. 颜色空间转换示例
    cv::Mat hsv_image(300, 400, CV_8UC3);
    hsv_image.setTo(cv::Scalar(120, 255, 255));  // HSV颜色：绿色
    
    cv::Mat bgr_image;
    cv::cvtColor(hsv_image, bgr_image, cv::COLOR_HSV2BGR);
    
    // 8. 在图像上绘制彩色文本和图形
    cv::Mat canvas(500, 600, CV_8UC3, cv::Scalar(240, 240, 240));  // 浅灰色背景
    
    // 绘制彩色矩形
    cv::rectangle(canvas, cv::Rect(50, 50, 100, 100), blue, -1);
    cv::rectangle(canvas, cv::Rect(200, 50, 100, 100), green, -1);
    cv::rectangle(canvas, cv::Rect(350, 50, 100, 100), red, -1);
    
    // 绘制彩色圆形
    cv::circle(canvas, cv::Point(100, 250), 50, yellow, -1);
    cv::circle(canvas, cv::Point(250, 250), 50, magenta, -1);
    cv::circle(canvas, cv::Point(400, 250), 50, cyan, -1);
    
    // 添加文本
    cv::putText(canvas, "Blue", cv::Point(65, 130), 
                cv::FONT_HERSHEY_SIMPLEX, 0.7, white, 2);
    cv::putText(canvas, "Green", cv::Point(210, 130), 
                cv::FONT_HERSHEY_SIMPLEX, 0.7, black, 2);
    cv::putText(canvas, "Red", cv::Point(375, 130), 
                cv::FONT_HERSHEY_SIMPLEX, 0.7, white, 2);
    
    // 显示图像
    cv::imshow("Blue Image", blue_image);
    cv::imshow("Gradient", gradient_image);
    cv::imshow("Color Palette", canvas);
    cv::waitKey(0);
    
    // 9. 使用Scalar进行图像通道操作
    cv::Mat multi_channel_image(100, 100, CV_8UC3);
    
    // 分离通道
    std::vector<cv::Mat> channels;
    cv::split(multi_channel_image, channels);
    
    // 使用Scalar设置单个通道
    channels[0].setTo(255);  // 蓝色通道设为255
    channels[1].setTo(128);  // 绿色通道设为128
    channels[2].setTo(0);    // 红色通道设为0
    
    // 合并通道
    cv::merge(channels, multi_channel_image);
    
    return 0;
}
```

## 三、其他重要类型

### 3.1 Vec（向量）- 多通道数据

**中文解释：**
Vec 是模板类，用于表示**小型固定长度的向量**，主要用于：
- 表示多通道像素值（如 Vec3b 表示BGR像素）
- 进行向量数学运算
- 存储小型数组

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>

int main() {
    std::cout << "=== Vec 类型详解 ===" << std::endl;
    
    // ============================================
    // 1. Vec 的常见类型
    // ============================================
    
    std::cout << "1. Vec 的常见类型（格式: Vec<元素类型, 通道数>）:" << std::endl;
    
    // 1.1 8位无符号整数（uchar） - 最常用
    cv::Vec3b pixel_bgr(100, 150, 200);  // B=100, G=150, R=200
    std::cout << "\n   cv::Vec3b (3通道uchar):" << std::endl;
    std::cout << "     用于BGR彩色像素" << std::endl;
    std::cout << "     示例: (" << (int)pixel_bgr[0] << ", " 
              << (int)pixel_bgr[1] << ", " << (int)pixel_bgr[2] << ")" << std::endl;
    
    // 1.2 单精度浮点数（float）
    cv::Vec3f point_3d(1.5f, 2.5f, 3.5f);  // 3D坐标
    std::cout << "\n   cv::Vec3f (3通道float):" << std::endl;
    std::cout << "     用于3D坐标、浮点颜色" << std::endl;
    
    // 1.3 双精度浮点数（double）
    cv::Vec3d point_3d_d(1.5, 2.5, 3.5);
    std::cout << "\n   cv::Vec3d (3通道double):" << std::endl;
    std::cout << "     用于高精度计算" << std::endl;
    
    // 1.4 带透明度的像素
    cv::Vec4b pixel_bgra(100, 150, 200, 255);  // BGRA
    std::cout << "\n   cv::Vec4b (4通道uchar):" << std::endl;
    std::cout << "     用于带透明度的像素" << std::endl;
    
    // ============================================
    // 2. Vec 的数学运算
    // ============================================
    
    std::cout << "\n\n2. Vec 的数学运算:" << std::endl;
    
    cv::Vec3f v1(1.0f, 2.0f, 3.0f);
    cv::Vec3f v2(4.0f, 5.0f, 6.0f);
    
    // 2.1 向量加减
    cv::Vec3f v_sum = v1 + v2;   // (5.0, 7.0, 9.0)
    cv::Vec3f v_diff = v2 - v1;  // (3.0, 3.0, 3.0)
    
    std::cout << "   v1 + v2 = (" << v_sum[0] << ", " << v_sum[1] << ", " << v_sum[2] << ")" << std::endl;
    std::cout << "   v2 - v1 = (" << v_diff[0] << ", " << v_diff[1] << ", " << v_diff[2] << ")" << std::endl;
    
    // 2.2 向量与标量运算
    cv::Vec3f v_scaled = v1 * 2.0f;  // (2.0, 4.0, 6.0)
    std::cout << "   v1 * 2.0 = (" << v_scaled[0] << ", " << v_scaled[1] << ", " << v_scaled[2] << ")" << std::endl;
    
    // 2.3 点积（内积）
    float dot = v1.dot(v2);  // 1*4 + 2*5 + 3*6 = 32
    std::cout << "\n   点积 v1·v2 = " << dot << std::endl;
    std::cout << "   几何意义: 两个向量的乘积" << std::endl;
    
    // 2.4 叉积（外积） - 3D向量
    cv::Vec3f cross = v1.cross(v2);  // (2*6-3*5, 3*4-1*6, 1*5-2*4) = (-3, 6, -3)
    std::cout << "\n   叉积 v1×v2 = (" << cross[0] << ", " << cross[1] << ", " << cross[2] << ")" << std::endl;
    std::cout << "   几何意义: 垂直于v1和v2的向量" << std::endl;
    
    // 2.5 向量长度（范数）
    float norm_v1 = cv::norm(v1);  // sqrt(1² + 2² + 3²) = √14 ≈ 3.741
    std::cout << "\n   向量长度 ||v1|| = " << norm_v1 << std::endl;
    
    // 2.6 向量归一化（单位向量）
    cv::Vec3f normalized = v1 / norm_v1;
    std::cout << "   归一化向量 = (" << normalized[0] << ", " << normalized[1] << ", " << normalized[2] << ")" << std::endl;
    std::cout << "   归一化后长度 = " << cv::norm(normalized) << " (应该≈1.0)" << std::endl;
    
    return 0;
}
```

### 3.1 Vec 属性和方法

#### Vec 属性

Vec 是模板类 `Vec<T, cn>`，其中 T 是元素类型，cn 是通道数。

| 特性 | 说明 | 示例 |
|------|------|------|
| 元素访问 | 通过下标运算符访问元素 | `vec[0]`, `vec[1]`, ... |
| 通道数 | 模板参数 cn 指定向量长度 | `Vec3b` 有3个通道 |
| 元素类型 | 模板参数 T 指定元素类型 | `Vec3b` 元素类型是 `uchar` |

#### Vec 方法

| 方法 | 返回类型 | 说明 | 示例 |
|------|----------|------|------|
| `operator[]` | `T&` | 访问指定位置的元素 | `vec[0] = 255` |
| `dot(v)` | `T` | 点积运算 | `v1.dot(v2)` |
| `cross(v)` | `Vec<T,3>` | 叉积运算（仅3通道） | `v1.cross(v2)` |
| `mul(v)` | `Vec` | 逐元素乘法 | `v1.mul(v2)` |
| `conj()` | `Vec` | 返回共轭（对复数有效） | `v.conj()` |
| `operator+` | `Vec` | 向量加法 | `v1 + v2` |
| `operator-` | `Vec` | 向量减法 | `v1 - v2` |
| `operator*` | `Vec` | 与标量乘法 | `v * 2.0` |
| `operator/` | `Vec` | 与标量除法 | `v / 2.0` |
| `operator-` (一元) | `Vec` | 取负 | `-v` |
| `operator==` | `bool` | 相等比较 | `v1 == v2` |
| `operator!=` | `bool` | 不等比较 | `v1 != v2` |

### 3.1 Vec 常用编程示例

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>
#include <cmath>

int main() {
    // 1. 创建不同维度和类型的向量
    cv::Vec2b vec2b(100, 200);          // 2通道，uchar类型
    cv::Vec3b vec3b(100, 150, 200);     // 3通道，uchar类型（BGR像素）
    cv::Vec4b vec4b(100, 150, 200, 255); // 4通道，uchar类型（BGRA像素）
    cv::Vec3f vec3f(1.5f, 2.5f, 3.5f);  // 3通道，float类型
    cv::Vec3d vec3d(1.5, 2.5, 3.5);     // 3通道，double类型
    cv::Vec6f vec6f(1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f); // 6通道，float类型
    
    std::cout << "Vec3b: (" << (int)vec3b[0] << ", " << (int)vec3b[1] 
              << ", " << (int)vec3b[2] << ")" << std::endl;
    std::cout << "Vec3f: (" << vec3f[0] << ", " << vec3f[1] 
              << ", " << vec3f[2] << ")" << std::endl;
    
    // 2. 向量运算
    cv::Vec3f v1(1.0f, 2.0f, 3.0f);
    cv::Vec3f v2(4.0f, 5.0f, 6.0f);
    
    cv::Vec3f sum = v1 + v2;      // 向量加法
    cv::Vec3f diff = v2 - v1;     // 向量减法
    cv::Vec3f scaled = v1 * 2.0f; // 标量乘法
    
    std::cout << "\n向量运算:" << std::endl;
    std::cout << "v1 + v2 = (" << sum[0] << ", " << sum[1] << ", " << sum[2] << ")" << std::endl;
    std::cout << "v2 - v1 = (" << diff[0] << ", " << diff[1] << ", " << diff[2] << ")" << std::endl;
    std::cout << "v1 * 2 = (" << scaled[0] << ", " << scaled[1] << ", " << scaled[2] << ")" << std::endl;
    
    // 3. 点积和叉积
    float dot_product = v1.dot(v2);          // 点积
    cv::Vec3f cross_product = v1.cross(v2);  // 叉积（仅3D向量）
    
    std::cout << "\n点积 v1·v2 = " << dot_product << std::endl;
    std::cout << "叉积 v1×v2 = (" << cross_product[0] << ", " 
              << cross_product[1] << ", " << cross_product[2] << ")" << std::endl;
    
    // 4. 向量长度和归一化
    float length = cv::norm(v1);                     // 向量长度
    cv::Vec3f normalized = v1 / length;              // 归一化
    
    std::cout << "\n向量长度 ||v1|| = " << length << std::endl;
    std::cout << "归一化向量 = (" << normalized[0] << ", " 
              << normalized[1] << ", " << normalized[2] << ")" << std::endl;
    std::cout << "归一化后长度 = " << cv::norm(normalized) << std::endl;
    
    // 5. 在图像处理中使用Vec
    cv::Mat image(300, 400, CV_8UC3, cv::Scalar(255, 255, 255)); // 白色背景
    
    // 使用Vec3b访问和修改像素
    for (int y = 100; y < 200; y++) {
        for (int x = 100; x < 300; x++) {
            cv::Vec3b& pixel = image.at<cv::Vec3b>(y, x);
            
            // 创建渐变效果
            pixel[0] = static_cast<uchar>(255 * (x - 100) / 200.0);  // 蓝色通道
            pixel[1] = static_cast<uchar>(255 * (y - 100) / 100.0);  // 绿色通道
            pixel[2] = 255 - static_cast<uchar>(255 * (x - 100) / 200.0); // 红色通道
        }
    }
    
    // 6. 颜色转换示例
    cv::Mat color_image(100, 100, CV_8UC3);
    
    // 遍历所有像素
    for (int y = 0; y < color_image.rows; y++) {
        for (int x = 0; x < color_image.cols; x++) {
            cv::Vec3b pixel;
            
            // 计算HSV颜色（然后转换为BGR）
            float hue = static_cast<float>(x) / color_image.cols * 360.0f;
            float saturation = 1.0f;
            float value = static_cast<float>(y) / color_image.rows;
            
            // HSV到RGB转换（简化版）
            float c = value * saturation;
            float x_h = c * (1 - std::abs(std::fmod(hue / 60.0f, 2) - 1));
            float m = value - c;
            
            float r, g, b;
            if (hue < 60) { r = c; g = x_h; b = 0; }
            else if (hue < 120) { r = x_h; g = c; b = 0; }
            else if (hue < 180) { r = 0; g = c; b = x_h; }
            else if (hue < 240) { r = 0; g = x_h; b = c; }
            else if (hue < 300) { r = x_h; g = 0; b = c; }
            else { r = c; g = 0; b = x_h; }
            
            pixel[2] = static_cast<uchar>((r + m) * 255); // R
            pixel[1] = static_cast<uchar>((g + m) * 255); // G
            pixel[0] = static_cast<uchar>((b + m) * 255); // B
            
            color_image.at<cv::Vec3b>(y, x) = pixel;
        }
    }
    
    // 7. 使用Vec进行像素级操作
    cv::Mat src1(100, 100, CV_8UC3, cv::Scalar(100, 150, 200));
    cv::Mat src2(100, 100, CV_8UC3, cv::Scalar(50, 75, 100));
    cv::Mat dst(100, 100, CV_8UC3);
    
    // 逐像素混合
    for (int y = 0; y < src1.rows; y++) {
        for (int x = 0; x < src1.cols; x++) {
            cv::Vec3b pixel1 = src1.at<cv::Vec3b>(y, x);
            cv::Vec3b pixel2 = src2.at<cv::Vec3b>(y, x);
            
            // 加权平均
            cv::Vec3b blended = pixel1 * 0.7 + pixel2 * 0.3;
            dst.at<cv::Vec3b>(y, x) = blended;
        }
    }
    
    // 8. 显示结果
    cv::imshow("Gradient Image", image);
    cv::imshow("HSV Color Wheel", color_image);
    cv::imshow("Blended Image", dst);
    cv::waitKey(0);
    
    // 9. 向量在矩阵运算中的应用
    cv::Mat points_mat = (cv::Mat_<float>(3, 3) << 
        1.0, 2.0, 3.0,
        4.0, 5.0, 6.0,
        7.0, 8.0, 9.0);
    
    // 访问矩阵的行作为向量
    cv::Vec3f row1 = points_mat.row(0);
    cv::Vec3f row2 = points_mat.row(1);
    
    std::cout << "\n矩阵行作为向量:" << std::endl;
    std::cout << "行1: (" << row1[0] << ", " << row1[1] << ", " << row1[2] << ")" << std::endl;
    std::cout << "行2: (" << row2[0] << ", " << row2[1] << ", " << row2[2] << ")" << std::endl;
    
    return 0;
}
```

### 3.2 Range（范围）- 连续序列

**中文解释：**
Range 表示一个**连续的整数序列** [start, end)，包含start，不包含end。

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>

int main() {
    std::cout << "=== Range 类型详解 ===" << std::endl;
    
    // ============================================
    // 1. Range 的基本概念
    // ============================================
    
    std::cout << "1. Range 的基本概念:" << std::endl;
    std::cout << "   Range(start, end): 包含start，不包含end [start, end)" << std::endl;
    std::cout << "   元素个数 = end - start" << std::endl;
    
    cv::Range r1(0, 10);    // 包含0-9，共10个元素
    cv::Range r2(5, 15);    // 包含5-14，共10个元素
    
    std::cout << "\n   Range(0, 10):" << std::endl;
    std::cout << "   包含索引: 0, 1, 2, ..., 9" << std::endl;
    std::cout << "   元素个数: " << r1.size() << std::endl;
    
    std::cout << "\n   Range(5, 15):" << std::endl;
    std::cout << "   包含索引: 5, 6, 7, ..., 14" << std::endl;
    std::cout << "   元素个数: " << r2.size() << std::endl;
    
    // ============================================
    // 2. Range 的特殊值
    // ============================================
    
    std::cout << "\n\n2. Range 的特殊值:" << std::endl;
    
    // 空范围
    cv::Range empty_range;  // 默认 (0, 0)
    std::cout << "   空范围 Range():" << std::endl;
    std::cout << "   start=0, end=0, size=0" << std::endl;
    std::cout << "   empty() = " << empty_range.empty() << std::endl;
    
    // 全部范围
    cv::Range all_range = cv::Range::all();
    std::cout << "\n   全部范围 Range::all():" << std::endl;
    std::cout << "   表示所有元素" << std::endl;
    std::cout << "   特殊值，用于选择所有行或列" << std::endl;
    
    // ============================================
    // 3. Range 与 Mat 结合使用
    // ============================================
    
    std::cout << "\n\n3. Range 与 Mat 结合使用:" << std::endl;
    
    // 创建5×5矩阵
    cv::Mat matrix = (cv::Mat_<int>(5, 5) <<
        1,  2,  3,  4,  5,
        6,  7,  8,  9,  10,
        11, 12, 13, 14, 15,
        16, 17, 18, 19, 20,
        21, 22, 23, 24, 25);
    
    std::cout << "   原始5×5矩阵:" << std::endl;
    std::cout << matrix << std::endl;
    
    // 使用Range选择子矩阵
    cv::Range rows(1, 4);  // 选择第2-4行（索引1,2,3）
    cv::Range cols(1, 4);  // 选择第2-4列（索引1,2,3）
    
    cv::Mat submatrix = matrix(rows, cols);
    std::cout << "\n   选择行[1,4)和列[1,4):" << std::endl;
    std::cout << "   即第2-4行，第2-4列" << std::endl;
    std::cout << submatrix << std::endl;
    
    // 选择所有行，部分列
    cv::Mat all_rows = matrix(cv::Range::all(), cv::Range(2, 5));
    std::cout << "\n   选择所有行，列[2,5):" << std::endl;
    std::cout << "   即所有行，第3-5列" << std::endl;
    std::cout << all_rows << std::endl;
    
    return 0;
}
```

### 3.2 Range 属性和方法

#### Range 属性

| 属性 | 类型 | 说明 | 示例 |
|------|------|------|------|
| `start` | `int` | 范围的起始索引（包含） | `range.start` |
| `end` | `int` | 范围的结束索引（不包含） | `range.end` |

#### Range 方法

| 方法 | 返回类型 | 说明 | 示例 |
|------|----------|------|------|
| `size()` | `int` | 返回范围中的元素数量 | `range.size()` |
| `empty()` | `bool` | 判断范围是否为空（start == end） | `range.empty()` |
| `all()` | `Range` | 静态方法，返回表示"所有"的特殊范围 | `Range::all()` |
| `shift(int delta)` | `Range` | 平移范围 | `range.shift(10)` |
| `operator==` | `bool` | 相等比较 | `r1 == r2` |
| `operator!=` | `bool` | 不等比较 | `r1 != r2` |
| `operator&` | `Range` | 计算两个范围的交集 | `r1 & r2` |

### 3.2 Range 常用编程示例

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>
#include <vector>

int main() {
    // 1. 创建范围
    cv::Range r1(0, 10);          // 包含0-9
    cv::Range r2(5, 15);          // 包含5-14
    cv::Range r3(20, 30);         // 包含20-29
    cv::Range empty_range;        // 空范围 (0, 0)
    cv::Range all_range = cv::Range::all(); // 全部范围
    
    std::cout << "Range(0, 10): start=" << r1.start << ", end=" << r1.end 
              << ", size=" << r1.size() << std::endl;
    std::cout << "Range(5, 15): start=" << r2.start << ", end=" << r2.end 
              << ", size=" << r2.size() << std::endl;
    std::cout << "空范围: start=" << empty_range.start << ", end=" << empty_range.end 
              << ", empty=" << (empty_range.empty() ? "true" : "false") << std::endl;
    
    // 2. 范围运算
    // 平移范围
    cv::Range shifted = r1.shift(5);  // (5, 15)
    std::cout << "Range(0,10)平移5: (" << shifted.start << ", " << shifted.end << ")" << std::endl;
    
    // 范围交集
    cv::Range intersection = r1 & r2;  // (5, 10)
    std::cout << "Range(0,10)与Range(5,15)的交集: (" 
              << intersection.start << ", " << intersection.end << ")" << std::endl;
    
    // 3. 在数组中使用Range
    std::vector<int> data(20);
    for (int i = 0; i < 20; i++) {
        data[i] = i * 2;
    }
    
    // 使用Range选择子集
    cv::Range selection(5, 10);
    std::cout << "\n数组索引[5,10)的元素: ";
    for (int i = selection.start; i < selection.end; i++) {
        std::cout << data[i] << " ";
    }
    std::cout << std::endl;
    
    // 4. 在Mat矩阵中使用Range
    // 创建10×10矩阵
    cv::Mat matrix(10, 10, CV_32FC1);
    for (int i = 0; i < matrix.rows; i++) {
        for (int j = 0; j < matrix.cols; j++) {
            matrix.at<float>(i, j) = i * 10.0f + j;
        }
    }
    
    std::cout << "\n原始矩阵 (显示前5×5):" << std::endl;
    for (int i = 0; i < 5; i++) {
        for (int j = 0; j < 5; j++) {
            std::cout << matrix.at<float>(i, j) << "\t";
        }
        std::cout << std::endl;
    }
    
    // 使用Range选择子矩阵
    cv::Range rows(2, 6);    // 第3-6行（索引2,3,4,5）
    cv::Range cols(3, 7);    // 第4-7列（索引3,4,5,6）
    
    cv::Mat submatrix = matrix(rows, cols);
    
    std::cout << "\n子矩阵 matrix(Range(2,6), Range(3,7)):" << std::endl;
    for (int i = 0; i < submatrix.rows; i++) {
        for (int j = 0; j < submatrix.cols; j++) {
            std::cout << submatrix.at<float>(i, j) << "\t";
        }
        std::cout << std::endl;
    }
    
    // 5. 多维度范围选择
    cv::Mat image(100, 100, CV_8UC3, cv::Scalar(255, 255, 255)); // 白色图像
    
    // 选择中心区域
    cv::Range center_rows(25, 75);  // 行25-74
    cv::Range center_cols(25, 75);  // 列25-74
    
    cv::Mat center_region = image(center_rows, center_cols);
    center_region.setTo(cv::Scalar(0, 0, 255)); // 设置为红色
    
    // 选择顶部区域
    cv::Mat top_region = image(cv::Range(0, 25), cv::Range::all());
    top_region.setTo(cv::Scalar(255, 0, 0)); // 设置为蓝色
    
    // 选择右侧区域
    cv::Mat right_region = image(cv::Range::all(), cv::Range(75, 100));
    right_region.setTo(cv::Scalar(0, 255, 0)); // 设置为绿色
    
    // 6. Range在图像处理中的应用
    cv::Mat gradient(200, 300, CV_8UC1);
    
    // 使用Range创建渐变效果
    for (int row = 0; row < gradient.rows; row++) {
        cv::Range row_range(row, row + 1);
        cv::Mat row_mat = gradient(row_range, cv::Range::all());
        
        // 每行设置不同的灰度值
        uchar gray_value = static_cast<uchar>(255 * row / gradient.rows);
        row_mat.setTo(gray_value);
    }
    
    // 7. 使用Range::all()选择所有行或列
    cv::Mat src = cv::imread("example.jpg");
    if (!src.empty()) {
        // 提取所有行的第100-200列
        cv::Mat column_region = src(cv::Range::all(), cv::Range(100, 200));
        
        // 提取第50-150行的所有列
        cv::Mat row_region = src(cv::Range(50, 150), cv::Range::all());
        
        // 显示结果
        cv::imshow("Original", src);
        cv::imshow("Column Region (cols 100-200)", column_region);
        cv::imshow("Row Region (rows 50-150)", row_region);
        cv::waitKey(0);
    }
    
    // 8. 范围遍历
    cv::Range iteration_range(0, 20);
    
    std::cout << "\n范围遍历 Range(0,20):" << std::endl;
    for (int i = iteration_range.start; i < iteration_range.end; i++) {
        std::cout << i << " ";
        if ((i + 1) % 10 == 0) std::cout << std::endl;
    }
    std::cout << std::endl;
    
    // 9. 复杂范围操作
    cv::Mat big_matrix(20, 30, CV_32FC1);
    cv::randu(big_matrix, 0.0f, 1.0f);
    
    // 选择多个非连续区域（通过多个Range）
    cv::Mat extracted;
    
    // 方法1：使用多个范围操作（需要复制）
    cv::Mat part1 = big_matrix(cv::Range(0, 5), cv::Range(0, 10));
    cv::Mat part2 = big_matrix(cv::Range(10, 15), cv::Range(20, 30));
    
    // 合并两个部分
    cv::vconcat(part1, part2, extracted);
    
    std::cout << "\n提取的非连续区域尺寸: " << extracted.rows << "×" << extracted.cols << std::endl;
    
    // 显示图像
    cv::imshow("Color Regions", image);
    cv::imshow("Gradient", gradient);
    cv::waitKey(0);
    
    return 0;
}
```

### 3.3 Ptr（智能指针）- 内存管理

**中文解释：**
Ptr 是OpenCV的**智能指针**，类似C++的shared_ptr，用于自动管理内存，防止内存泄漏。

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>

int main() {
    std::cout << "=== Ptr 智能指针详解 ===" << std::endl;
    
    // ============================================
    // 1. 为什么需要智能指针？
    // ============================================
    
    std::cout << "1. 为什么需要智能指针？" << std::endl;
    std::cout << "   问题: 传统指针需要手动new和delete" << std::endl;
    std::cout << "   风险: 忘记delete会导致内存泄漏" << std::endl;
    std::cout << "   解决: 智能指针自动管理内存" << std::endl;
    
    // ============================================
    // 2. Ptr 的基本用法
    // ============================================
    
    std::cout << "\n\n2. Ptr 的基本用法:" << std::endl;
    
    // 2.1 创建智能指针
    cv::Ptr<cv::Mat> smart_mat = cv::makePtr<cv::Mat>(100, 100, CV_8UC3);
    
    std::cout << "   创建: cv::Ptr<Mat> smart_mat = cv::makePtr<Mat>(100,100,CV_8UC3)" << std::endl;
    std::cout << "   自动分配内存，不需要new" << std::endl;
    
    // 2.2 使用智能指针
    smart_mat->setTo(cv::Scalar(255, 0, 0));  // 设置为蓝色
    
    std::cout << "   使用: smart_mat->setTo(...)" << std::endl;
    std::cout << "   访问: 使用->操作符，就像普通指针" << std::endl;
    
    // 2.3 智能指针的引用计数
    cv::Ptr<cv::Mat> copy1 = smart_mat;  // 复制，引用计数+1
    cv::Ptr<cv::Mat> copy2 = smart_mat;  // 复制，引用计数+1
    
    std::cout << "\n   引用计数:" << std::endl;
    std::cout << "   创建smart_mat: 引用计数=1" << std::endl;
    std::cout << "   复制到copy1: 引用计数=2" << std::endl;
    std::cout << "   复制到copy2: 引用计数=3" << std::endl;
    std::cout << "   当所有Ptr都销毁时，内存自动释放" << std::endl;
    
    // ============================================
    // 3. Ptr 与传统指针对比
    // ============================================
    
    std::cout << "\n\n3. Ptr 与传统指针对比:" << std::endl;
    
    // 3.1 传统指针（需要手动管理）
    cv::Mat* raw_ptr = new cv::Mat(100, 100, CV_8UC1);
    std::cout << "   传统指针: cv::Mat* raw_ptr = new cv::Mat(...)" << std::endl;
    std::cout << "   问题: 必须记得 delete raw_ptr;" << std::endl;
    
    // 使用后必须手动释放
    delete raw_ptr;
    raw_ptr = nullptr;  // 避免野指针
    
    std::cout << "   必须: delete raw_ptr; 否则内存泄漏" << std::endl;
    
    // 3.2 智能指针（自动管理）
    {
        cv::Ptr<cv::Mat> smart_ptr = cv::makePtr<cv::Mat>(100, 100, CV_8UC1);
        std::cout << "\n   智能指针在作用域内" << std::endl;
        
        // 离开作用域时自动释放
    }
    std::cout << "   离开作用域: 智能指针自动释放内存" << std::endl;
    
    // ============================================
    // 4. Ptr 的实用操作
    // ============================================
    
    std::cout << "\n\n4. Ptr 的实用操作:" << std::endl;
    
    cv::Ptr<cv::Mat> ptr = cv::makePtr<cv::Mat>(50, 50, CV_8UC3);
    
    // 4.1 判断是否为空
    std::cout << "   判断是否为空: ptr.empty() = " << ptr.empty() << std::endl;
    
    // 4.2 获取原始指针
    cv::Mat* raw = ptr.get();
    std::cout << "   获取原始指针: ptr.get() = " << raw << std::endl;
    
    // 4.3 释放指针
    ptr.release();
    std::cout << "   释放指针: ptr.release()" << std::endl;
    std::cout << "   释放后: ptr.empty() = " << ptr.empty() << std::endl;
    
    return 0;
}
```

### 3.3 Ptr 属性和方法

#### Ptr 属性

Ptr 是模板类 `Ptr<T>`，其中 T 是指向的类型。

| 特性 | 说明 | 示例 |
|------|------|------|
| 引用计数 | 自动管理内存，多个Ptr可以共享同一对象 | 多个Ptr指向同一对象时，引用计数增加 |
| 空指针 | 可以指向nullptr | `Ptr<T> ptr;` |

#### Ptr 方法

| 方法 | 返回类型 | 说明 | 示例 |
|------|----------|------|------|
| `get()` | `T*` | 获取原始指针 | `ptr.get()` |
| `empty()` | `bool` | 判断是否为空指针 | `ptr.empty()` |
| `release()` | `void` | 释放指针（置空） | `ptr.release()` |
| `addref()` | `void` | 增加引用计数 | `ptr.addref()` |
| `delete_obj()` | `void` | 删除对象（谨慎使用） | `ptr.delete_obj()` |
| `operator*` | `T&` | 解引用操作符 | `*ptr` |
| `operator->` | `T*` | 成员访问操作符 | `ptr->method()` |
| `operator=` | `Ptr&` | 赋值操作符 | `ptr1 = ptr2` |
| `operator bool()` | `bool` | 布尔转换（检查是否非空） | `if (ptr) { ... }` |
| `operator==` | `bool` | 相等比较 | `ptr1 == ptr2` |
| `operator!=` | `bool` | 不等比较 | `ptr1 != ptr2` |

### 3.3 Ptr 常用编程示例

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>
#include <vector>

// 自定义类，用于演示Ptr
class MyData {
public:
    int id;
    std::string name;
    cv::Mat data;
    
    MyData(int _id, const std::string& _name, const cv::Size& size) 
        : id(_id), name(_name), data(size, CV_8UC1) {
        std::cout << "MyData构造函数: " << name << " (ID: " << id << ")" << std::endl;
    }
    
    ~MyData() {
        std::cout << "MyData析构函数: " << name << " (ID: " << id << ")" << std::endl;
    }
    
    void process() {
        std::cout << "处理数据: " << name << std::endl;
        cv::randu(data, 0, 255);
    }
    
    void displayInfo() const {
        std::cout << "ID: " << id << ", Name: " << name 
                  << ", Data size: " << data.cols << "×" << data.rows << std::endl;
    }
};

int main() {
    // 1. 创建智能指针
    cv::Ptr<cv::Mat> mat_ptr = cv::makePtr<cv::Mat>(100, 100, CV_8UC3);
    mat_ptr->setTo(cv::Scalar(255, 0, 0)); // 设置为蓝色
    
    std::cout << "创建Mat智能指针: " << mat_ptr->cols << "×" << mat_ptr->rows << std::endl;
    
    // 2. 智能指针的引用计数
    {
        cv::Ptr<cv::Mat> ptr1 = cv::makePtr<cv::Mat>(50, 50, CV_8UC1);
        cv::Ptr<cv::Mat> ptr2 = ptr1;  // 引用计数+1
        cv::Ptr<cv::Mat> ptr3 = ptr1;  // 引用计数+1
        
        std::cout << "\n在作用域内创建3个指向同一对象的Ptr" << std::endl;
        std::cout << "ptr1地址: " << ptr1.get() << std::endl;
        std::cout << "ptr2地址: " << ptr2.get() << std::endl;
        std::cout << "ptr3地址: " << ptr3.get() << std::endl;
        
        // 修改数据，所有指针都看到相同的变化
        ptr1->setTo(100);
        std::cout << "通过ptr1修改数据，ptr2看到的第一个像素值: " 
                  << (int)ptr2->at<uchar>(0, 0) << std::endl;
    }
    std::cout << "离开作用域，所有Ptr销毁，内存自动释放" << std::endl;
    
    // 3. 判断指针是否为空
    cv::Ptr<cv::Mat> null_ptr;
    cv::Ptr<cv::Mat> valid_ptr = cv::makePtr<cv::Mat>(10, 10, CV_8UC1);
    
    if (null_ptr.empty()) {
        std::cout << "\nnull_ptr是空的" << std::endl;
    }
    
    if (!valid_ptr.empty()) {
        std::cout << "valid_ptr不是空的" << std::endl;
    }
    
    // 使用bool转换检查
    if (valid_ptr) {
        std::cout << "valid_ptr可以转换为true" << std::endl;
    }
    
    // 4. 获取原始指针
    cv::Mat* raw_pointer = valid_ptr.get();
    if (raw_pointer) {
        std::cout << "获取原始指针成功: " << raw_pointer->cols << "×" << raw_pointer->rows << std::endl;
    }
    
    // 5. 释放指针
    valid_ptr.release();
    if (valid_ptr.empty()) {
        std::cout << "释放后，valid_ptr变为空" << std::endl;
    }
    
    // 6. 使用智能指针管理自定义对象
    cv::Ptr<MyData> data_ptr = cv::makePtr<MyData>(1, "测试数据", cv::Size(100, 100));
    data_ptr->process();
    data_ptr->displayInfo();
    
    // 7. 智能指针在容器中的使用
    std::vector<cv::Ptr<MyData>> data_list;
    
    for (int i = 0; i < 5; i++) {
        std::string name = "数据_" + std::to_string(i + 1);
        cv::Ptr<MyData> item = cv::makePtr<MyData>(i + 1, name, cv::Size(50, 50));
        item->process();
        data_list.push_back(item);
    }
    
    std::cout << "\n数据列表大小: " << data_list.size() << std::endl;
    for (const auto& item : data_list) {
        item->displayInfo();
    }
    
    // 8. 智能指针作为函数参数和返回值
    auto create_image = []() -> cv::Ptr<cv::Mat> {
        cv::Ptr<cv::Mat> img = cv::makePtr<cv::Mat>(200, 300, CV_8UC3);
        
        // 创建渐变效果
        for (int y = 0; y < img->rows; y++) {
            for (int x = 0; x < img->cols; x++) {
                cv::Vec3b& pixel = img->at<cv::Vec3b>(y, x);
                pixel[0] = static_cast<uchar>(255 * x / img->cols);      // B
                pixel[1] = static_cast<uchar>(255 * y / img->rows);      // G
                pixel[2] = static_cast<uchar>(255 * (1.0 - x / (double)img->cols)); // R
            }
        }
        
        return img;
    };
    
    auto process_image = [](cv::Ptr<cv::Mat> img) {
        if (!img || img->empty()) {
            std::cout << "图像为空!" << std::endl;
            return;
        }
        
        // 应用高斯模糊
        cv::GaussianBlur(*img, *img, cv::Size(15, 15), 0);
        std::cout << "处理图像: " << img->cols << "×" << img->rows << std::endl;
    };
    
    cv::Ptr<cv::Mat> gradient_image = create_image();
    process_image(gradient_image);
    
    // 9. 显示智能指针管理的图像
    if (gradient_image && !gradient_image->empty()) {
        cv::imshow("Gradient Image", *gradient_image);
        
        // 创建副本进行修改（不影响原图）
        cv::Ptr<cv::Mat> copy = cv::makePtr<cv::Mat>();
        gradient_image->copyTo(*copy);
        
        // 在副本上绘制
        cv::rectangle(*copy, cv::Rect(50, 50, 100, 100), cv::Scalar(255, 255, 255), 3);
        cv::putText(*copy, "Smart Pointer", cv::Point(60, 120), 
                   cv::FONT_HERSHEY_SIMPLEX, 1.0, cv::Scalar(255, 255, 255), 2);
        
        cv::imshow("Modified Copy", *copy);
        cv::waitKey(0);
    }
    
    // 10. 智能指针与OpenCV算法的结合
    cv::Ptr<cv::ORB> orb_detector = cv::ORB::create(500);
    cv::Ptr<cv::SIFT> sift_detector = cv::SIFT::create();
    
    cv::Mat test_image = cv::imread("example.jpg", cv::IMREAD_GRAYSCALE);
    if (!test_image.empty()) {
        std::vector<cv::KeyPoint> keypoints;
        cv::Mat descriptors;
        
        // 使用智能指针管理的检测器
        orb_detector->detectAndCompute(test_image, cv::noArray(), keypoints, descriptors);
        
        std::cout << "\n检测到 " << keypoints.size() << " 个关键点" << std::endl;
        
        // 在图像上绘制关键点
        cv::Mat result;
        cv::drawKeypoints(test_image, keypoints, result, cv::Scalar(0, 255, 0), 
                         cv::DrawMatchesFlags::DRAW_RICH_KEYPOINTS);
        
        cv::imshow("ORB Keypoints", result);
        cv::waitKey(0);
    }
    
    // 11. 自定义删除器（高级用法）
    auto custom_deleter = [](MyData* ptr) {
        std::cout << "使用自定义删除器删除: " << ptr->name << std::endl;
        delete ptr;
    };
    
    cv::Ptr<MyData> custom_ptr(new MyData(99, "自定义删除", cv::Size(10, 10)), custom_deleter);
    
    std::cout << "\n程序结束，智能指针将自动释放内存..." << std::endl;
    
    return 0;
}
```

## 四、编译和运行

```bash
# 编译命令
g++ -o opencv_types opencv_types.cpp `pkg-config --cflags --libs opencv4` -std=c++11

# 运行
./opencv_types
```

## 五、总结表格

| 类型 | 主要用途 | 关键特点 | 常用示例 |
|------|----------|----------|----------|
| **Mat** | 图像/矩阵存储 | OpenCV核心，支持多种数据类型 | `Mat(480,640,CV_8UC3)` |
| **Point** | 坐标表示 | 2D/3D点，支持数学运算 | `Point(100,200)` |
| **Size** | 尺寸表示 | 宽度和高度，计算面积 | `Size(640,480)` |
| **Rect** | 矩形区域 | 位置+尺寸，支持交集并集 | `Rect(100,100,200,150)` |
| **Scalar** | 颜色/标量 | BGR颜色，4元素向量 | `Scalar(255,0,0)` |
| **Vec** | 多通道数据 | 模板类，用于像素和向量 | `Vec3b(100,150,200)` |
| **Range** | 范围选择 | 连续整数序列 [start,end) | `Range(0,10)` |
| **Ptr** | 智能指针 | 自动内存管理 | `Ptr<Mat> ptr = makePtr<Mat>()` |