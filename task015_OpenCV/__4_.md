# OpenCV 图像处理进阶笔记


## 三、像素运算与位操作

### 3.1 像素运算基础

#### 讲解
像素运算是图像处理中最基本的操作之一，包括算术运算（加、减、乘、除）和逻辑运算（与、或、非、异或）。这些操作常用于图像融合、对比度调整、掩膜处理等应用。

#### 核心概念

| 概念 | 说明 | 数学表示 | OpenCV 实现 |
|------|------|----------|-------------|
| **像素值范围** | 8位图像：0-255<br>16位图像：0-65535<br>浮点图像：0.0-1.0 | [0, 255] | `CV_8U`, `CV_16U`, `CV_32F` |
| **溢出处理** | 超出范围的值如何处理 | - | `cv::saturate_cast<>()` |
| **图像融合** | 加权合并两张图像 | dst = α×src1 + β×src2 + γ | `cv::addWeighted()` |

#### 运算方法对比

| 运算类型 | OpenCV函数 | 运算符 | 特点 |
|----------|------------|--------|------|
| **加法** | `cv::add()` | `+` | 避免溢出（饱和） |
| **减法** | `cv::subtract()` | `-` | 避免下溢 |
| **乘法** | `cv::multiply()` | `*` | 标量或矩阵乘法 |
| **除法** | `cv::divide()` | `/` | 避免除零 |
| **加权和** | `cv::addWeighted()` | - | 线性混合 |

#### 位运算方法

| 位运算 | OpenCV函数 | 用途 |
|--------|------------|------|
| **与** | `cv::bitwise_and()` | 掩膜操作，提取ROI |
| **或** | `cv::bitwise_or()` | 图像合并 |
| **非** | `cv::bitwise_not()` | 图像取反 |
| **异或** | `cv::bitwise_xor()` | 差异检测，加密 |

### 3.2 像素运算实战代码

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>
#include <vector>
#include <cmath>

// 显示图像信息
void showImageInfo(const cv::Mat& img, const std::string& name) {
    std::cout << name << ": " << img.cols << "×" << img.rows 
              << " (" << img.channels() << " channels, " 
              << img.depth() << " depth)" << std::endl;
}

// 像素值范围检查
void checkPixelRange(const cv::Mat& img) {
    double min_val, max_val;
    cv::minMaxLoc(img, &min_val, &max_val);
    std::cout << "  像素值范围: [" << min_val << ", " << max_val << "]" << std::endl;
}

int main() {
    std::cout << "=== OpenCV 像素运算与位操作 ===\n" << std::endl;
    
    // ============================================
    // 1. 创建测试图像
    // ============================================
    
    std::cout << "1. 创建测试图像..." << std::endl;
    
    // 1.1 基础图像
    cv::Mat img1(300, 400, CV_8UC3, cv::Scalar(100, 100, 100));
    cv::Mat img2(300, 400, CV_8UC3, cv::Scalar(200, 200, 200));
    
    // 1.2 创建渐变图像
    cv::Mat gradient(300, 400, CV_8UC3);
    for (int y = 0; y < gradient.rows; y++) {
        for (int x = 0; x < gradient.cols; x++) {
            gradient.at<cv::Vec3b>(y, x) = cv::Vec3b(
                static_cast<uchar>(255.0 * x / gradient.cols),      // 蓝色渐变
                static_cast<uchar>(255.0 * y / gradient.rows),      // 绿色渐变
                static_cast<uchar>(128 + 127 * sin(x * 0.05))       // 红色正弦
            );
        }
    }
    
    // 1.3 创建掩膜图像
    cv::Mat mask(300, 400, CV_8UC1, cv::Scalar(0));
    cv::circle(mask, cv::Point(200, 150), 100, cv::Scalar(255), -1);
    
    showImageInfo(img1, "图像1 (100,100,100)");
    showImageInfo(img2, "图像2 (200,200,200)");
    showImageInfo(gradient, "渐变图像");
    showImageInfo(mask, "掩膜图像");
    
    // ============================================
    // 2. 算术运算：加法
    // ============================================
    
    std::cout << "\n2. 算术运算：加法" << std::endl;
    
    // 2.1 使用cv::add() - 饱和加法（推荐）
    cv::Mat add_saturated;
    cv::add(img1, img2, add_saturated);
    std::cout << "   cv::add(): 饱和加法" << std::endl;
    checkPixelRange(add_saturated);
    
    // 2.2 使用+运算符 - 模加法（可能溢出）
    cv::Mat add_modulo = img1 + img2;
    std::cout << "   +运算符: 模加法（溢出会回绕）" << std::endl;
    checkPixelRange(add_modulo);
    
    // 2.3 标量加法
    cv::Mat add_scalar;
    cv::add(img1, cv::Scalar(50, 30, 10), add_scalar);
    std::cout << "   标量加法: 每个通道加不同值" << std::endl;
    
    // 2.4 演示溢出问题
    cv::Mat img_high(300, 400, CV_8UC3, cv::Scalar(200, 200, 200));
    cv::Mat add_overflow;
    cv::add(img_high, img_high, add_overflow);  // 200+200=400，但饱和到255
    
    // 提取一个像素进行比较
    cv::Vec3b pixel_high = img_high.at<cv::Vec3b>(0, 0);
    cv::Vec3b pixel_add = add_overflow.at<cv::Vec3b>(0, 0);
    std::cout << "   溢出演示: 200+200 = (" 
              << (int)pixel_add[0] << "," << (int)pixel_add[1] << "," 
              << (int)pixel_add[2] << ") [饱和到255]" << std::endl;
    
    // ============================================
    // 3. 算术运算：减法
    // ============================================
    
    std::cout << "\n3. 算术运算：减法" << std::endl;
    
    // 3.1 使用cv::subtract()
    cv::Mat subtract_result;
    cv::subtract(img2, img1, subtract_result);
    std::cout << "   cv::subtract(): 200-100 = 100" << std::endl;
    checkPixelRange(subtract_result);
    
    // 3.2 下溢演示
    cv::Mat img_low(300, 400, CV_8UC3, cv::Scalar(50, 50, 50));
    cv::Mat underflow;
    cv::subtract(img_low, img2, underflow);  // 50-200=-150，但饱和到0
    
    cv::Vec3b pixel_low = img_low.at<cv::Vec3b>(0, 0);
    cv::Vec3b pixel_sub = underflow.at<cv::Vec3b>(0, 0);
    std::cout << "   下溢演示: 50-200 = (" 
              << (int)pixel_sub[0] << "," << (int)pixel_sub[1] << "," 
              << (int)pixel_sub[2] << ") [饱和到0]" << std::endl;
    
    // ============================================
    // 4. 算术运算：乘法
    // ============================================
    
    std::cout << "\n4. 算术运算：乘法" << std::endl;
    
    // 4.1 图像乘法（逐元素）
    cv::Mat multiply_result;
    cv::multiply(img1, img2, multiply_result, 1.0/255.0);  // 归一化因子
    std::cout << "   cv::multiply(): 100×200 = 20000/255≈78" << std::endl;
    checkPixelRange(multiply_result);
    
    // 4.2 标量乘法（对比度调整）
    cv::Mat contrast_low, contrast_high;
    cv::multiply(gradient, 0.5, contrast_low);   // 降低对比度
    cv::multiply(gradient, 1.5, contrast_high);  // 提高对比度
    
    std::cout << "   对比度调整: ×0.5 和 ×1.5" << std::endl;
    checkPixelRange(contrast_low);
    checkPixelRange(contrast_high);
    
    // ============================================
    // 5. 算术运算：除法
    // ============================================
    
    std::cout << "\n5. 算术运算：除法" << std::endl;
    
    // 5.1 避免除零
    cv::Mat img_nonzero = img2.clone();
    img_nonzero.setTo(cv::Scalar(1, 1, 1), img_nonzero == 0);  // 确保没有0值
    
    cv::Mat divide_result;
    cv::divide(img2, img_nonzero, divide_result);
    std::cout << "   cv::divide(): 200/1 = 200" << std::endl;
    checkPixelRange(divide_result);
    
    // 5.2 带缩放因子的除法
    cv::Mat divide_scaled;
    cv::divide(img2, img_nonzero, divide_scaled, 2.0);  // 结果×2
    std::cout << "   带缩放除法: (200/1)×2 = 400 [饱和到255]" << std::endl;
    checkPixelRange(divide_scaled);
    
    // ============================================
    // 6. 加权和（图像融合）
    // ============================================
    
    std::cout << "\n6. 加权和：图像融合" << std::endl;
    
    cv::Mat blended;
    double alpha = 0.3;  // img1的权重
    double beta = 0.7;   // img2的权重
    double gamma = 0.0;  // 额外的常数
    
    cv::addWeighted(img1, alpha, img2, beta, gamma, blended);
    
    std::cout << "   cv::addWeighted(): 0.3×img1 + 0.7×img2" << std::endl;
    std::cout << "   理论值: 0.3×100 + 0.7×200 = 170" << std::endl;
    
    cv::Vec3b pixel_blend = blended.at<cv::Vec3b>(0, 0);
    std::cout << "   实际值: (" << (int)pixel_blend[0] << "," 
              << (int)pixel_blend[1] << "," << (int)pixel_blend[2] << ")" << std::endl;
    
    // 渐变融合演示
    cv::Mat gradient_blend;
    cv::addWeighted(gradient, 0.6, img2, 0.4, 0, gradient_blend);
    
    // ============================================
    // 7. 位运算：与操作
    // ============================================
    
    std::cout << "\n7. 位运算：与操作 (AND)" << std::endl;
    
    // 7.1 创建二进制图像
    cv::Mat binary1(300, 400, CV_8UC1, cv::Scalar(0));
    cv::Mat binary2(300, 400, CV_8UC1, cv::Scalar(0));
    
    cv::rectangle(binary1, cv::Rect(50, 50, 200, 200), cv::Scalar(255), -1);
    cv::rectangle(binary2, cv::Rect(150, 150, 200, 200), cv::Scalar(255), -1);
    
    // 7.2 位与操作
    cv::Mat bitwise_and_result;
    cv::bitwise_and(binary1, binary2, bitwise_and_result);
    
    std::cout << "   cv::bitwise_and(): 矩形交集" << std::endl;
    
    // 7.3 使用掩膜
    cv::Mat masked_gradient;
    cv::bitwise_and(gradient, gradient, masked_gradient, mask);  // 应用圆形掩膜
    
    // ============================================
    // 8. 位运算：或操作
    // ============================================
    
    std::cout << "\n8. 位运算：或操作 (OR)" << std::endl;
    
    cv::Mat bitwise_or_result;
    cv::bitwise_or(binary1, binary2, bitwise_or_result);
    
    std::cout << "   cv::bitwise_or(): 矩形并集" << std::endl;
    
    // ============================================
    // 9. 位运算：非操作
    // ============================================
    
    std::cout << "\n9. 位运算：非操作 (NOT)" << std::endl;
    
    cv::Mat bitwise_not_result;
    cv::bitwise_not(binary1, bitwise_not_result);
    
    std::cout << "   cv::bitwise_not(): 图像取反" << std::endl;
    
    // 彩色图像取反
    cv::Mat gradient_inverse;
    cv::bitwise_not(gradient, gradient_inverse);
    
    // ============================================
    // 10. 位运算：异或操作
    // ============================================
    
    std::cout << "\n10. 位运算：异或操作 (XOR)" << std::endl;
    
    cv::Mat bitwise_xor_result;
    cv::bitwise_xor(binary1, binary2, bitwise_xor_result);
    
    std::cout << "   cv::bitwise_xor(): 矩形差异" << std::endl;
    
    // ============================================
    // 11. 综合应用：图像水印
    // ============================================
    
    std::cout << "\n11. 综合应用：图像水印" << std::endl;
    
    // 11.1 创建水印图像
    cv::Mat watermark(300, 400, CV_8UC3, cv::Scalar(0));
    cv::putText(watermark, "OPENCV", cv::Point(100, 150),
                cv::FONT_HERSHEY_SIMPLEX, 2.0, cv::Scalar(255, 255, 255), 3);
    
    // 11.2 创建水印掩膜
    cv::Mat watermark_gray, watermark_mask;
    cv::cvtColor(watermark, watermark_gray, cv::COLOR_BGR2GRAY);
    cv::threshold(watermark_gray, watermark_mask, 10, 255, cv::THRESH_BINARY);
    
    // 11.3 应用水印（使用位运算）
    cv::Mat watermarked;
    gradient.copyTo(watermarked);
    
    // 方法1：直接设置水印区域
    watermark.copyTo(watermarked, watermark_mask);
    
    // 方法2：混合水印（半透明效果）
    cv::Mat watermarked_blend;
    cv::addWeighted(gradient, 0.7, watermark, 0.3, 0, watermarked_blend);
    
    std::cout << "   创建文字水印并应用到图像" << std::endl;
    
    // ============================================
    // 12. 综合应用：图像差异检测
    // ============================================
    
    std::cout << "\n12. 综合应用：图像差异检测" << std::endl;
    
    // 12.1 创建两个相似但有差异的图像
    cv::Mat scene1 = gradient.clone();
    cv::Mat scene2 = gradient.clone();
    
    // 在scene2中添加一个矩形
    cv::rectangle(scene2, cv::Rect(250, 100, 80, 60), cv::Scalar(0, 0, 255), -1);
    
    // 12.2 计算绝对差异
    cv::Mat diff_abs;
    cv::absdiff(scene1, scene2, diff_abs);
    
    // 12.3 转换为灰度并二值化
    cv::Mat diff_gray, diff_binary;
    cv::cvtColor(diff_abs, diff_gray, cv::COLOR_BGR2GRAY);
    cv::threshold(diff_gray, diff_binary, 30, 255, cv::THRESH_BINARY);
    
    std::cout << "   使用absdiff()检测图像差异" << std::endl;
    
    // ============================================
    // 13. 像素值饱和处理
    // ============================================
    
    std::cout << "\n13. 像素值饱和处理" << std::endl;
    
    // 13.1 手动饱和处理
    cv::Mat high_values(100, 100, CV_32FC1);
    cv::randu(high_values, 0.0, 3.0);  // 生成0-3的值
    
    cv::Mat saturated_manual = high_values.clone();
    saturated_manual.setTo(1.0, saturated_manual > 1.0);
    saturated_manual.setTo(0.0, saturated_manual < 0.0);
    
    // 13.2 使用saturate_cast
    cv::Mat float_image(100, 100, CV_32FC1);
    cv::randu(float_image, -0.5, 1.5);
    
    cv::Mat uchar_image(float_image.size(), CV_8UC1);
    for (int y = 0; y < float_image.rows; y++) {
        for (int x = 0; x < float_image.cols; x++) {
            float pixel = float_image.at<float>(y, x);
            // 饱和转换：<0变为0，>1变为255，其他线性映射
            uchar_image.at<uchar>(y, x) = cv::saturate_cast<uchar>(pixel * 255);
        }
    }
    
    std::cout << "   saturate_cast<uchar>: 自动处理溢出" << std::endl;
    
    // 13.3 不同数据类型的转换
    cv::Mat float_src(100, 100, CV_32FC3);
    cv::randu(float_src, 0.0, 1.0);
    
    cv::Mat uchar_dst;
    float_src.convertTo(uchar_dst, CV_8UC3, 255.0);  // 缩放并转换
    
    // ============================================
    // 14. 创建显示面板
    // ============================================
    
    std::cout << "\n14. 创建结果显示面板..." << std::endl;
    
    // 14.1 创建主显示面板
    int panel_width = 1200;
    int panel_height = 900;
    cv::Mat display_panel(panel_height, panel_width, CV_8UC3, cv::Scalar(30, 30, 30));
    
    // 14.2 定义缩略图尺寸
    int thumb_width = 280;
    int thumb_height = 210;
    
    // 14.3 准备所有结果图像
    std::vector<cv::Mat> all_results;
    std::vector<std::string> all_labels;
    
    // 原始图像
    cv::Mat thumb_original;
    cv::resize(gradient, thumb_original, cv::Size(thumb_width, thumb_height));
    all_results.push_back(thumb_original);
    all_labels.push_back("Original");
    
    // 算术运算结果
    std::vector<cv::Mat> arithmetic_results = {
        add_saturated, subtract_result, multiply_result, blended
    };
    std::vector<std::string> arithmetic_labels = {
        "Add", "Subtract", "Multiply", "Blend"
    };
    
    for (size_t i = 0; i < arithmetic_results.size(); i++) {
        cv::Mat thumb;
        cv::resize(arithmetic_results[i], thumb, cv::Size(thumb_width, thumb_height));
        all_results.push_back(thumb);
        all_labels.push_back(arithmetic_labels[i]);
    }
    
    // 位运算结果（转换为彩色显示）
    std::vector<cv::Mat> bitwise_results = {
        binary1, binary2, bitwise_and_result, 
        bitwise_or_result, bitwise_not_result, bitwise_xor_result
    };
    std::vector<std::string> bitwise_labels = {
        "Binary1", "Binary2", "AND", "OR", "NOT", "XOR"
    };
    
    for (size_t i = 0; i < bitwise_results.size(); i++) {
        cv::Mat thumb;
        cv::Mat color_bitwise;
        if (bitwise_results[i].channels() == 1) {
            cv::cvtColor(bitwise_results[i], color_bitwise, cv::COLOR_GRAY2BGR);
        } else {
            color_bitwise = bitwise_results[i];
        }
        cv::resize(color_bitwise, thumb, cv::Size(thumb_width, thumb_height));
        all_results.push_back(thumb);
        all_labels.push_back(bitwise_labels[i]);
    }
    
    // 应用结果
    all_results.push_back(watermarked);
    all_labels.push_back("Watermarked");
    
    all_results.push_back(diff_abs);
    all_labels.push_back("Difference");
    
    // 14.4 在面板上排列所有结果
    int cols = 4;
    int thumb_index = 0;
    
    for (size_t i = 0; i < all_results.size(); i++) {
        int row = thumb_index / cols;
        int col = thumb_index % cols;
        
        int x = col * (thumb_width + 20) + 20;
        int y = row * (thumb_height + 40) + 40;
        
        // 确保位置在面板范围内
        if (y + thumb_height < panel_height) {
            // 复制缩略图
            cv::Rect roi(x, y, thumb_width, thumb_height);
            cv::Mat thumb_resized;
            cv::resize(all_results[i], thumb_resized, cv::Size(thumb_width, thumb_height));
            thumb_resized.copyTo(display_panel(roi));
            
            // 添加边框
            cv::rectangle(display_panel, roi, cv::Scalar(180, 180, 180), 1);
            
            // 添加标签
            cv::putText(display_panel, all_labels[i], 
                       cv::Point(x + 5, y + thumb_height + 20),
                       cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(220, 220, 220), 1);
            
            thumb_index++;
        }
    }
    
    // 14.5 添加标题
    cv::putText(display_panel, "OpenCV Pixel Operations Demo", 
               cv::Point(panel_width / 2 - 200, 30),
               cv::FONT_HERSHEY_SIMPLEX, 0.9, cv::Scalar(0, 255, 255), 2);
    
    // 添加分类标签
    cv::putText(display_panel, "Arithmetic Operations", 
               cv::Point(20, 20),
               cv::FONT_HERSHEY_SIMPLEX, 0.6, cv::Scalar(0, 200, 255), 1);
    
    cv::putText(display_panel, "Bitwise Operations", 
               cv::Point(20, 280),
               cv::FONT_HERSHEY_SIMPLEX, 0.6, cv::Scalar(0, 200, 255), 1);
    
    cv::putText(display_panel, "Applications", 
               cv::Point(20, 540),
               cv::FONT_HERSHEY_SIMPLEX, 0.6, cv::Scalar(0, 200, 255), 1);
    
    // ============================================
    // 15. 交互演示
    // ============================================
    
    std::cout << "\n15. 交互演示：动态调整参数" << std::endl;
    
    cv::namedWindow("像素运算演示", cv::WINDOW_NORMAL);
    cv::resizeWindow("像素运算演示", panel_width, panel_height);
    cv::imshow("像素运算演示", display_panel);
    
    // 创建控制窗口
    cv::namedWindow("控制面板", cv::WINDOW_NORMAL);
    cv::resizeWindow("控制面板", 400, 300);
    
    // 创建控制参数
    int alpha_slider = 50;  // 0-100，对应0.0-1.0
    int beta_slider = 50;
    int operation_type = 0;  // 0:加法, 1:减法, 2:乘法, 3:融合
    
    // 创建控制面板图像
    cv::Mat control_panel(300, 400, CV_8UC3, cv::Scalar(50, 50, 50));
    
    // 更新控制面板函数
    auto updateControlPanel = [&]() {
        control_panel.setTo(cv::Scalar(50, 50, 50));
        
        // 标题
        cv::putText(control_panel, "=== 像素运算控制 ===",
                   cv::Point(20, 30), cv::FONT_HERSHEY_SIMPLEX,
                   0.7, cv::Scalar(0, 255, 255), 2);
        
        // 操作类型
        std::vector<std::string> operations = {"加法", "减法", "乘法", "融合"};
        cv::putText(control_panel, "操作: " + operations[operation_type],
                   cv::Point(20, 70), cv::FONT_HERSHEY_SIMPLEX,
                   0.6, cv::Scalar(200, 200, 200), 1);
        
        // 参数显示
        double alpha_val = alpha_slider / 100.0;
        double beta_val = beta_slider / 100.0;
        
        cv::putText(control_panel, "参数1: " + std::to_string(alpha_val),
                   cv::Point(20, 100), cv::FONT_HERSHEY_SIMPLEX,
                   0.6, cv::Scalar(200, 200, 200), 1);
        
        if (operation_type == 3) {  // 融合操作
            cv::putText(control_panel, "参数2: " + std::to_string(beta_val),
                       cv::Point(20, 130), cv::FONT_HERSHEY_SIMPLEX,
                       0.6, cv::Scalar(200, 200, 200), 1);
        }
        
        // 操作说明
        cv::putText(control_panel, "按键控制:", cv::Point(20, 180),
                   cv::FONT_HERSHEY_SIMPLEX, 0.6, cv::Scalar(0, 255, 0), 1);
        
        cv::putText(control_panel, "A/D: 调整参数1", cv::Point(30, 210),
                   cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(200, 200, 200), 1);
        
        cv::putText(control_panel, "W/S: 调整参数2", cv::Point(30, 235),
                   cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(200, 200, 200), 1);
        
        cv::putText(control_panel, "数字1-4: 选择操作", cv::Point(30, 260),
                   cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(200, 200, 200), 1);
        
        cv::putText(control_panel, "ESC: 退出", cv::Point(30, 285),
                   cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(200, 200, 200), 1);
    };
    
    updateControlPanel();
    cv::imshow("控制面板", control_panel);
    
    // 创建动态演示窗口
    cv::namedWindow("动态演示", cv::WINDOW_NORMAL);
    cv::resizeWindow("动态演示", 400, 300);
    
    std::cout << "   按键说明:" << std::endl;
    std::cout << "   A/D: 调整参数1" << std::endl;
    std::cout << "   W/S: 调整参数2（融合操作）" << std::endl;
    std::cout << "   1-4: 选择操作类型" << std::endl;
    std::cout << "   ESC: 退出程序" << std::endl;
    
    while (true) {
        // 根据当前操作类型计算结果
        cv::Mat dynamic_result;
        double alpha_val = alpha_slider / 100.0;
        double beta_val = beta_slider / 100.0;
        
        switch (operation_type) {
            case 0:  // 加法
                cv::addWeighted(img1, alpha_val, img2, 1.0 - alpha_val, 0, dynamic_result);
                break;
                
            case 1:  // 减法
                {
                    cv::Mat temp;
                    cv::multiply(img2, cv::Scalar::all(alpha_val), temp);
                    cv::subtract(temp, img1, dynamic_result);
                }
                break;
                
            case 2:  // 乘法
                cv::multiply(img1, cv::Scalar::all(alpha_val * 2.0), dynamic_result);
                break;
                
            case 3:  // 融合
                cv::addWeighted(img1, alpha_val, gradient, beta_val, 0, dynamic_result);
                break;
        }
        
        // 在结果上添加参数信息
        cv::Mat result_display;
        dynamic_result.copyTo(result_display);
        
        std::string param_text;
        if (operation_type == 3) {
            param_text = "Alpha: " + std::to_string(alpha_val) + 
                        "  Beta: " + std::to_string(beta_val);
        } else {
            param_text = "参数: " + std::to_string(alpha_val);
        }
        
        cv::putText(result_display, param_text, cv::Point(10, 30),
                   cv::FONT_HERSHEY_SIMPLEX, 0.7, cv::Scalar(0, 255, 0), 2);
        
        std::vector<std::string> op_names = {"加法", "减法", "乘法", "融合"};
        cv::putText(result_display, "操作: " + op_names[operation_type], 
                   cv::Point(10, 60), cv::FONT_HERSHEY_SIMPLEX, 
                   0.6, cv::Scalar(0, 255, 255), 1);
        
        // 显示动态结果
        cv::imshow("动态演示", result_display);
        
        // 处理按键
        int key = cv::waitKey(30);
        
        if (key == 27) {  // ESC
            break;
        } else if (key == 'a' || key == 'A') {
            alpha_slider = std::max(0, alpha_slider - 5);
            updateControlPanel();
            cv::imshow("控制面板", control_panel);
        } else if (key == 'd' || key == 'D') {
            alpha_slider = std::min(100, alpha_slider + 5);
            updateControlPanel();
            cv::imshow("控制面板", control_panel);
        } else if (key == 'w' || key == 'W') {
            beta_slider = std::min(100, beta_slider + 5);
            updateControlPanel();
            cv::imshow("控制面板", control_panel);
        } else if (key == 's' || key == 'S') {
            beta_slider = std::max(0, beta_slider - 5);
            updateControlPanel();
            cv::imshow("控制面板", control_panel);
        } else if (key >= '1' && key <= '4') {
            operation_type = key - '1';
            updateControlPanel();
            cv::imshow("控制面板", control_panel);
        } else if (key == ' ') {
            // 保存当前结果
            std::string filename = "pixel_op_result_" + 
                                 std::to_string(time(0)) + ".jpg";
            cv::imwrite(filename, result_display);
            std::cout << "已保存: " << filename << std::endl;
        }
    }
    
    cv::destroyAllWindows();
    
    std::cout << "\n=== 像素运算演示完成 ===" << std::endl;
    std::cout << "总结：" << std::endl;
    std::cout << "1. 掌握了像素算术运算（加、减、乘、除）" << std::endl;
    std::cout << "2. 学会了位运算（与、或、非、异或）" << std::endl;
    std::cout << "3. 理解了像素值范围和溢出处理" << std::endl;
    std::cout << "4. 实现了图像融合、水印、差异检测等应用" << std::endl;
    
    return 0;
}
```

### 3.3 关键知识点总结

#### 1. 像素值范围与溢出处理
- **8位图像**：像素值范围0-255，超过会自动回绕（255+1=0）
- **饱和运算**：使用`cv::add()`、`cv::subtract()`等函数避免溢出
- **类型转换**：使用`convertTo()`和`saturate_cast<>()`进行安全转换

#### 2. 算术运算的选择
- **简单运算**：使用运算符（+、-、*、/）速度快，但需注意溢出
- **安全运算**：使用OpenCV函数（add、subtract等）自动处理溢出
- **融合运算**：`addWeighted()`实现α×A + β×B + γ

#### 3. 位运算的应用场景
- **掩膜操作**：`bitwise_and()`提取感兴趣区域
- **图像合并**：`bitwise_or()`组合多个图像
- **图像取反**：`bitwise_not()`创建负片效果
- **差异检测**：`bitwise_xor()`找出两图不同之处

#### 4. 实用技巧
1. **避免除零**：在除法前检查分母是否为零
2. **归一化处理**：将浮点数转换到0-255范围显示
3. **掩膜优化**：使用位运算替代逐像素判断
4. **内存连续**：连续图像可使用指针快速遍历



## 一、色彩空间与通道操作

### 1.1 色彩空间转换

#### 讲解
色彩空间是描述颜色的一种数学模型，不同色彩空间适用于不同应用场景。OpenCV支持多种色彩空间的相互转换，最常用的是RGB、灰度、HSV等。

#### 核心类与方法

| 方法 | 说明 | 常用转换代码 |
|------|------|-------------|
| `cvtColor()` | 色彩空间转换 | `cv::COLOR_BGR2GRAY`, `cv::COLOR_BGR2HSV` |
| `split()` | 通道拆分 | 将多通道图像拆分为单通道数组 |
| `merge()` | 通道合并 | 将单通道数组合并为多通道图像 |

#### 常用色彩空间

| 色彩空间 | 通道 | 特点 | 应用场景 |
|----------|------|------|----------|
| **BGR** | B, G, R | OpenCV默认格式，注意不是RGB | 图像显示、存储 |
| **灰度** | Gray | 单通道，亮度信息 | 简化处理，特征提取 |
| **HSV** | H, S, V | 色调、饱和度、明度 | 颜色识别、跟踪 |
| **LAB** | L, A, B | 感知均匀的色彩空间 | 颜色距离计算 |
| **YCrCb** | Y, Cr, Cb | 亮度和色度分离 | 视频压缩、肤色检测 |

#### 色彩空间转换实战

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>
#include <vector>

// 显示图像信息
void showImageInfo(const cv::Mat& img, const std::string& name) {
    std::cout << name << ": " << img.cols << "×" << img.rows 
              << " (" << img.channels() << " channels)" << std::endl;
}

// 创建颜色测试图像
cv::Mat createColorTestImage(int width, int height) {
    cv::Mat image(height, width, CV_8UC3);
    
    // 创建彩虹渐变
    for (int y = 0; y < height; y++) {
        for (int x = 0; x < width; x++) {
            float ratio = static_cast<float>(x) / width;
            cv::Vec3b color;
            
            if (ratio < 0.2) {
                // 红色到橙色
                float t = ratio / 0.2;
                color = cv::Vec3b(0, 165 * t, 255);  // BGR: (0, 165*t, 255)
            } else if (ratio < 0.4) {
                // 橙色到黄色
                float t = (ratio - 0.2) / 0.2;
                color = cv::Vec3b(0, 165 + 90 * t, 255);  // (0, 165+90*t, 255)
            } else if (ratio < 0.6) {
                // 黄色到绿色
                float t = (ratio - 0.4) / 0.2;
                color = cv::Vec3b(0, 255, 255 - 255 * t);  // (0, 255, 255-255*t)
            } else if (ratio < 0.8) {
                // 绿色到蓝色
                float t = (ratio - 0.6) / 0.2;
                color = cv::Vec3b(255 * t, 255, 0);  // (255*t, 255, 0)
            } else {
                // 蓝色到紫色
                float t = (ratio - 0.8) / 0.2;
                color = cv::Vec3b(255, 255 - 128 * t, 128 * t);  // (255, 255-128*t, 128*t)
            }
            
            // 添加垂直渐变
            float vertical_factor = static_cast<float>(y) / height;
            color = color * (0.5 + 0.5 * vertical_factor);
            
            image.at<cv::Vec3b>(y, x) = color;
        }
    }
    
    // 添加颜色块
    std::vector<cv::Scalar> color_blocks = {
        cv::Scalar(0, 0, 255),     // 红色
        cv::Scalar(0, 255, 0),     // 绿色
        cv::Scalar(255, 0, 0),     // 蓝色
        cv::Scalar(0, 255, 255),   // 黄色
        cv::Scalar(255, 255, 0),   // 青色
        cv::Scalar(255, 0, 255),   // 品红
        cv::Scalar(128, 128, 128), // 灰色
        cv::Scalar(0, 0, 0),       // 黑色
        cv::Scalar(255, 255, 255)  // 白色
    };
    
    int block_size = 40;
    for (size_t i = 0; i < color_blocks.size(); i++) {
        int x = 20 + (i % 3) * (block_size + 10);
        int y = height - 120 + (i / 3) * (block_size + 10);
        cv::rectangle(image, cv::Rect(x, y, block_size, block_size), 
                     color_blocks[i], -1);
        cv::rectangle(image, cv::Rect(x, y, block_size, block_size), 
                     cv::Scalar(255, 255, 255), 1);
    }
    
    return image;
}

int main() {
    std::cout << "=== OpenCV 色彩空间与通道操作 ===\n" << std::endl;
    
    // ============================================
    // 1. 创建测试图像
    // ============================================
    
    std::cout << "1. 创建测试图像..." << std::endl;
    cv::Mat original = createColorTestImage(800, 600);
    showImageInfo(original, "原始图像");
    
    // ============================================
    // 2. 色彩空间转换
    // ============================================
    
    std::cout << "\n2. 色彩空间转换" << std::endl;
    
    // 2.1 RGB/BGR 转灰度
    cv::Mat gray;
    cv::cvtColor(original, gray, cv::COLOR_BGR2GRAY);
    showImageInfo(gray, "   灰度图像");
    
    // 2.2 BGR 转 HSV
    cv::Mat hsv;
    cv::cvtColor(original, hsv, cv::COLOR_BGR2HSV);
    showImageInfo(hsv, "   HSV图像");
    
    // 2.3 BGR 转 LAB
    cv::Mat lab;
    cv::cvtColor(original, lab, cv::COLOR_BGR2Lab);
    showImageInfo(lab, "   Lab图像");
    
    // 2.4 BGR 转 YCrCb
    cv::Mat ycrcb;
    cv::cvtColor(original, ycrcb, cv::COLOR_BGR2YCrCb);
    showImageInfo(ycrcb, "   YCrCb图像");
    
    // 2.5 反向转换
    cv::Mat bgr_from_hsv, bgr_from_lab, bgr_from_ycrcb;
    cv::cvtColor(hsv, bgr_from_hsv, cv::COLOR_HSV2BGR);
    cv::cvtColor(lab, bgr_from_lab, cv::COLOR_Lab2BGR);
    cv::cvtColor(ycrcb, bgr_from_ycrcb, cv::COLOR_YCrCb2BGR);
    
    // ============================================
    // 3. 通道拆分与合并
    // ============================================
    
    std::cout << "\n3. 通道拆分与合并" << std::endl;
    
    // 3.1 拆分BGR通道
    std::vector<cv::Mat> bgr_channels;
    cv::split(original, bgr_channels);
    
    std::cout << "   BGR通道拆分: ";
    std::cout << "B(" << bgr_channels[0].cols << "×" << bgr_channels[0].rows << ") ";
    std::cout << "G(" << bgr_channels[1].cols << "×" << bgr_channels[1].rows << ") ";
    std::cout << "R(" << bgr_channels[2].cols << "×" << bgr_channels[2].rows << ")" << std::endl;
    
    // 3.2 拆分HSV通道
    std::vector<cv::Mat> hsv_channels;
    cv::split(hsv, hsv_channels);
    std::cout << "   HSV通道拆分: H(色调), S(饱和度), V(明度)" << std::endl;
    
    // 3.3 创建单通道图像用于演示
    cv::Mat blue_channel = bgr_channels[0].clone();
    cv::Mat green_channel = bgr_channels[1].clone();
    cv::Mat red_channel = bgr_channels[2].clone();
    
    // 3.4 通道合并
    std::vector<cv::Mat> custom_channels;
    custom_channels.push_back(blue_channel);      // B通道
    custom_channels.push_back(cv::Mat::zeros(original.size(), CV_8UC1));  // G通道设为0
    custom_channels.push_back(cv::Mat::zeros(original.size(), CV_8UC1));  // R通道设为0
    
    cv::Mat blue_only;
    cv::merge(custom_channels, blue_only);
    
    std::cout << "   创建只显示蓝色通道的图像" << std::endl;
    
    // 3.5 交换通道顺序（BGR转RGB）
    std::vector<cv::Mat> rgb_channels;
    rgb_channels.push_back(bgr_channels[2]);  // R
    rgb_channels.push_back(bgr_channels[1]);  // G
    rgb_channels.push_back(bgr_channels[0]);  // B
    
    cv::Mat rgb_image;
    cv::merge(rgb_channels, rgb_image);
    
    // ============================================
    // 4. HSV颜色识别（提取红色区域）
    // ============================================
    
    std::cout << "\n4. HSV颜色识别：提取红色区域" << std::endl;
    
    // 4.1 定义红色范围（HSV空间）
    // 注意：OpenCV中H范围是0-180（不是0-360）
    cv::Mat red_mask1, red_mask2, red_mask;
    
    // 红色在HSV中跨越0度和180度（因为色调是圆形）
    cv::inRange(hsv, cv::Scalar(0, 70, 50), cv::Scalar(10, 255, 255), red_mask1);     // 红色低范围
    cv::inRange(hsv, cv::Scalar(170, 70, 50), cv::Scalar(180, 255, 255), red_mask2);  // 红色高范围
    
    // 合并两个范围
    cv::bitwise_or(red_mask1, red_mask2, red_mask);
    
    // 4.2 形态学操作优化掩膜
    cv::Mat kernel = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(5, 5));
    cv::morphologyEx(red_mask, red_mask, cv::MORPH_CLOSE, kernel);  // 闭运算填充空洞
    cv::morphologyEx(red_mask, red_mask, cv::MORPH_OPEN, kernel);   // 开运算去除噪声
    
    // 4.3 应用掩膜提取红色区域
    cv::Mat red_extracted;
    original.copyTo(red_extracted, red_mask);
    
    std::cout << "   红色区域提取完成" << std::endl;
    
    // 4.4 其他颜色提取示例
    cv::Mat green_mask, blue_mask, yellow_mask;
    
    // 绿色范围
    cv::inRange(hsv, cv::Scalar(35, 70, 50), cv::Scalar(85, 255, 255), green_mask);
    
    // 蓝色范围
    cv::inRange(hsv, cv::Scalar(100, 70, 50), cv::Scalar(130, 255, 255), blue_mask);
    
    // 黄色范围
    cv::inRange(hsv, cv::Scalar(20, 70, 50), cv::Scalar(35, 255, 255), yellow_mask);
    
    // ============================================
    // 5. 通道操作高级应用
    // ============================================
    
    std::cout << "\n5. 通道操作高级应用" << std::endl;
    
    // 5.1 修改特定通道
    cv::Mat enhanced_red = original.clone();
    std::vector<cv::Mat> enhanced_channels;
    cv::split(enhanced_red, enhanced_channels);
    
    // 增强红色通道（提高对比度）
    cv::Mat red_enhanced;
    cv::equalizeHist(enhanced_channels[2], red_enhanced);
    enhanced_channels[2] = red_enhanced;
    
    cv::merge(enhanced_channels, enhanced_red);
    
    // 5.2 创建伪彩色图像（将灰度图映射为彩色）
    cv::Mat pseudocolor;
    cv::applyColorMap(gray, pseudocolor, cv::COLORMAP_JET);
    
    // 5.3 通道混合（创建特殊效果）
    cv::Mat special_effect;
    std::vector<cv::Mat> effect_channels;
    
    // 使用不同通道组合
    effect_channels.push_back(bgr_channels[2]);  // 红色通道作为蓝色
    effect_channels.push_back(bgr_channels[0]);  // 蓝色通道作为绿色
    effect_channels.push_back(bgr_channels[1]);  // 绿色通道作为红色
    
    cv::merge(effect_channels, special_effect);
    
    std::cout << "   通道混合效果创建完成" << std::endl;
    
    // 5.4 计算通道统计信息
    cv::Scalar mean_bgr, stddev_bgr;
    cv::meanStdDev(original, mean_bgr, stddev_bgr);
    
    std::cout << "\n   BGR通道统计:" << std::endl;
    std::cout << "     均值: B=" << mean_bgr[0] << ", G=" << mean_bgr[1] << ", R=" << mean_bgr[2] << std::endl;
    std::cout << "     标准差: B=" << stddev_bgr[0] << ", G=" << stddev_bgr[1] << ", R=" << stddev_bgr[2] << std::endl;
    
    // 5.5 通道直方图（简化显示）
    std::cout << "\n   通道直方图统计:" << std::endl;
    
    for (int i = 0; i < 3; i++) {
        // 计算直方图
        int histSize = 256;
        float range[] = {0, 256};
        const float* histRange = {range};
        
        cv::Mat hist;
        cv::calcHist(&bgr_channels[i], 1, 0, cv::Mat(), hist, 1, &histSize, &histRange);
        
        // 找到最大值
        double min_val, max_val;
        cv::minMaxLoc(hist, &min_val, &max_val);
        
        // 简化为10个区间显示
        std::cout << "     通道" << i << ": ";
        int bin_step = histSize / 10;
        for (int j = 0; j < 10; j++) {
            int bin_start = j * bin_step;
            int bin_end = (j + 1) * bin_step;
            float sum = 0;
            
            for (int k = bin_start; k < bin_end && k < histSize; k++) {
                sum += hist.at<float>(k);
            }
            
            // 显示相对频率
            int stars = static_cast<int>(sum / max_val * 20);
            std::cout << std::string(stars, '*');
            if (j < 9) std::cout << "|";
        }
        std::cout << std::endl;
    }
    
    // ============================================
    // 6. 创建显示面板
    // ============================================
    
    std::cout << "\n6. 创建结果显示面板..." << std::endl;
    
    int panel_width = 1600;
    int panel_height = 1000;
    cv::Mat display_panel(panel_height, panel_width, CV_8UC3, cv::Scalar(40, 40, 40));
    
    // 6.1 定义布局
    int thumb_width = 380;
    int thumb_height = 285;
    
    // 6.2 准备所有图像
    struct DisplayItem {
        cv::Mat image;
        std::string label;
        cv::Scalar text_color;
    };
    
    std::vector<DisplayItem> display_items = {
        {original, "原始图像 (BGR)", cv::Scalar(255, 255, 255)},
        {gray, "灰度图像", cv::Scalar(255, 255, 255)},
        {hsv, "HSV色彩空间", cv::Scalar(255, 255, 255)},
        {lab, "Lab色彩空间", cv::Scalar(255, 255, 255)},
        {bgr_from_hsv, "BGR (从HSV转换)", cv::Scalar(255, 255, 255)},
        {red_extracted, "红色区域提取", cv::Scalar(0, 0, 255)},
        {enhanced_red, "增强红色通道", cv::Scalar(255, 255, 255)},
        {pseudocolor, "伪彩色 (JET)", cv::Scalar(255, 255, 255)},
        {special_effect, "通道混合效果", cv::Scalar(255, 255, 255)}
    };
    
    // 6.3 添加通道分离图像
    std::vector<cv::Mat> channel_display;
    for (int i = 0; i < 3; i++) {
        cv::Mat channel_color;
        std::vector<cv::Mat> single_channel(3, cv::Mat::zeros(original.size(), CV_8UC1));
        single_channel[i] = bgr_channels[i];
        cv::merge(single_channel, channel_color);
        
        std::string channel_name;
        cv::Scalar text_color;
        
        switch(i) {
            case 0: channel_name = "蓝色通道"; text_color = cv::Scalar(255, 0, 0); break;
            case 1: channel_name = "绿色通道"; text_color = cv::Scalar(0, 255, 0); break;
            case 2: channel_name = "红色通道"; text_color = cv::Scalar(0, 0, 255); break;
        }
        
        display_items.push_back({channel_color, channel_name, text_color});
    }
    
    // 6.4 添加HSV通道图像
    std::vector<std::string> hsv_names = {"色调 (H)", "饱和度 (S)", "明度 (V)"};
    for (int i = 0; i < 3; i++) {
        // 将单通道转换为伪彩色以便观察
        cv::Mat pseudocolor_channel;
        cv::applyColorMap(hsv_channels[i], pseudocolor_channel, cv::COLORMAP_JET);
        
        display_items.push_back({pseudocolor_channel, hsv_names[i], cv::Scalar(255, 255, 255)});
    }
    
    // 6.5 排列图像
    int cols = 4;
    for (size_t i = 0; i < display_items.size(); i++) {
        int row = i / cols;
        int col = i % cols;
        
        int x = col * (thumb_width + 20) + 20;
        int y = row * (thumb_height + 40) + 40;
        
        // 检查边界
        if (y + thumb_height >= panel_height) {
            // 创建第二个面板
            panel_height += thumb_height + 100;
            cv::Mat new_panel(panel_height, panel_width, CV_8UC3, cv::Scalar(40, 40, 40));
            display_panel.copyTo(new_panel(cv::Rect(0, 0, display_panel.cols, display_panel.rows)));
            display_panel = new_panel;
        }
        
        // 调整图像尺寸
        cv::Mat thumb;
        cv::resize(display_items[i].image, thumb, cv::Size(thumb_width, thumb_height));
        
        // 复制到面板
        cv::Rect roi(x, y, thumb_width, thumb_height);
        thumb.copyTo(display_panel(roi));
        
        // 添加边框
        cv::rectangle(display_panel, roi, cv::Scalar(180, 180, 180), 2);
        
        // 添加标签
        cv::putText(display_panel, display_items[i].label,
                   cv::Point(x + 10, y + thumb_height + 25),
                   cv::FONT_HERSHEY_SIMPLEX, 0.6, display_items[i].text_color, 1);
        
        // 添加序号
        cv::putText(display_panel, std::to_string(i + 1),
                   cv::Point(x + 10, y + 20),
                   cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 255, 255), 1);
    }
    
    // 6.6 添加标题和说明
    cv::putText(display_panel, "OpenCV 色彩空间与通道操作演示",
               cv::Point(panel_width / 2 - 250, 30),
               cv::FONT_HERSHEY_SIMPLEX, 0.9, cv::Scalar(0, 255, 255), 2);
    
    // 添加图例
    cv::putText(display_panel, "色彩空间: BGR, HSV, Lab, YCrCb",
               cv::Point(20, panel_height - 60),
               cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(200, 200, 200), 1);
    
    cv::putText(display_panel, "操作: 转换, 拆分, 合并, 颜色提取",
               cv::Point(20, panel_height - 40),
               cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(200, 200, 200), 1);
    
    cv::putText(display_panel, "按ESC退出, 按's'保存结果",
               cv::Point(panel_width - 300, panel_height - 20),
               cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(200, 200, 200), 1);
    
    // ============================================
    // 7. 交互演示：颜色选择器
    // ============================================
    
    std::cout << "\n7. 交互演示：HSV颜色选择器" << std::endl;
    
    // 创建颜色选择器窗口
    cv::namedWindow("颜色选择器", cv::WINDOW_NORMAL);
    cv::resizeWindow("颜色选择器", 600, 400);
    
    // 创建控制参数
    int h_min = 0, h_max = 180;
    int s_min = 0, s_max = 255;
    int v_min = 0, v_max = 255;
    
    // 创建控制面板
    cv::namedWindow("控制面板", cv::WINDOW_NORMAL);
    cv::resizeWindow("控制面板", 400, 500);
    
    // 创建滑动条回调函数
    auto updateColorPicker = [&]() {
        cv::Mat control_panel(500, 400, CV_8UC3, cv::Scalar(50, 50, 50));
        
        // 标题
        cv::putText(control_panel, "=== HSV颜色选择器 ===",
                   cv::Point(20, 30), cv::FONT_HERSHEY_SIMPLEX,
                   0.7, cv::Scalar(0, 255, 255), 2);
        
        // 显示当前范围
        cv::putText(control_panel, "H: [" + std::to_string(h_min) + ", " + std::to_string(h_max) + "]",
                   cv::Point(20, 70), cv::FONT_HERSHEY_SIMPLEX,
                   0.6, cv::Scalar(200, 200, 200), 1);
        
        cv::putText(control_panel, "S: [" + std::to_string(s_min) + ", " + std::to_string(s_max) + "]",
                   cv::Point(20, 100), cv::FONT_HERSHEY_SIMPLEX,
                   0.6, cv::Scalar(200, 200, 200), 1);
        
        cv::putText(control_panel, "V: [" + std::to_string(v_min) + ", " + std::to_string(v_max) + "]",
                   cv::Point(20, 130), cv::FONT_HERSHEY_SIMPLEX,
                   0.6, cv::Scalar(200, 200, 200), 1);
        
        // 创建滑动条显示
        int bar_width = 360;
        int bar_height = 20;
        int bar_x = 20;
        
        // H滑动条
        cv::rectangle(control_panel, cv::Rect(bar_x, 160, bar_width, bar_height),
                     cv::Scalar(100, 100, 100), -1);
        int h_pos = bar_x + (h_min * bar_width / 180);
        int h_width = (h_max - h_min) * bar_width / 180;
        cv::rectangle(control_panel, cv::Rect(h_pos, 160, h_width, bar_height),
                     cv::Scalar(0, 255, 0), -1);
        cv::putText(control_panel, "Hue (色调)", cv::Point(bar_x, 155),
                   cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(200, 200, 200), 1);
        
        // S滑动条
        cv::rectangle(control_panel, cv::Rect(bar_x, 200, bar_width, bar_height),
                     cv::Scalar(100, 100, 100), -1);
        int s_pos = bar_x + (s_min * bar_width / 255);
        int s_width = (s_max - s_min) * bar_width / 255;
        cv::rectangle(control_panel, cv::Rect(s_pos, 200, s_width, bar_height),
                     cv::Scalar(0, 255, 0), -1);
        cv::putText(control_panel, "Saturation (饱和度)", cv::Point(bar_x, 195),
                   cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(200, 200, 200), 1);
        
        // V滑动条
        cv::rectangle(control_panel, cv::Rect(bar_x, 240, bar_width, bar_height),
                     cv::Scalar(100, 100, 100), -1);
        int v_pos = bar_x + (v_min * bar_width / 255);
        int v_width = (v_max - v_min) * bar_width / 255;
        cv::rectangle(control_panel, cv::Rect(v_pos, 240, v_width, bar_height),
                     cv::Scalar(0, 255, 0), -1);
        cv::putText(control_panel, "Value (明度)", cv::Point(bar_x, 235),
                   cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(200, 200, 200), 1);
        
        // 操作说明
        cv::putText(control_panel, "按键控制:", cv::Point(20, 290),
                   cv::FONT_HERSHEY_SIMPLEX, 0.6, cv::Scalar(0, 255, 0), 1);
        
        std::vector<std::string> instructions = {
            "Q/W: 调整H最小值",
            "A/S: 调整H最大值",
            "E/R: 调整S最小值",
            "D/F: 调整S最大值",
            "T/Y: 调整V最小值",
            "G/H: 调整V最大值",
            "空格: 重置所有参数",
            "ESC: 退出程序"
        };
        
        for (size_t i = 0; i < instructions.size(); i++) {
            cv::putText(control_panel, instructions[i],
                       cv::Point(30, 320 + i * 25),
                       cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(200, 200, 200), 1);
        }
        
        // 显示当前选择的颜色
        cv::Mat color_sample(50, 200, CV_8UC3);
        
        // 计算HSV中间值
        cv::Scalar hsv_color(
            (h_min + h_max) / 2,
            (s_min + s_max) / 2,
            (v_min + v_max) / 2
        );
        
        // 转换为BGR显示
        cv::Mat hsv_mat(1, 1, CV_8UC3, hsv_color);
        cv::Mat bgr_mat;
        cv::cvtColor(hsv_mat, bgr_mat, cv::COLOR_HSV2BGR);
        cv::Vec3b bgr_color = bgr_mat.at<cv::Vec3b>(0, 0);
        
        color_sample.setTo(cv::Scalar(bgr_color[0], bgr_color[1], bgr_color[2]));
        
        // 添加到控制面板
        cv::Rect color_rect(100, 420, 200, 50);
        color_sample.copyTo(control_panel(color_rect));
        cv::rectangle(control_panel, color_rect, cv::Scalar(255, 255, 255), 2);
        
        cv::putText(control_panel, "当前颜色",
                   cv::Point(20, 445), cv::FONT_HERSHEY_SIMPLEX,
                   0.6, cv::Scalar(200, 200, 200), 1);
        
        cv::imshow("控制面板", control_panel);
        
        // 更新颜色选择器显示
        cv::Mat color_mask;
        cv::inRange(hsv, cv::Scalar(h_min, s_min, v_min), 
                   cv::Scalar(h_max, s_max, v_max), color_mask);
        
        cv::Mat color_result;
        original.copyTo(color_result, color_mask);
        
        // 添加轮廓
        std::vector<std::vector<cv::Point>> contours;
        cv::findContours(color_mask, contours, cv::RETR_EXTERNAL, cv::CHAIN_APPROX_SIMPLE);
        
        for (const auto& contour : contours) {
            if (cv::contourArea(contour) > 100) {  // 只显示面积大于100的轮廓
                cv::drawContours(color_result, std::vector<std::vector<cv::Point>>{contour}, 
                               0, cv::Scalar(255, 255, 255), 2);
            }
        }
        
        // 添加信息
        cv::putText(color_result, "HSV范围: [" + std::to_string(h_min) + "," + std::to_string(h_max) + "]",
                   cv::Point(10, 30), cv::FONT_HERSHEY_SIMPLEX, 0.7, cv::Scalar(0, 255, 0), 2);
        cv::putText(color_result, "按ESC退出选择器",
                   cv::Point(10, 60), cv::FONT_HERSHEY_SIMPLEX, 0.6, cv::Scalar(255, 255, 255), 1);
        
        cv::imshow("颜色选择器", color_result);
    };
    
    // 初始显示
    updateColorPicker();
    
    // 主循环
    while (true) {
        int key = cv::waitKey(0);
        
        if (key == 27) {  // ESC
            break;
        } else if (key == 'q' || key == 'Q') {
            h_min = std::max(0, h_min - 5);
            updateColorPicker();
        } else if (key == 'w' || key == 'W') {
            h_min = std::min(h_max - 1, h_min + 5);
            updateColorPicker();
        } else if (key == 'a' || key == 'A') {
            h_max = std::max(h_min + 1, h_max - 5);
            updateColorPicker();
        } else if (key == 's' || key == 'S') {
            h_max = std::min(180, h_max + 5);
            updateColorPicker();
        } else if (key == 'e' || key == 'E') {
            s_min = std::max(0, s_min - 5);
            updateColorPicker();
        } else if (key == 'r' || key == 'R') {
            s_min = std::min(s_max - 1, s_min + 5);
            updateColorPicker();
        } else if (key == 'd' || key == 'D') {
            s_max = std::max(s_min + 1, s_max - 5);
            updateColorPicker();
        } else if (key == 'f' || key == 'F') {
            s_max = std::min(255, s_max + 5);
            updateColorPicker();
        } else if (key == 't' || key == 'T') {
            v_min = std::max(0, v_min - 5);
            updateColorPicker();
        } else if (key == 'y' || key == 'Y') {
            v_min = std::min(v_max - 1, v_min + 5);
            updateColorPicker();
        } else if (key == 'g' || key == 'G') {
            v_max = std::max(v_min + 1, v_max - 5);
            updateColorPicker();
        } else if (key == 'h' || key == 'H') {
            v_max = std::min(255, v_max + 5);
            updateColorPicker();
        } else if (key == ' ') {
            // 重置
            h_min = 0; h_max = 180;
            s_min = 0; s_max = 255;
            v_min = 0; v_max = 255;
            updateColorPicker();
        } else if (key == '1') {
            // 红色范围
            h_min = 0; h_max = 10;
            s_min = 100; s_max = 255;
            v_min = 50; v_max = 255;
            updateColorPicker();
        } else if (key == '2') {
            // 绿色范围
            h_min = 35; h_max = 85;
            s_min = 100; s_max = 255;
            v_min = 50; v_max = 255;
            updateColorPicker();
        } else if (key == '3') {
            // 蓝色范围
            h_min = 100; h_max = 130;
            s_min = 100; s_max = 255;
            v_min = 50; v_max = 255;
            updateColorPicker();
        } else if (key == 's' || key == 'S') {
            // 保存当前结果
            cv::imwrite("color_space_demo.jpg", display_panel);
            std::cout << "已保存结果到 color_space_demo.jpg" << std::endl;
        }
    }
    
    cv::destroyAllWindows();
    
    std::cout << "\n=== 色彩空间与通道操作演示完成 ===" << std::endl;
    std::cout << "总结：" << std::endl;
    std::cout << "1. 掌握了色彩空间转换（BGR↔灰度↔HSV↔Lab）" << std::endl;
    std::cout << "2. 学会了通道拆分、合并和单通道处理" << std::endl;
    std::cout << "3. 实现了HSV颜色识别和提取" << std::endl;
    std::cout << "4. 了解了不同色彩空间的特点和应用场景" << std::endl;
    
    return 0;
}
```

### 1.2 关键知识点总结

#### 1. 色彩空间转换要点
- **BGR vs RGB**：OpenCV默认使用BGR顺序，显示时需要注意
- **HSV范围**：H通道范围0-180（OpenCV将0-360压缩为0-180），S和V范围0-255
- **转换精度**：浮点图像转换更精确，但计算量更大

#### 2. 通道操作技巧
- **高效拆分**：`split()`函数比循环访问像素快得多
- **内存共享**：拆分后的通道与原始图像共享内存，修改需谨慎
- **通道重组**：`merge()`可以创建任意通道顺序的图像

#### 3. HSV颜色识别最佳实践
1. **光照影响**：V通道（明度）受光照影响大，需合理设置范围
2. **饱和度过滤**：低饱和度区域通常不是鲜艳颜色，可用S通道过滤
3. **色调处理**：红色在色调圆环两端，需要两个范围合并
4. **形态学优化**：使用开闭运算优化掩膜质量

#### 4. 性能优化建议
- **减少转换**：避免不必要的色彩空间转换
- **使用查找表**：对于固定转换，可使用LUT加速
- **并行处理**：多通道可并行处理，利用多核CPU

这个补充笔记详细介绍了色彩空间转换和通道操作的各个方面，从基础概念到实际应用，包含了丰富的代码示例和交互演示，可以帮助深入理解和掌握OpenCV中的颜色处理技术。



# OpenCV 图像处理进阶笔记（续）

## 五、图像滤波与降噪（预处理必备）

### 5.1 图像滤波基础

#### 讲解
图像滤波是图像处理中的基本操作，主要用于去除噪声、平滑图像、增强特征等。滤波器可以分为线性滤波和非线性滤波。理解滤波器的核（kernel）以及不同滤波器的适用场景对于选择正确的滤波方法至关重要。

#### 核心概念

| 概念 | 说明 | 数学表示 |
|------|------|----------|
| **核（Kernel）** | 一个小矩阵，用于在图像上滑动并进行卷积操作 | 3×3, 5×5等 |
| **卷积** | 将核与图像对应区域逐元素相乘并求和 | `dst(x,y) = sum(kernel(i,j) * src(x+i, y+j))` |
| **边界处理** | 处理图像边界时的方法 | `BORDER_CONSTANT`, `BORDER_REPLICATE` |

#### 常用滤波器

| 滤波器类型 | OpenCV函数 | 特点 | 适用场景 |
|------------|------------|------|----------|
| **均值滤波** | `blur()` | 核内取平均，简单快速 | 去除随机噪声，但会使图像模糊 |
| **高斯滤波** | `GaussianBlur()` | 加权平均，权重服从高斯分布 | 去除高斯噪声，保持边缘较好 |
| **中值滤波** | `medianBlur()` | 取核内中值，非线性滤波 | 去除椒盐噪声，保护边缘 |
| **双边滤波** | `bilateralFilter()` | 同时考虑空间距离和像素差异 | 保边去噪，可用于图像美化 |

#### 滤波实战代码

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>
#include <vector>

// 显示图像信息
void showImageInfo(const cv::Mat& img, const std::string& name) {
    std::cout << name << ": " << img.cols << "×" << img.rows 
              << " (" << img.channels() << " channels)" << std::endl;
}

// 创建测试图像
cv::Mat createTestImage(int width, int height) {
    cv::Mat image(height, width, CV_8UC3, cv::Scalar(100, 100, 100));
    
    // 添加一些图形
    cv::rectangle(image, cv::Rect(50, 50, 200, 150), cv::Scalar(200, 200, 200), -1);
    cv::circle(image, cv::Point(400, 300), 80, cv::Scalar(50, 50, 200), -1);
    cv::line(image, cv::Point(100, 400), cv::Point(700, 100), cv::Scalar(200, 50, 50), 3);
    
    // 添加文字
    cv::putText(image, "OpenCV Filter Demo", cv::Point(150, 80),
                cv::FONT_HERSHEY_SIMPLEX, 1.2, cv::Scalar(255, 255, 255), 2);
    
    return image;
}

// 添加噪声
void addNoise(cv::Mat& image, double noise_level, int noise_type) {
    cv::Mat noise(image.size(), image.type());
    
    if (noise_type == 0) {
        // 高斯噪声
        cv::randn(noise, 0, noise_level * 255);
        image += noise;
        cv::normalize(image, image, 0, 255, cv::NORM_MINMAX, CV_8UC3);
    } else if (noise_type == 1) {
        // 椒盐噪声
        int num_pixels = static_cast<int>(noise_level * image.total());
        for (int i = 0; i < num_pixels; i++) {
            int x = rand() % image.cols;
            int y = rand() % image.rows;
            int channel = rand() % image.channels();
            
            if (rand() % 2 == 0) {
                image.at<cv::Vec3b>(y, x)[channel] = 0;   // 椒噪声（黑色）
            } else {
                image.at<cv::Vec3b>(y, x)[channel] = 255; // 盐噪声（白色）
            }
        }
    }
}

int main() {
    std::cout << "=== OpenCV 图像滤波与降噪 ===\n" << std::endl;
    
    // ============================================
    // 1. 创建测试图像
    // ============================================
    
    std::cout << "1. 创建测试图像..." << std::endl;
    cv::Mat original = createTestImage(800, 600);
    showImageInfo(original, "原始图像");
    
    // ============================================
    // 2. 添加噪声
    // ============================================
    
    std::cout << "\n2. 添加噪声..." << std::endl;
    
    cv::Mat gaussian_noise_img = original.clone();
    addNoise(gaussian_noise_img, 0.1, 0);  // 高斯噪声
    std::cout << "   添加高斯噪声" << std::endl;
    
    cv::Mat saltpepper_noise_img = original.clone();
    addNoise(saltpepper_noise_img, 0.05, 1);  // 椒盐噪声
    std::cout << "   添加椒盐噪声" << std::endl;
    
    // ============================================
    // 3. 均值滤波
    // ============================================
    
    std::cout << "\n3. 均值滤波 (blur)" << std::endl;
    
    cv::Mat blur_result_gaussian, blur_result_saltpepper;
    
    // 3×3均值滤波
    cv::blur(gaussian_noise_img, blur_result_gaussian, cv::Size(3, 3));
    cv::blur(saltpepper_noise_img, blur_result_saltpepper, cv::Size(3, 3));
    std::cout << "   3×3核大小" << std::endl;
    
    // 不同核大小比较
    cv::Mat blur_5x5, blur_9x9;
    cv::blur(gaussian_noise_img, blur_5x5, cv::Size(5, 5));
    cv::blur(gaussian_noise_img, blur_9x9, cv::Size(9, 9));
    
    // ============================================
    // 4. 高斯滤波
    // ============================================
    
    std::cout << "\n4. 高斯滤波 (GaussianBlur)" << std::endl;
    
    cv::Mat gaussian_result_gaussian, gaussian_result_saltpepper;
    
    // 3×3高斯滤波，标准差为0（自动计算）
    cv::GaussianBlur(gaussian_noise_img, gaussian_result_gaussian, cv::Size(3, 3), 0);
    cv::GaussianBlur(saltpepper_noise_img, gaussian_result_saltpepper, cv::Size(3, 3), 0);
    std::cout << "   3×3核大小，标准差自动计算" << std::endl;
    
    // 不同标准差比较
    cv::Mat gaussian_sigma1, gaussian_sigma3;
    cv::GaussianBlur(gaussian_noise_img, gaussian_sigma1, cv::Size(5, 5), 1.0);
    cv::GaussianBlur(gaussian_noise_img, gaussian_sigma3, cv::Size(5, 5), 3.0);
    
    // ============================================
    // 5. 中值滤波
    // ============================================
    
    std::cout << "\n5. 中值滤波 (medianBlur)" << std::endl;
    
    cv::Mat median_result_gaussian, median_result_saltpepper;
    
    // 3×3中值滤波
    cv::medianBlur(gaussian_noise_img, median_result_gaussian, 3);
    cv::medianBlur(saltpepper_noise_img, median_result_saltpepper, 3);
    std::cout << "   3×3核大小" << std::endl;
    
    // 不同核大小比较
    cv::Mat median_5, median_7;
    cv::medianBlur(saltpepper_noise_img, median_5, 5);
    cv::medianBlur(saltpepper_noise_img, median_7, 7);
    
    // ============================================
    // 6. 双边滤波
    // ============================================
    
    std::cout << "\n6. 双边滤波 (bilateralFilter)" << std::endl;
    
    cv::Mat bilateral_result_gaussian, bilateral_result_saltpepper;
    
    // 双边滤波
    cv::bilateralFilter(gaussian_noise_img, bilateral_result_gaussian, 9, 75, 75);
    cv::bilateralFilter(saltpepper_noise_img, bilateral_result_saltpepper, 9, 75, 75);
    std::cout << "   直径=9，颜色空间标准差=75，坐标空间标准差=75" << std::endl;
    
    // 不同参数比较
    cv::Mat bilateral_small, bilateral_large;
    cv::bilateralFilter(gaussian_noise_img, bilateral_small, 5, 25, 25);
    cv::bilateralFilter(gaussian_noise_img, bilateral_large, 15, 150, 150);
    
    // ============================================
    // 7. 创建显示面板
    // ============================================
    
    std::cout << "\n7. 创建结果显示面板..." << std::endl;
    
    int panel_width = 1600;
    int panel_height = 1200;
    cv::Mat display_panel(panel_height, panel_width, CV_8UC3, cv::Scalar(40, 40, 40));
    
    // 7.1 定义缩略图尺寸
    int thumb_width = 350;
    int thumb_height = 260;
    
    // 7.2 准备所有图像
    struct DisplayItem {
        cv::Mat image;
        std::string label;
    };
    
    std::vector<DisplayItem> display_items = {
        {original, "原始图像"},
        {gaussian_noise_img, "高斯噪声图像"},
        {saltpepper_noise_img, "椒盐噪声图像"},
        {blur_result_gaussian, "均值滤波(高斯噪声)"},
        {blur_result_saltpepper, "均值滤波(椒盐噪声)"},
        {gaussian_result_gaussian, "高斯滤波(高斯噪声)"},
        {gaussian_result_saltpepper, "高斯滤波(椒盐噪声)"},
        {median_result_gaussian, "中值滤波(高斯噪声)"},
        {median_result_saltpepper, "中值滤波(椒盐噪声)"},
        {bilateral_result_gaussian, "双边滤波(高斯噪声)"},
        {bilateral_result_saltpepper, "双边滤波(椒盐噪声)"}
    };
    
    // 7.3 排列图像
    int cols = 4;
    for (size_t i = 0; i < display_items.size(); i++) {
        int row = i / cols;
        int col = i % cols;
        
        int x = col * (thumb_width + 20) + 20;
        int y = row * (thumb_height + 40) + 40;
        
        // 调整图像尺寸
        cv::Mat thumb;
        cv::resize(display_items[i].image, thumb, cv::Size(thumb_width, thumb_height));
        
        // 复制到面板
        cv::Rect roi(x, y, thumb_width, thumb_height);
        thumb.copyTo(display_panel(roi));
        
        // 添加边框
        cv::rectangle(display_panel, roi, cv::Scalar(180, 180, 180), 2);
        
        // 添加标签
        cv::putText(display_panel, display_items[i].label,
                   cv::Point(x + 10, y + thumb_height + 25),
                   cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(220, 220, 220), 1);
    }
    
    // 7.4 添加标题和说明
    cv::putText(display_panel, "OpenCV 图像滤波与降噪演示",
               cv::Point(panel_width / 2 - 250, 30),
               cv::FONT_HERSHEY_SIMPLEX, 0.9, cv::Scalar(0, 255, 255), 2);
    
    cv::putText(display_panel, "噪声类型: 高斯噪声, 椒盐噪声",
               cv::Point(20, panel_height - 80),
               cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(200, 200, 200), 1);
    
    cv::putText(display_panel, "滤波方法: 均值滤波, 高斯滤波, 中值滤波, 双边滤波",
               cv::Point(20, panel_height - 60),
               cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(200, 200, 200), 1);
    
    cv::putText(display_panel, "按ESC退出, 按's'保存结果",
               cv::Point(panel_width - 300, panel_height - 20),
               cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(200, 200, 200), 1);
    
    // ============================================
    // 8. 交互演示：实时滤波参数调整
    // ============================================
    
    std::cout << "\n8. 交互演示：实时滤波参数调整" << std::endl;
    
    cv::namedWindow("滤波效果对比", cv::WINDOW_NORMAL);
    cv::resizeWindow("滤波效果对比", 800, 600);
    
    cv::namedWindow("控制面板", cv::WINDOW_NORMAL);
    cv::resizeWindow("控制面板", 400, 500);
    
    // 控制参数
    int filter_type = 0;  // 0:均值, 1:高斯, 2:中值, 3:双边
    int kernel_size = 3;
    int sigma = 1;
    int bilateral_diameter = 9;
    int bilateral_sigma_color = 75;
    int bilateral_sigma_space = 75;
    
    // 创建控制面板
    cv::Mat control_panel(500, 400, CV_8UC3, cv::Scalar(50, 50, 50));
    
    // 更新控制面板和滤波效果
    auto updateFilterDemo = [&]() {
        control_panel.setTo(cv::Scalar(50, 50, 50));
        
        // 标题
        cv::putText(control_panel, "=== 滤波控制面板 ===",
                   cv::Point(20, 30), cv::FONT_HERSHEY_SIMPLEX,
                   0.7, cv::Scalar(0, 255, 255), 2);
        
        // 当前参数
        std::vector<std::string> filter_names = {"均值滤波", "高斯滤波", "中值滤波", "双边滤波"};
        cv::putText(control_panel, "当前滤波: " + filter_names[filter_type],
                   cv::Point(20, 70), cv::FONT_HERSHEY_SIMPLEX,
                   0.6, cv::Scalar(200, 200, 200), 1);
        
        cv::putText(control_panel, "核大小: " + std::to_string(kernel_size),
                   cv::Point(20, 100), cv::FONT_HERSHEY_SIMPLEX,
                   0.6, cv::Scalar(200, 200, 200), 1);
        
        if (filter_type == 1) {  // 高斯滤波
            cv::putText(control_panel, "标准差: " + std::to_string(sigma),
                       cv::Point(20, 130), cv::FONT_HERSHEY_SIMPLEX,
                       0.6, cv::Scalar(200, 200, 200), 1);
        } else if (filter_type == 3) {  // 双边滤波
            cv::putText(control_panel, "直径: " + std::to_string(bilateral_diameter),
                       cv::Point(20, 130), cv::FONT_HERSHEY_SIMPLEX,
                       0.6, cv::Scalar(200, 200, 200), 1);
            cv::putText(control_panel, "颜色标准差: " + std::to_string(bilateral_sigma_color),
                       cv::Point(20, 160), cv::FONT_HERSHEY_SIMPLEX,
                       0.6, cv::Scalar(200, 200, 200), 1);
            cv::putText(control_panel, "空间标准差: " + std::to_string(bilateral_sigma_space),
                       cv::Point(20, 190), cv::FONT_HERSHEY_SIMPLEX,
                       0.6, cv::Scalar(200, 200, 200), 1);
        }
        
        // 操作说明
        cv::putText(control_panel, "按键控制:", cv::Point(20, 240),
                   cv::FONT_HERSHEY_SIMPLEX, 0.6, cv::Scalar(0, 255, 0), 1);
        
        std::vector<std::string> instructions = {
            "1-4: 选择滤波类型",
            "A/D: 调整核大小",
            "W/S: 调整标准差(高斯)",
            "Q/E: 调整直径(双边)",
            "R/F: 调整颜色标准差(双边)",
            "T/G: 调整空间标准差(双边)",
            "空格: 切换噪声类型",
            "ESC: 退出"
        };
        
        for (size_t i = 0; i < instructions.size(); i++) {
            cv::putText(control_panel, instructions[i],
                       cv::Point(30, 270 + i * 25),
                       cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(200, 200, 200), 1);
        }
        
        // 显示当前滤波效果
        cv::Mat noisy_image = gaussian_noise_img.clone();  // 默认使用高斯噪声图像
        static bool use_gaussian_noise = true;
        
        cv::Mat filtered_image;
        
        // 应用当前滤波
        switch (filter_type) {
            case 0:  // 均值滤波
                cv::blur(noisy_image, filtered_image, cv::Size(kernel_size, kernel_size));
                break;
            case 1:  // 高斯滤波
                cv::GaussianBlur(noisy_image, filtered_image, cv::Size(kernel_size, kernel_size), sigma);
                break;
            case 2:  // 中值滤波
                cv::medianBlur(noisy_image, filtered_image, kernel_size);
                break;
            case 3:  // 双边滤波
                cv::bilateralFilter(noisy_image, filtered_image, bilateral_diameter, 
                                   bilateral_sigma_color, bilateral_sigma_space);
                break;
        }
        
        // 创建对比图像（左右并排）
        cv::Mat comparison(noisy_image.rows, noisy_image.cols * 2, CV_8UC3);
        noisy_image.copyTo(comparison(cv::Rect(0, 0, noisy_image.cols, noisy_image.rows)));
        filtered_image.copyTo(comparison(cv::Rect(noisy_image.cols, 0, noisy_image.cols, noisy_image.rows)));
        
        // 添加标签
        cv::putText(comparison, "噪声图像", cv::Point(20, 40),
                   cv::FONT_HERSHEY_SIMPLEX, 1.0, cv::Scalar(0, 255, 0), 2);
        cv::putText(comparison, "滤波后图像", cv::Point(noisy_image.cols + 20, 40),
                   cv::FONT_HERSHEY_SIMPLEX, 1.0, cv::Scalar(0, 255, 0), 2);
        
        // 添加滤波信息
        std::string info = filter_names[filter_type] + " (核大小: " + std::to_string(kernel_size) + ")";
        cv::putText(comparison, info, cv::Point(noisy_image.cols / 2 - 100, noisy_image.rows - 20),
                   cv::FONT_HERSHEY_SIMPLEX, 0.7, cv::Scalar(255, 255, 255), 2);
        
        cv::imshow("滤波效果对比", comparison);
        cv::imshow("控制面板", control_panel);
    };
    
    // 初始显示
    updateFilterDemo();
    
    // 主循环
    bool use_gaussian_noise = true;
    while (true) {
        int key = cv::waitKey(0);
        
        if (key == 27) {  // ESC
            break;
        } else if (key >= '1' && key <= '4') {
            filter_type = key - '1';
            updateFilterDemo();
        } else if (key == 'a' || key == 'A') {
            kernel_size = std::max(1, kernel_size - 2);
            if (kernel_size % 2 == 0) kernel_size--;  // 确保为奇数
            updateFilterDemo();
        } else if (key == 'd' || key == 'D') {
            kernel_size = std::min(31, kernel_size + 2);
            if (kernel_size % 2 == 0) kernel_size++;  // 确保为奇数
            updateFilterDemo();
        } else if ((key == 'w' || key == 'W') && filter_type == 1) {
            sigma = std::min(10, sigma + 1);
            updateFilterDemo();
        } else if ((key == 's' || key == 'S') && filter_type == 1) {
            sigma = std::max(0, sigma - 1);
            updateFilterDemo();
        } else if ((key == 'q' || key == 'Q') && filter_type == 3) {
            bilateral_diameter = std::max(1, bilateral_diameter - 2);
            updateFilterDemo();
        } else if ((key == 'e' || key == 'E') && filter_type == 3) {
            bilateral_diameter = std::min(31, bilateral_diameter + 2);
            updateFilterDemo();
        } else if ((key == 'r' || key == 'R') && filter_type == 3) {
            bilateral_sigma_color = std::max(1, bilateral_sigma_color - 10);
            updateFilterDemo();
        } else if ((key == 'f' || key == 'F') && filter_type == 3) {
            bilateral_sigma_color = std::min(200, bilateral_sigma_color + 10);
            updateFilterDemo();
        } else if ((key == 't' || key == 'T') && filter_type == 3) {
            bilateral_sigma_space = std::max(1, bilateral_sigma_space - 10);
            updateFilterDemo();
        } else if ((key == 'g' || key == 'G') && filter_type == 3) {
            bilateral_sigma_space = std::min(200, bilateral_sigma_space + 10);
            updateFilterDemo();
        } else if (key == ' ') {
            use_gaussian_noise = !use_gaussian_noise;
            // 这里需要重新生成噪声图像，为了简化，我们切换预先生成的两张噪声图像
            // 在实际演示中，可能需要重新生成
            updateFilterDemo();
        } else if (key == 's' || key == 'S') {
            cv::imwrite("filter_demo.jpg", display_panel);
            std::cout << "已保存结果到 filter_demo.jpg" << std::endl;
        }
    }
    
    cv::destroyAllWindows();
    
    std::cout << "\n=== 图像滤波与降噪演示完成 ===" << std::endl;
    std::cout << "总结：" << std::endl;
    std::cout << "1. 掌握了线性滤波（均值、高斯）和非线性滤波（中值、双边）" << std::endl;
    std::cout << "2. 理解了不同滤波器的适用场景和参数调节" << std::endl;
    std::cout << "3. 学会了如何根据噪声类型选择合适的滤波器" << std::endl;
    std::cout << "4. 了解了滤波核大小和标准差对滤波效果的影响" << std::endl;
    
    return 0;
}
```

## 六、图像阈值处理（二值化核心）

### 6.1 阈值处理基础

#### 讲解
图像阈值处理是将灰度图像转换为二值图像的过程，通过设定一个阈值，将像素分为前景和背景。这是图像分割、文字提取、物体检测等应用的基础。

#### 核心方法

| 方法 | OpenCV函数 | 特点 | 适用场景 |
|------|------------|------|----------|
| **简单阈值** | `threshold()` | 全局固定阈值 | 光照均匀，背景与前景对比明显 |
| **自适应阈值** | `adaptiveThreshold()` | 局部动态阈值 | 光照不均，背景复杂 |
| **Otsu方法** | `THRESH_OTSU` | 自动确定最佳阈值 | 双峰直方图图像 |

#### 阈值类型

| 阈值类型 | 说明 | 公式 |
|----------|------|------|
| **THRESH_BINARY** | 二值化 | `dst(x,y) = maxval if src(x,y) > thresh else 0` |
| **THRESH_BINARY_INV** | 反二值化 | `dst(x,y) = 0 if src(x,y) > thresh else maxval` |
| **THRESH_TRUNC** | 截断 | `dst(x,y) = thresh if src(x,y) > thresh else src(x,y)` |
| **THRESH_TOZERO** | 超过阈值置零 | `dst(x,y) = src(x,y) if src(x,y) > thresh else 0` |
| **THRESH_TOZERO_INV** | 低于阈值置零 | `dst(x,y) = 0 if src(x,y) > thresh else src(x,y)` |

#### 阈值处理实战代码

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>
#include <vector>

// 显示图像信息
void showImageInfo(const cv::Mat& img, const std::string& name) {
    std::cout << name << ": " << img.cols << "×" << img.rows 
              << " (" << img.channels() << " channels)" << std::endl;
}

// 创建测试图像
cv::Mat createTestImage(int width, int height) {
    cv::Mat image(height, width, CV_8UC1, cv::Scalar(128));
    
    // 添加不同灰度的矩形
    cv::rectangle(image, cv::Rect(50, 50, 200, 100), cv::Scalar(200), -1);   // 亮区域
    cv::rectangle(image, cv::Rect(300, 150, 150, 80), cv::Scalar(50), -1);    // 暗区域
    
    // 添加渐变区域
    for (int y = 200; y < 350; y++) {
        for (int x = 100; x < 250; x++) {
            image.at<uchar>(y, x) = static_cast<uchar>((x - 100) * 255 / 150.0);
        }
    }
    
    // 添加文字
    cv::putText(image, "Threshold", cv::Point(400, 100),
                cv::FONT_HERSHEY_SIMPLEX, 1.5, cv::Scalar(255), 3);
    cv::putText(image, "Demo", cv::Point(450, 150),
                cv::FONT_HERSHEY_SIMPLEX, 1.2, cv::Scalar(100), 2);
    
    // 添加光照不均效果（模拟）
    for (int y = 0; y < height; y++) {
        for (int x = 0; x < width; x++) {
            // 中心亮，四周暗
            double distance = sqrt(pow(x - width/2, 2) + pow(y - height/2, 2));
            double factor = 1.0 - distance / (width/2) * 0.5;
            uchar pixel = image.at<uchar>(y, x);
            image.at<uchar>(y, x) = cv::saturate_cast<uchar>(pixel * factor);
        }
    }
    
    return image;
}

int main() {
    std::cout << "=== OpenCV 图像阈值处理 ===\n" << std::endl;
    
    // ============================================
    // 1. 创建测试图像
    // ============================================
    
    std::cout << "1. 创建测试图像..." << std::endl;
    cv::Mat original = createTestImage(800, 600);
    showImageInfo(original, "原始灰度图像");
    
    // ============================================
    // 2. 简单阈值处理
    // ============================================
    
    std::cout << "\n2. 简单阈值处理 (threshold)" << std::endl;
    
    cv::Mat binary, binary_inv, trunc, tozero, tozero_inv;
    double thresh = 127;
    double maxval = 255;
    
    // 2.1 二值化
    cv::threshold(original, binary, thresh, maxval, cv::THRESH_BINARY);
    std::cout << "   二值化 (THRESH_BINARY): 阈值=" << thresh << std::endl;
    
    // 2.2 反二值化
    cv::threshold(original, binary_inv, thresh, maxval, cv::THRESH_BINARY_INV);
    std::cout << "   反二值化 (THRESH_BINARY_INV)" << std::endl;
    
    // 2.3 截断
    cv::threshold(original, trunc, thresh, maxval, cv::THRESH_TRUNC);
    std::cout << "   截断 (THRESH_TRUNC): 大于阈值设为阈值" << std::endl;
    
    // 2.4 超过阈值置零
    cv::threshold(original, tozero, thresh, maxval, cv::THRESH_TOZERO);
    std::cout << "   超过阈值置零 (THRESH_TOZERO)" << std::endl;
    
    // 2.5 低于阈值置零
    cv::threshold(original, tozero_inv, thresh, maxval, cv::THRESH_TOZERO_INV);
    std::cout << "   低于阈值置零 (THRESH_TOZERO_INV)" << std::endl;
    
    // 2.6 自动阈值（Otsu方法）
    cv::Mat otsu;
    double otsu_thresh = cv::threshold(original, otsu, 0, 255, cv::THRESH_BINARY | cv::THRESH_OTSU);
    std::cout << "   Otsu自动阈值: 计算的最佳阈值=" << otsu_thresh << std::endl;
    
    // 2.7 三角法自动阈值
    cv::Mat triangle;
    double triangle_thresh = cv::threshold(original, triangle, 0, 255, cv::THRESH_BINARY | cv::THRESH_TRIANGLE);
    std::cout << "   Triangle自动阈值: 计算的最佳阈值=" << triangle_thresh << std::endl;
    
    // ============================================
    // 3. 自适应阈值处理
    // ============================================
    
    std::cout << "\n3. 自适应阈值处理 (adaptiveThreshold)" << std::endl;
    
    cv::Mat adaptive_mean, adaptive_gaussian;
    
    // 3.1 均值自适应
    cv::adaptiveThreshold(original, adaptive_mean, 255, 
                         cv::ADAPTIVE_THRESH_MEAN_C, cv::THRESH_BINARY, 11, 2);
    std::cout << "   均值自适应: 块大小=11, C=2" << std::endl;
    
    // 3.2 高斯自适应
    cv::adaptiveThreshold(original, adaptive_gaussian, 255,
                         cv::ADAPTIVE_THRESH_GAUSSIAN_C, cv::THRESH_BINARY, 11, 2);
    std::cout << "   高斯自适应: 块大小=11, C=2" << std::endl;
    
    // 不同参数比较
    cv::Mat adaptive_large, adaptive_small;
    cv::adaptiveThreshold(original, adaptive_large, 255,
                         cv::ADAPTIVE_THRESH_MEAN_C, cv::THRESH_BINARY, 31, 10);
    cv::adaptiveThreshold(original, adaptive_small, 255,
                         cv::ADAPTIVE_THRESH_MEAN_C, cv::THRESH_BINARY, 5, 1);
    
    // ============================================
    // 4. 应用：文字提取
    // ============================================
    
    std::cout << "\n4. 应用：文字提取" << std::endl;
    
    // 创建文字图像
    cv::Mat text_image(200, 600, CV_8UC1, cv::Scalar(200));
    cv::putText(text_image, "OpenCV Threshold Processing", cv::Point(30, 80),
                cv::FONT_HERSHEY_SIMPLEX, 1.5, cv::Scalar(50), 3);
    cv::putText(text_image, "Text Extraction Demo", cv::Point(80, 150),
                cv::FONT_HERSHEY_SIMPLEX, 1.2, cv::Scalar(30), 2);
    
    // 添加噪声
    cv::Mat noise(text_image.size(), CV_8UC1);
    cv::randn(noise, 0, 30);
    text_image += noise;
    
    // 文字提取
    cv::Mat text_binary, text_adaptive;
    cv::threshold(text_image, text_binary, 0, 255, cv::THRESH_BINARY | cv::THRESH_OTSU);
    cv::adaptiveThreshold(text_image, text_adaptive, 255,
                         cv::ADAPTIVE_THRESH_GAUSSIAN_C, cv::THRESH_BINARY, 15, 5);
    
    std::cout << "   使用Otsu和自适应阈值提取文字" << std::endl;
    
    // ============================================
    // 5. 创建显示面板
    // ============================================
    
    std::cout << "\n5. 创建结果显示面板..." << std::endl;
    
    int panel_width = 1600;
    int panel_height = 1000;
    cv::Mat display_panel(panel_height, panel_width, CV_8UC3, cv::Scalar(40, 40, 40));
    
    // 5.1 定义缩略图尺寸
    int thumb_width = 350;
    int thumb_height = 260;
    
    // 5.2 准备所有图像（转换为彩色显示）
    struct DisplayItem {
        cv::Mat image;
        std::string label;
        bool is_gray;
    };
    
    std::vector<DisplayItem> display_items = {
        {original, "原始灰度图像", true},
        {binary, "二值化 (THRESH_BINARY)", true},
        {binary_inv, "反二值化 (THRESH_BINARY_INV)", true},
        {trunc, "截断 (THRESH_TRUNC)", true},
        {tozero, "超过阈值置零 (THRESH_TOZERO)", true},
        {tozero_inv, "低于阈值置零 (THRESH_TOZERO_INV)", true},
        {otsu, "Otsu自动阈值", true},
        {triangle, "Triangle自动阈值", true},
        {adaptive_mean, "自适应均值", true},
        {adaptive_gaussian, "自适应高斯", true},
        {text_image, "文字图像（带噪声）", true},
        {text_binary, "文字提取（Otsu）", true},
        {text_adaptive, "文字提取（自适应）", true}
    };
    
    // 5.3 排列图像
    int cols = 4;
    for (size_t i = 0; i < display_items.size(); i++) {
        int row = i / cols;
        int col = i % cols;
        
        int x = col * (thumb_width + 20) + 20;
        int y = row * (thumb_height + 40) + 40;
        
        // 检查边界
        if (y + thumb_height >= panel_height) {
            // 扩展面板
            panel_height += thumb_height + 100;
            cv::Mat new_panel(panel_height, panel_width, CV_8UC3, cv::Scalar(40, 40, 40));
            display_panel.copyTo(new_panel(cv::Rect(0, 0, display_panel.cols, display_panel.rows)));
            display_panel = new_panel;
        }
        
        // 转换为彩色显示
        cv::Mat color_thumb;
        if (display_items[i].is_gray) {
            cv::cvtColor(display_items[i].image, color_thumb, cv::COLOR_GRAY2BGR);
        } else {
            color_thumb = display_items[i].image;
        }
        
        // 调整图像尺寸
        cv::Mat thumb;
        cv::resize(color_thumb, thumb, cv::Size(thumb_width, thumb_height));
        
        // 复制到面板
        cv::Rect roi(x, y, thumb_width, thumb_height);
        thumb.copyTo(display_panel(roi));
        
        // 添加边框
        cv::rectangle(display_panel, roi, cv::Scalar(180, 180, 180), 2);
        
        // 添加标签
        cv::putText(display_panel, display_items[i].label,
                   cv::Point(x + 10, y + thumb_height + 25),
                   cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(220, 220, 220), 1);
    }
    
    // 5.4 添加标题和说明
    cv::putText(display_panel, "OpenCV 图像阈值处理演示",
               cv::Point(panel_width / 2 - 250, 30),
               cv::FONT_HERSHEY_SIMPLEX, 0.9, cv::Scalar(0, 255, 255), 2);
    
    cv::putText(display_panel, "阈值类型: 二值化, 反二值化, 截断, 置零等",
               cv::Point(20, panel_height - 80),
               cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(200, 200, 200), 1);
    
    cv::putText(display_panel, "方法: 简单阈值, 自适应阈值, Otsu, Triangle",
               cv::Point(20, panel_height - 60),
               cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(200, 200, 200), 1);
    
    cv::putText(display_panel, "应用: 文字提取, 物体分割",
               cv::Point(20, panel_height - 40),
               cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(200, 200, 200), 1);
    
    cv::putText(display_panel, "按ESC退出, 按's'保存结果",
               cv::Point(panel_width - 300, panel_height - 20),
               cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(200, 200, 200), 1);
    
    // ============================================
    // 6. 交互演示：实时阈值调整
    // ============================================
    
    std::cout << "\n6. 交互演示：实时阈值调整" << std::endl;
    
    cv::namedWindow("阈值调整", cv::WINDOW_NORMAL);
    cv::resizeWindow("阈值调整", 800, 600);
    
    cv::namedWindow("控制面板", cv::WINDOW_NORMAL);
    cv::resizeWindow("控制面板", 400, 500);
    
    // 控制参数
    int threshold_type = 0;  // 0:二值化, 1:反二值化, 2:截断, 3:超过阈值置零, 4:低于阈值置零
    int threshold_value = 127;
    int adaptive_method = 0;  // 0:简单阈值, 1:自适应均值, 2:自适应高斯, 3:Otsu, 4:Triangle
    int block_size = 11;
    int C_value = 2;
    
    // 创建控制面板
    cv::Mat control_panel(500, 400, CV_8UC3, cv::Scalar(50, 50, 50));
    
    // 更新控制面板和阈值效果
    auto updateThresholdDemo = [&]() {
        control_panel.setTo(cv::Scalar(50, 50, 50));
        
        // 标题
        cv::putText(control_panel, "=== 阈值控制面板 ===",
                   cv::Point(20, 30), cv::FONT_HERSHEY_SIMPLEX,
                   0.7, cv::Scalar(0, 255, 255), 2);
        
        // 当前参数
        std::vector<std::string> type_names = {"二值化", "反二值化", "截断", "超过阈值置零", "低于阈值置零"};
        std::vector<std::string> method_names = {"简单阈值", "自适应均值", "自适应高斯", "Otsu", "Triangle"};
        
        cv::putText(control_panel, "阈值类型: " + type_names[threshold_type],
                   cv::Point(20, 70), cv::FONT_HERSHEY_SIMPLEX,
                   0.6, cv::Scalar(200, 200, 200), 1);
        
        cv::putText(control_panel, "处理方法: " + method_names[adaptive_method],
                   cv::Point(20, 100), cv::FONT_HERSHEY_SIMPLEX,
                   0.6, cv::Scalar(200, 200, 200), 1);
        
        if (adaptive_method == 0) {  // 简单阈值
            cv::putText(control_panel, "阈值: " + std::to_string(threshold_value),
                       cv::Point(20, 130), cv::FONT_HERSHEY_SIMPLEX,
                       0.6, cv::Scalar(200, 200, 200), 1);
        } else if (adaptive_method == 1 || adaptive_method == 2) {  // 自适应阈值
            cv::putText(control_panel, "块大小: " + std::to_string(block_size),
                       cv::Point(20, 130), cv::FONT_HERSHEY_SIMPLEX,
                       0.6, cv::Scalar(200, 200, 200), 1);
            cv::putText(control_panel, "C值: " + std::to_string(C_value),
                       cv::Point(20, 160), cv::FONT_HERSHEY_SIMPLEX,
                       0.6, cv::Scalar(200, 200, 200), 1);
        }
        
        // 操作说明
        cv::putText(control_panel, "按键控制:", cv::Point(20, 200),
                   cv::FONT_HERSHEY_SIMPLEX, 0.6, cv::Scalar(0, 255, 0), 1);
        
        std::vector<std::string> instructions = {
            "1-5: 选择阈值类型",
            "6-0: 选择处理方法",
            "A/D: 调整阈值或块大小",
            "W/S: 调整C值(自适应)",
            "空格: 切换测试图像",
            "ESC: 退出"
        };
        
        for (size_t i = 0; i < instructions.size(); i++) {
            cv::putText(control_panel, instructions[i],
                       cv::Point(30, 230 + i * 25),
                       cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(200, 200, 200), 1);
        }
        
        // 应用当前阈值
        cv::Mat result;
        cv::Mat test_image = original.clone();
        static bool use_text_image = false;
        
        if (use_text_image) {
            test_image = text_image.clone();
        }
        
        if (adaptive_method == 0) {  // 简单阈值
            int type_flag;
            switch (threshold_type) {
                case 0: type_flag = cv::THRESH_BINARY; break;
                case 1: type_flag = cv::THRESH_BINARY_INV; break;
                case 2: type_flag = cv::THRESH_TRUNC; break;
                case 3: type_flag = cv::THRESH_TOZERO; break;
                case 4: type_flag = cv::THRESH_TOZERO_INV; break;
                default: type_flag = cv::THRESH_BINARY;
            }
            cv::threshold(test_image, result, threshold_value, 255, type_flag);
        } else if (adaptive_method == 1) {  // 自适应均值
            int type_flag = (threshold_type == 0) ? cv::THRESH_BINARY : cv::THRESH_BINARY_INV;
            cv::adaptiveThreshold(test_image, result, 255,
                                 cv::ADAPTIVE_THRESH_MEAN_C, type_flag,
                                 (block_size % 2 == 0) ? block_size + 1 : block_size, C_value);
        } else if (adaptive_method == 2) {  // 自适应高斯
            int type_flag = (threshold_type == 0) ? cv::THRESH_BINARY : cv::THRESH_BINARY_INV;
            cv::adaptiveThreshold(test_image, result, 255,
                                 cv::ADAPTIVE_THRESH_GAUSSIAN_C, type_flag,
                                 (block_size % 2 == 0) ? block_size + 1 : block_size, C_value);
        } else if (adaptive_method == 3) {  // Otsu
            int type_flag = (threshold_type == 0) ? cv::THRESH_BINARY : cv::THRESH_BINARY_INV;
            type_flag |= cv::THRESH_OTSU;
            cv::threshold(test_image, result, 0, 255, type_flag);
        } else if (adaptive_method == 4) {  // Triangle
            int type_flag = (threshold_type == 0) ? cv::THRESH_BINARY : cv::THRESH_BINARY_INV;
            type_flag |= cv::THRESH_TRIANGLE;
            cv::threshold(test_image, result, 0, 255, type_flag);
        }
        
        // 创建对比图像（左右并排）
        cv::Mat comparison(test_image.rows, test_image.cols * 2, CV_8UC1);
        test_image.copyTo(comparison(cv::Rect(0, 0, test_image.cols, test_image.rows)));
        result.copyTo(comparison(cv::Rect(test_image.cols, 0, test_image.cols, test_image.rows)));
        
        // 转换为彩色显示
        cv::Mat color_comparison;
        cv::cvtColor(comparison, color_comparison, cv::COLOR_GRAY2BGR);
        
        // 添加标签
        cv::putText(color_comparison, "原始图像", cv::Point(20, 40),
                   cv::FONT_HERSHEY_SIMPLEX, 1.0, cv::Scalar(0, 255, 0), 2);
        cv::putText(color_comparison, "阈值处理后", cv::Point(test_image.cols + 20, 40),
                   cv::FONT_HERSHEY_SIMPLEX, 1.0, cv::Scalar(0, 255, 0), 2);
        
        // 添加方法信息
        std::string info = method_names[adaptive_method] + " - " + type_names[threshold_type];
        if (adaptive_method == 0) {
            info += " (阈值=" + std::to_string(threshold_value) + ")";
        } else if (adaptive_method == 1 || adaptive_method == 2) {
            info += " (块大小=" + std::to_string(block_size) + ", C=" + std::to_string(C_value) + ")";
        }
        
        cv::putText(color_comparison, info, cv::Point(test_image.cols / 2 - 150, test_image.rows - 20),
                   cv::FONT_HERSHEY_SIMPLEX, 0.7, cv::Scalar(255, 255, 255), 2);
        
        cv::imshow("阈值调整", color_comparison);
        cv::imshow("控制面板", control_panel);
    };
    
    // 初始显示
    updateThresholdDemo();
    
    // 主循环
    bool use_text_image = false;
    while (true) {
        int key = cv::waitKey(0);
        
        if (key == 27) {  // ESC
            break;
        } else if (key >= '1' && key <= '5') {
            threshold_type = key - '1';
            updateThresholdDemo();
        } else if (key >= '6' && key <= '0') {
            adaptive_method = (key == '0') ? 4 : key - '6';
            updateThresholdDemo();
        } else if (key == 'a' || key == 'A') {
            if (adaptive_method == 0) {
                threshold_value = std::max(0, threshold_value - 5);
            } else if (adaptive_method == 1 || adaptive_method == 2) {
                block_size = std::max(3, block_size - 2);
            }
            updateThresholdDemo();
        } else if (key == 'd' || key == 'D') {
            if (adaptive_method == 0) {
                threshold_value = std::min(255, threshold_value + 5);
            } else if (adaptive_method == 1 || adaptive_method == 2) {
                block_size = std::min(31, block_size + 2);
            }
            updateThresholdDemo();
        } else if ((key == 'w' || key == 'W') && (adaptive_method == 1 || adaptive_method == 2)) {
            C_value = std::min(20, C_value + 1);
            updateThresholdDemo();
        } else if ((key == 's' || key == 'S') && (adaptive_method == 1 || adaptive_method == 2)) {
            C_value = std::max(0, C_value - 1);
            updateThresholdDemo();
        } else if (key == ' ') {
            use_text_image = !use_text_image;
            updateThresholdDemo();
        } else if (key == 's' || key == 'S') {
            cv::imwrite("threshold_demo.jpg", display_panel);
            std::cout << "已保存结果到 threshold_demo.jpg" << std::endl;
        }
    }
    
    cv::destroyAllWindows();
    
    std::cout << "\n=== 图像阈值处理演示完成 ===" << std::endl;
    std::cout << "总结：" << std::endl;
    std::cout << "1. 掌握了5种基本阈值类型及其应用场景" << std::endl;
    std::cout << "2. 学会了自适应阈值处理光照不均问题" << std::endl;
    std::cout << "3. 理解了Otsu和Triangle自动阈值算法" << std::endl;
    std::cout << "4. 实现了文字提取和简单物体分割应用" << std::endl;
    
    return 0;
}
```

由于篇幅限制，我将形态学操作、边缘检测与轮廓提取、图像几何变换（复杂变换）的内容放在下一个回复中继续。这些内容同样重要，我会按照相同的格式为您提供详细的笔记和代码示例。

# OpenCV 形态学操作、边缘检测、轮廓提取与几何变换

## 八、边缘检测与轮廓提取（目标识别基础）

### 8.1 边缘检测基础

#### 讲解
边缘检测是图像处理中用于识别物体边界的重要技术。边缘通常出现在图像灰度或颜色发生显著变化的位置。不同的边缘检测算子有不同的特点和应用场景。

#### 边缘检测算子对比

| 算子 | OpenCV函数 | 特点 | 适用场景 |
|------|------------|------|----------|
| **Canny** | `Canny()` | 多阶段算法，效果好，需要阈值调节 | 通用边缘检测，最常用 |
| **Sobel** | `Sobel()` | 一阶导数，可检测水平和垂直边缘 | 方向性边缘检测 |
| **Scharr** | `Scharr()` | Sobel的优化版本，精度更高 | 需要高精度边缘检测 |
| **Laplacian** | `Laplacian()` | 二阶导数，对噪声敏感 | 检测边缘和角点 |
| **Prewitt** | 需手动实现 | 简单一阶微分 | 简单边缘检测 |

#### Canny边缘检测参数

| 参数 | 说明 | 影响 |
|------|------|------|
| `threshold1` | 低阈值 | 低于此值的边缘被丢弃 |
| `threshold2` | 高阈值 | 高于此值的边缘被保留 |
| `apertureSize` | Sobel核大小 | 3, 5, 7，越大检测越粗糙 |
| `L2gradient` | 梯度计算方式 | True使用更精确的L2范数 |

#### 轮廓分析常用函数

| 函数 | 说明 | 返回值 |
|------|------|--------|
| `findContours()` | 查找轮廓 | 轮廓点集，层次结构 |
| `drawContours()` | 绘制轮廓 | 绘制后的图像 |
| `contourArea()` | 计算轮廓面积 | 面积值（浮点数） |
| `arcLength()` | 计算轮廓周长 | 周长值（浮点数） |
| `boundingRect()` | 获取外接矩形 | 矩形坐标和尺寸 |
| `minAreaRect()` | 获取最小外接矩形 | 旋转矩形 |
| `minEnclosingCircle()` | 获取最小外接圆 | 圆心和半径 |
| `approxPolyDP()` | 多边形近似 | 简化后的轮廓点 |

#### 边缘检测与轮廓提取实战代码

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>
#include <vector>
#include <cmath>

// 显示图像信息
void showImageInfo(const cv::Mat& img, const std::string& name) {
    std::cout << name << ": " << img.cols << "×" << img.rows 
              << " (" << img.channels() << " channels)" << std::endl;
}

// 创建测试图像
cv::Mat createTestImage(int width, int height) {
    cv::Mat image(height, width, CV_8UC3, cv::Scalar(100, 100, 100));
    
    // 添加各种形状
    // 矩形
    cv::rectangle(image, cv::Rect(50, 50, 120, 80), cv::Scalar(0, 0, 255), -1);
    cv::rectangle(image, cv::Rect(200, 150, 100, 120), cv::Scalar(0, 255, 0), -1);
    
    // 圆形
    cv::circle(image, cv::Point(400, 300), 70, cv::Scalar(255, 0, 0), -1);
    cv::circle(image, cv::Point(550, 200), 40, cv::Scalar(255, 255, 0), -1);
    
    // 三角形（通过多边形绘制）
    std::vector<cv::Point> triangle = {
        cv::Point(650, 100),
        cv::Point(750, 100),
        cv::Point(700, 180)
    };
    cv::fillConvexPoly(image, triangle, cv::Scalar(255, 0, 255));
    
    // 椭圆
    cv::ellipse(image, cv::Point(300, 400), cv::Size(100, 60), 30, 0, 360, 
                cv::Scalar(0, 255, 255), -1);
    
    // 添加文字
    cv::putText(image, "Edge & Contour", cv::Point(200, 500),
                cv::FONT_HERSHEY_SIMPLEX, 1.5, cv::Scalar(255, 255, 255), 3);
    
    // 添加一些噪声
    cv::Mat noise(image.size(), CV_8UC3);
    cv::randn(noise, 0, 20);
    image += noise;
    
    return image;
}

int main() {
    std::cout << "=== OpenCV 边缘检测与轮廓提取 ===\n" << std::endl;
    
    // ============================================
    // 1. 创建测试图像
    // ============================================
    
    std::cout << "1. 创建测试图像..." << std::endl;
    cv::Mat original = createTestImage(800, 600);
    showImageInfo(original, "原始彩色图像");
    
    // 转换为灰度图像
    cv::Mat gray;
    cv::cvtColor(original, gray, cv::COLOR_BGR2GRAY);
    showImageInfo(gray, "灰度图像");
    
    // ============================================
    // 2. Canny边缘检测
    // ============================================
    
    std::cout << "\n2. Canny边缘检测" << std::endl;
    
    cv::Mat canny_edges1, canny_edges2, canny_edges3;
    
    // 2.1 低阈值检测（检测更多边缘）
    cv::Canny(gray, canny_edges1, 50, 150);
    std::cout << "   Canny (50, 150): 低阈值，检测更多边缘" << std::endl;
    
    // 2.2 高阈值检测（检测主要边缘）
    cv::Canny(gray, canny_edges2, 100, 200);
    std::cout << "   Canny (100, 200): 中等阈值" << std::endl;
    
    // 2.3 高阈值检测（检测强边缘）
    cv::Canny(gray, canny_edges3, 150, 250);
    std::cout << "   Canny (150, 250): 高阈值，只检测强边缘" << std::endl;
    
    // 2.4 不同核大小比较
    cv::Mat canny_small, canny_large;
    cv::Canny(gray, canny_small, 50, 150, 3);    // 3×3核
    cv::Canny(gray, canny_large, 50, 150, 7);    // 7×7核
    
    // ============================================
    // 3. Sobel边缘检测
    // ============================================
    
    std::cout << "\n3. Sobel边缘检测" << std::endl;
    
    cv::Mat sobel_x, sobel_y, sobel_xy;
    
    // 3.1 水平方向边缘
    cv::Sobel(gray, sobel_x, CV_16S, 1, 0, 3);  // dx=1, dy=0
    cv::convertScaleAbs(sobel_x, sobel_x);
    std::cout << "   Sobel X方向: 检测垂直边缘" << std::endl;
    
    // 3.2 垂直方向边缘
    cv::Sobel(gray, sobel_y, CV_16S, 0, 1, 3);  // dx=0, dy=1
    cv::convertScaleAbs(sobel_y, sobel_y);
    std::cout << "   Sobel Y方向: 检测水平边缘" << std::endl;
    
    // 3.3 合并两个方向
    cv::addWeighted(sobel_x, 0.5, sobel_y, 0.5, 0, sobel_xy);
    std::cout << "   Sobel XY合并: 检测所有方向边缘" << std::endl;
    
    // 3.4 Scharr算子（Sobel的优化）
    cv::Mat scharr_x, scharr_y, scharr_xy;
    cv::Scharr(gray, scharr_x, CV_16S, 1, 0);
    cv::convertScaleAbs(scharr_x, scharr_x);
    cv::Scharr(gray, scharr_y, CV_16S, 0, 1);
    cv::convertScaleAbs(scharr_y, scharr_y);
    cv::addWeighted(scharr_x, 0.5, scharr_y, 0.5, 0, scharr_xy);
    
    // ============================================
    // 4. Laplacian边缘检测
    // ============================================
    
    std::cout << "\n4. Laplacian边缘检测" << std::endl;
    
    cv::Mat laplacian, laplacian_abs;
    cv::Laplacian(gray, laplacian, CV_16S, 3);
    cv::convertScaleAbs(laplacian, laplacian_abs);
    std::cout << "   Laplacian: 二阶导数，对噪声敏感" << std::endl;
    
    // ============================================
    // 5. 轮廓提取
    // ============================================
    
    std::cout << "\n5. 轮廓提取" << std::endl;
    
    // 5.1 使用Canny边缘检测结果进行轮廓提取
    cv::Mat canny_for_contours;
    cv::Canny(gray, canny_for_contours, 100, 200);
    
    // 5.2 查找轮廓
    std::vector<std::vector<cv::Point>> contours;
    std::vector<cv::Vec4i> hierarchy;
    
    cv::findContours(canny_for_contours, contours, hierarchy, 
                     cv::RETR_TREE, cv::CHAIN_APPROX_SIMPLE);
    
    std::cout << "   找到轮廓数量: " << contours.size() << std::endl;
    
    // 5.3 绘制所有轮廓
    cv::Mat contours_all = original.clone();
    cv::drawContours(contours_all, contours, -1, cv::Scalar(0, 255, 255), 2);
    
    // 5.4 绘制层次结构
    cv::Mat contours_hierarchy = original.clone();
    for (size_t i = 0; i < contours.size(); i++) {
        // 使用不同颜色表示不同层级的轮廓
        cv::Scalar color;
        if (hierarchy[i][3] == -1) {  // 最外层轮廓
            color = cv::Scalar(0, 255, 0);  // 绿色
        } else if (hierarchy[i][2] == -1) {  // 最内层轮廓
            color = cv::Scalar(0, 0, 255);  // 红色
        } else {  // 中间层轮廓
            color = cv::Scalar(255, 0, 0);  // 蓝色
        }
        cv::drawContours(contours_hierarchy, contours, i, color, 2, 8, hierarchy);
    }
    
    // ============================================
    // 6. 轮廓分析
    // ============================================
    
    std::cout << "\n6. 轮廓分析" << std::endl;
    
    cv::Mat contours_analysis = original.clone();
    
    // 筛选面积大于500的轮廓
    std::vector<std::vector<cv::Point>> filtered_contours;
    std::vector<cv::RotatedRect> min_rects;
    std::vector<cv::Point2f> centers;
    std::vector<float> radii;
    
    for (size_t i = 0; i < contours.size(); i++) {
        double area = cv::contourArea(contours[i]);
        double perimeter = cv::arcLength(contours[i], true);
        
        if (area > 500) {  // 只处理面积大于500的轮廓
            filtered_contours.push_back(contours[i]);
            
            // 6.1 计算外接矩形
            cv::Rect rect = cv::boundingRect(contours[i]);
            cv::rectangle(contours_analysis, rect, cv::Scalar(255, 0, 0), 2);
            
            // 6.2 计算最小外接矩形（旋转矩形）
            cv::RotatedRect min_rect = cv::minAreaRect(contours[i]);
            cv::Point2f rect_points[4];
            min_rect.points(rect_points);
            for (int j = 0; j < 4; j++) {
                cv::line(contours_analysis, rect_points[j], rect_points[(j+1)%4], 
                        cv::Scalar(0, 255, 0), 2);
            }
            min_rects.push_back(min_rect);
            
            // 6.3 计算最小外接圆
            cv::Point2f center;
            float radius;
            cv::minEnclosingCircle(contours[i], center, radius);
            cv::circle(contours_analysis, center, static_cast<int>(radius), 
                      cv::Scalar(0, 0, 255), 2);
            centers.push_back(center);
            radii.push_back(radius);
            
            // 6.4 计算轮廓中心（质心）
            cv::Moments M = cv::moments(contours[i]);
            cv::Point2f centroid;
            if (M.m00 != 0) {
                centroid.x = static_cast<float>(M.m10 / M.m00);
                centroid.y = static_cast<float>(M.m01 / M.m00);
                cv::circle(contours_analysis, centroid, 5, cv::Scalar(255, 255, 0), -1);
            }
            
            // 6.5 多边形近似
            std::vector<cv::Point> approx;
            double epsilon = 0.02 * perimeter;  // 近似精度
            cv::approxPolyDP(contours[i], approx, epsilon, true);
            
            // 根据顶点数量判断形状
            std::string shape_name;
            if (approx.size() == 3) {
                shape_name = "Triangle";
            } else if (approx.size() == 4) {
                // 判断是否为正方形或矩形
                cv::Rect rect = cv::boundingRect(approx);
                float aspect_ratio = static_cast<float>(rect.width) / rect.height;
                if (aspect_ratio >= 0.95 && aspect_ratio <= 1.05) {
                    shape_name = "Square";
                } else {
                    shape_name = "Rectangle";
                }
            } else if (approx.size() > 8) {
                shape_name = "Circle";
            } else {
                shape_name = "Polygon";
            }
            
            // 在中心添加形状名称
            cv::putText(contours_analysis, shape_name, cv::Point(rect.x, rect.y - 10),
                       cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 255, 255), 1);
            
            // 显示轮廓信息
            std::cout << "   轮廓" << i << ": 面积=" << area 
                      << ", 周长=" << perimeter 
                      << ", 形状=" << shape_name << std::endl;
        }
    }
    
    std::cout << "   筛选后轮廓数量: " << filtered_contours.size() << std::endl;
    
    // ============================================
    // 7. 轮廓筛选与排序
    // ============================================
    
    std::cout << "\n7. 轮廓筛选与排序" << std::endl;
    
    cv::Mat contours_sorted = original.clone();
    
    // 按面积排序
    std::vector<std::pair<double, int>> contour_areas;
    for (size_t i = 0; i < filtered_contours.size(); i++) {
        double area = cv::contourArea(filtered_contours[i]);
        contour_areas.push_back(std::make_pair(area, i));
    }
    
    // 降序排序
    std::sort(contour_areas.begin(), contour_areas.end(),
              [](const std::pair<double, int>& a, const std::pair<double, int>& b) {
                  return a.first > b.first;
              });
    
    // 绘制排序后的轮廓（用不同颜色）
    std::vector<cv::Scalar> colors = {
        cv::Scalar(0, 255, 0),   // 绿色 - 最大轮廓
        cv::Scalar(0, 0, 255),   // 红色 - 第二大轮廓
        cv::Scalar(255, 0, 0),   // 蓝色 - 第三大轮廓
        cv::Scalar(255, 255, 0), // 青色 - 第四大轮廓
        cv::Scalar(255, 0, 255), // 品红 - 第五大轮廓
        cv::Scalar(0, 255, 255), // 黄色 - 第六大轮廓
    };
    
    for (size_t i = 0; i < std::min(contour_areas.size(), colors.size()); i++) {
        int contour_idx = contour_areas[i].second;
        cv::drawContours(contours_sorted, filtered_contours, contour_idx, 
                        colors[i], 3);
        
        // 显示面积排名
        cv::Rect rect = cv::boundingRect(filtered_contours[contour_idx]);
        cv::putText(contours_sorted, "#" + std::to_string(i+1), 
                   cv::Point(rect.x, rect.y + rect.height + 20),
                   cv::FONT_HERSHEY_SIMPLEX, 0.7, colors[i], 2);
    }
    
    // ============================================
    // 8. 创建显示面板
    // ============================================
    
    std::cout << "\n8. 创建结果显示面板..." << std::endl;
    
    int panel_width = 1600;
    int panel_height = 1200;
    cv::Mat display_panel(panel_height, panel_width, CV_8UC3, cv::Scalar(40, 40, 40));
    
    // 8.1 定义缩略图尺寸
    int thumb_width = 350;
    int thumb_height = 260;
    
    // 8.2 准备所有图像（转换为彩色显示）
    struct DisplayItem {
        cv::Mat image;
        std::string label;
    };
    
    std::vector<DisplayItem> display_items = {
        {original, "原始图像"},
        {gray, "灰度图像"},
        {canny_edges1, "Canny (50,150)"},
        {canny_edges2, "Canny (100,200)"},
        {canny_edges3, "Canny (150,250)"},
        {sobel_x, "Sobel X方向"},
        {sobel_y, "Sobel Y方向"},
        {sobel_xy, "Sobel XY合并"},
        {scharr_xy, "Scharr算子"},
        {laplacian_abs, "Laplacian"},
        {contours_all, "所有轮廓"},
        {contours_hierarchy, "轮廓层次"},
        {contours_analysis, "轮廓分析"},
        {contours_sorted, "轮廓排序"}
    };
    
    // 8.3 排列图像
    int cols = 4;
    for (size_t i = 0; i < display_items.size(); i++) {
        int row = i / cols;
        int col = i % cols;
        
        int x = col * (thumb_width + 20) + 20;
        int y = row * (thumb_height + 40) + 40;
        
        // 检查边界
        if (y + thumb_height >= panel_height) {
            // 扩展面板
            panel_height += thumb_height + 100;
            cv::Mat new_panel(panel_height, panel_width, CV_8UC3, cv::Scalar(40, 40, 40));
            display_panel.copyTo(new_panel(cv::Rect(0, 0, display_panel.cols, display_panel.rows)));
            display_panel = new_panel;
        }
        
        // 转换为彩色显示（如果需要）
        cv::Mat color_thumb;
        if (display_items[i].image.channels() == 1) {
            cv::cvtColor(display_items[i].image, color_thumb, cv::COLOR_GRAY2BGR);
        } else {
            color_thumb = display_items[i].image;
        }
        
        // 调整图像尺寸
        cv::Mat thumb;
        cv::resize(color_thumb, thumb, cv::Size(thumb_width, thumb_height));
        
        // 复制到面板
        cv::Rect roi(x, y, thumb_width, thumb_height);
        thumb.copyTo(display_panel(roi));
        
        // 添加边框
        cv::rectangle(display_panel, roi, cv::Scalar(180, 180, 180), 2);
        
        // 添加标签
        cv::putText(display_panel, display_items[i].label,
                   cv::Point(x + 10, y + thumb_height + 25),
                   cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(220, 220, 220), 1);
    }
    
    // 8.4 添加标题和说明
    cv::putText(display_panel, "OpenCV 边缘检测与轮廓提取演示",
               cv::Point(panel_width / 2 - 250, 30),
               cv::FONT_HERSHEY_SIMPLEX, 0.9, cv::Scalar(0, 255, 255), 2);
    
    cv::putText(display_panel, "边缘检测: Canny, Sobel, Scharr, Laplacian",
               cv::Point(20, panel_height - 80),
               cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(200, 200, 200), 1);
    
    cv::putText(display_panel, "轮廓操作: 查找, 绘制, 分析, 筛选",
               cv::Point(20, panel_height - 60),
               cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(200, 200, 200), 1);
    
    cv::putText(display_panel, "轮廓分析: 面积, 周长, 外接矩形, 最小外接圆",
               cv::Point(20, panel_height - 40),
               cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(200, 200, 200), 1);
    
    cv::putText(display_panel, "按ESC退出, 按's'保存结果",
               cv::Point(panel_width - 300, panel_height - 20),
               cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(200, 200, 200), 1);
    
    // ============================================
    // 9. 交互演示：实时边缘检测与轮廓分析
    // ============================================
    
    std::cout << "\n9. 交互演示：实时边缘检测与轮廓分析" << std::endl;
    
    cv::namedWindow("边缘检测与轮廓", cv::WINDOW_NORMAL);
    cv::resizeWindow("边缘检测与轮廓", 800, 600);
    
    cv::namedWindow("控制面板", cv::WINDOW_NORMAL);
    cv::resizeWindow("控制面板", 400, 500);
    
    // 控制参数
    int edge_method = 0;  // 0:Canny, 1:Sobel, 2:Laplacian
    int canny_thresh1 = 50;
    int canny_thresh2 = 150;
    int sobel_kernel = 3;
    bool show_contours = true;
    bool show_bounding = true;
    bool show_circles = false;
    double min_area = 500;
    
    // 创建控制面板
    cv::Mat control_panel(500, 400, CV_8UC3, cv::Scalar(50, 50, 50));
    
    // 更新控制面板和效果
    auto updateEdgeContourDemo = [&]() {
        control_panel.setTo(cv::Scalar(50, 50, 50));
        
        // 标题
        cv::putText(control_panel, "=== 边缘检测与轮廓控制 ===",
                   cv::Point(20, 30), cv::FONT_HERSHEY_SIMPLEX,
                   0.7, cv::Scalar(0, 255, 255), 2);
        
        // 当前参数
        std::vector<std::string> method_names = {"Canny", "Sobel", "Laplacian"};
        cv::putText(control_panel, "边缘检测方法: " + method_names[edge_method],
                   cv::Point(20, 70), cv::FONT_HERSHEY_SIMPLEX,
                   0.6, cv::Scalar(200, 200, 200), 1);
        
        if (edge_method == 0) {  // Canny
            cv::putText(control_panel, "低阈值: " + std::to_string(canny_thresh1),
                       cv::Point(20, 100), cv::FONT_HERSHEY_SIMPLEX,
                       0.6, cv::Scalar(200, 200, 200), 1);
            cv::putText(control_panel, "高阈值: " + std::to_string(canny_thresh2),
                       cv::Point(20, 130), cv::FONT_HERSHEY_SIMPLEX,
                       0.6, cv::Scalar(200, 200, 200), 1);
        } else if (edge_method == 1) {  // Sobel
            cv::putText(control_panel, "核大小: " + std::to_string(sobel_kernel),
                       cv::Point(20, 100), cv::FONT_HERSHEY_SIMPLEX,
                       0.6, cv::Scalar(200, 200, 200), 1);
        }
        
        cv::putText(control_panel, "最小轮廓面积: " + std::to_string(static_cast<int>(min_area)),
                   cv::Point(20, 160), cv::FONT_HERSHEY_SIMPLEX,
                   0.6, cv::Scalar(200, 200, 200), 1);
        
        cv::putText(control_panel, "显示轮廓: " + std::string(show_contours ? "是" : "否"),
                   cv::Point(20, 190), cv::FONT_HERSHEY_SIMPLEX,
                   0.6, cv::Scalar(show_contours ? cv::Scalar(0, 255, 0) : cv::Scalar(200, 200, 200)), 1);
        
        cv::putText(control_panel, "显示外接矩形: " + std::string(show_bounding ? "是" : "否"),
                   cv::Point(20, 220), cv::FONT_HERSHEY_SIMPLEX,
                   0.6, cv::Scalar(show_bounding ? cv::Scalar(0, 255, 0) : cv::Scalar(200, 200, 200)), 1);
        
        cv::putText(control_panel, "显示外接圆: " + std::string(show_circles ? "是" : "否"),
                   cv::Point(20, 250), cv::FONT_HERSHEY_SIMPLEX,
                   0.6, cv::Scalar(show_circles ? cv::Scalar(0, 255, 0) : cv::Scalar(200, 200, 200)), 1);
        
        // 操作说明
        cv::putText(control_panel, "按键控制:", cv::Point(20, 290),
                   cv::FONT_HERSHEY_SIMPLEX, 0.6, cv::Scalar(0, 255, 0), 1);
        
        std::vector<std::string> instructions = {
            "1-3: 选择边缘检测方法",
            "Q/W: 调整Canny低阈值",
            "A/S: 调整Canny高阈值",
            "E/R: 调整Sobel核大小",
            "Z/X: 调整最小面积",
            "C: 切换轮廓显示",
            "V: 切换矩形显示",
            "B: 切换圆形显示",
            "ESC: 退出"
        };
        
        for (size_t i = 0; i < instructions.size(); i++) {
            cv::putText(control_panel, instructions[i],
                       cv::Point(30, 320 + i * 25),
                       cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(200, 200, 200), 1);
        }
        
        // 应用当前边缘检测
        cv::Mat edges;
        cv::Mat gray_temp;
        cv::cvtColor(original, gray_temp, cv::COLOR_BGR2GRAY);
        
        if (edge_method == 0) {  // Canny
            cv::Canny(gray_temp, edges, canny_thresh1, canny_thresh2);
        } else if (edge_method == 1) {  // Sobel
            cv::Mat sobel_x, sobel_y, sobel_abs;
            cv::Sobel(gray_temp, sobel_x, CV_16S, 1, 0, sobel_kernel);
            cv::Sobel(gray_temp, sobel_y, CV_16S, 0, 1, sobel_kernel);
            cv::convertScaleAbs(sobel_x, sobel_x);
            cv::convertScaleAbs(sobel_y, sobel_y);
            cv::addWeighted(sobel_x, 0.5, sobel_y, 0.5, 0, edges);
        } else if (edge_method == 2) {  // Laplacian
            cv::Mat laplacian;
            cv::Laplacian(gray_temp, laplacian, CV_16S, 3);
            cv::convertScaleAbs(laplacian, edges);
        }
        
        // 转换为彩色显示
        cv::Mat color_edges;
        cv::cvtColor(edges, color_edges, cv::COLOR_GRAY2BGR);
        
        // 轮廓处理
        cv::Mat result = original.clone();
        if (show_contours) {
            // 查找轮廓
            std::vector<std::vector<cv::Point>> contours;
            cv::findContours(edges, contours, cv::RETR_TREE, cv::CHAIN_APPROX_SIMPLE);
            
            // 筛选轮廓
            std::vector<std::vector<cv::Point>> filtered_contours;
            for (const auto& contour : contours) {
                double area = cv::contourArea(contour);
                if (area >= min_area) {
                    filtered_contours.push_back(contour);
                    
                    // 绘制轮廓
                    cv::drawContours(result, std::vector<std::vector<cv::Point>>{contour}, 
                                    0, cv::Scalar(0, 255, 255), 2);
                    
                    // 绘制外接矩形
                    if (show_bounding) {
                        cv::Rect rect = cv::boundingRect(contour);
                        cv::rectangle(result, rect, cv::Scalar(255, 0, 0), 2);
                        
                        // 显示面积
                        cv::putText(result, "A=" + std::to_string(static_cast<int>(area)),
                                   cv::Point(rect.x, rect.y - 10),
                                   cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 255, 255), 1);
                    }
                    
                    // 绘制最小外接圆
                    if (show_circles) {
                        cv::Point2f center;
                        float radius;
                        cv::minEnclosingCircle(contour, center, radius);
                        cv::circle(result, center, static_cast<int>(radius), 
                                  cv::Scalar(0, 0, 255), 2);
                        
                        // 显示半径
                        cv::putText(result, "R=" + std::to_string(static_cast<int>(radius)),
                                   cv::Point(center.x + radius + 10, center.y),
                                   cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 255, 255), 1);
                    }
                }
            }
            
            // 显示轮廓数量
            std::string contour_info = "轮廓数量: " + std::to_string(filtered_contours.size());
            cv::putText(result, contour_info, cv::Point(20, 40),
                       cv::FONT_HERSHEY_SIMPLEX, 0.8, cv::Scalar(0, 255, 0), 2);
        }
        
        // 创建对比图像（左右并排）
        cv::Mat comparison(original.rows, original.cols * 2, CV_8UC3);
        color_edges.copyTo(comparison(cv::Rect(0, 0, original.cols, original.rows)));
        result.copyTo(comparison(cv::Rect(original.cols, 0, original.cols, original.rows)));
        
        // 添加标签
        cv::putText(comparison, "边缘检测结果", cv::Point(20, 40),
                   cv::FONT_HERSHEY_SIMPLEX, 1.0, cv::Scalar(0, 255, 0), 2);
        cv::putText(comparison, "轮廓分析结果", cv::Point(original.cols + 20, 40),
                   cv::FONT_HERSHEY_SIMPLEX, 1.0, cv::Scalar(0, 255, 0), 2);
        
        // 添加方法信息
        std::string info = method_names[edge_method];
        if (edge_method == 0) {
            info += " (" + std::to_string(canny_thresh1) + "," + std::to_string(canny_thresh2) + ")";
        } else if (edge_method == 1) {
            info += " (核大小=" + std::to_string(sobel_kernel) + ")";
        }
        
        cv::putText(comparison, info, cv::Point(original.cols / 2 - 100, original.rows - 20),
                   cv::FONT_HERSHEY_SIMPLEX, 0.7, cv::Scalar(255, 255, 255), 2);
        
        cv::imshow("边缘检测与轮廓", comparison);
        cv::imshow("控制面板", control_panel);
    };
    
    // 初始显示
    updateEdgeContourDemo();
    
    // 主循环
    while (true) {
        int key = cv::waitKey(0);
        
        if (key == 27) {  // ESC
            break;
        } else if (key >= '1' && key <= '3') {
            edge_method = key - '1';
            updateEdgeContourDemo();
        } else if ((key == 'q' || key == 'Q') && edge_method == 0) {
            canny_thresh1 = std::max(0, canny_thresh1 - 10);
            updateEdgeContourDemo();
        } else if ((key == 'w' || key == 'W') && edge_method == 0) {
            canny_thresh1 = std::min(255, canny_thresh1 + 10);
            updateEdgeContourDemo();
        } else if ((key == 'a' || key == 'A') && edge_method == 0) {
            canny_thresh2 = std::max(canny_thresh1 + 1, canny_thresh2 - 10);
            updateEdgeContourDemo();
        } else if ((key == 's' || key == 'S') && edge_method == 0) {
            canny_thresh2 = std::min(255, canny_thresh2 + 10);
            updateEdgeContourDemo();
        } else if ((key == 'e' || key == 'E') && edge_method == 1) {
            sobel_kernel = std::max(1, sobel_kernel - 2);
            if (sobel_kernel % 2 == 0) sobel_kernel--;
            updateEdgeContourDemo();
        } else if ((key == 'r' || key == 'R') && edge_method == 1) {
            sobel_kernel = std::min(31, sobel_kernel + 2);
            if (sobel_kernel % 2 == 0) sobel_kernel++;
            updateEdgeContourDemo();
        } else if (key == 'z' || key == 'Z') {
            min_area = std::max(100.0, min_area - 100);
            updateEdgeContourDemo();
        } else if (key == 'x' || key == 'X') {
            min_area = std::min(5000.0, min_area + 100);
            updateEdgeContourDemo();
        } else if (key == 'c' || key == 'C') {
            show_contours = !show_contours;
            updateEdgeContourDemo();
        } else if (key == 'v' || key == 'V') {
            show_bounding = !show_bounding;
            updateEdgeContourDemo();
        } else if (key == 'b' || key == 'B') {
            show_circles = !show_circles;
            updateEdgeContourDemo();
        } else if (key == 's' || key == 'S') {
            cv::imwrite("edge_contour_demo.jpg", display_panel);
            std::cout << "已保存结果到 edge_contour_demo.jpg" << std::endl;
        }
    }
    
    cv::destroyAllWindows();
    
    std::cout << "\n=== 边缘检测与轮廓提取演示完成 ===" << std::endl;
    std::cout << "总结：" << std::endl;
    std::cout << "1. 掌握了多种边缘检测方法（Canny, Sobel, Laplacian）" << std::endl;
    std::cout << "2. 学会了轮廓查找、绘制和分析" << std::endl;
    std::cout << "3. 理解了轮廓层次结构和轮廓筛选方法" << std::endl;
    std::cout << "4. 实现了轮廓面积、周长、外接形状等分析" << std::endl;
    
    return 0;
}
```

## 九、图像几何变换（复杂变换）

### 9.1 几何变换基础

#### 讲解
几何变换是改变图像中像素位置的操作，包括平移、旋转、缩放、仿射变换和透视变换等。这些变换在图像配准、图像校正、虚拟现实等领域有广泛应用。

#### 变换类型对比

| 变换类型 | 描述 | 自由度 | 保持性质 | OpenCV函数 |
|----------|------|--------|----------|------------|
| **平移** | 移动图像 | 2 | 形状、大小、方向 | `warpAffine()` |
| **旋转** | 绕中心旋转 | 1 | 形状、大小 | `warpAffine()` |
| **缩放** | 改变大小 | 2 | 形状 | `resize()`或`warpAffine()` |
| **仿射** | 线性变换+平移 | 6 | 平行性、共线性 | `warpAffine()` |
| **透视** | 投影变换 | 8 | 直线保持直线 | `warpPerspective()` |

#### 变换矩阵详解

##### 1. 仿射变换矩阵（2×3）
```
[ a00  a01  a02 ]
[ a10  a11  a12 ]
```
其中：
- `a00, a01, a10, a11`：线性变换部分（旋转、缩放、错切）
- `a02, a12`：平移部分

##### 2. 透视变换矩阵（3×3）
```
[ a00  a01  a02 ]
[ a10  a11  a12 ]
[ a20  a21  a23 ]
```
其中最后一行用于实现透视效果

#### 几何变换实战代码

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>
#include <vector>
#include <cmath>

// 显示图像信息
void showImageInfo(const cv::Mat& img, const std::string& name) {
    std::cout << name << ": " << img.cols << "×" << img.rows 
              << " (" << img.channels() << " channels)" << std::endl;
}

// 创建测试图像
cv::Mat createTestImage(int width, int height) {
    cv::Mat image(height, width, CV_8UC3, cv::Scalar(100, 100, 100));
    
    // 创建网格背景
    int grid_size = 50;
    for (int y = 0; y < height; y += grid_size) {
        cv::line(image, cv::Point(0, y), cv::Point(width, y), 
                cv::Scalar(150, 150, 150), 1);
    }
    for (int x = 0; x < width; x += grid_size) {
        cv::line(image, cv::Point(x, 0), cv::Point(x, height), 
                cv::Scalar(150, 150, 150), 1);
    }
    
    // 添加中心十字
    cv::line(image, cv::Point(width/2, 0), cv::Point(width/2, height), 
            cv::Scalar(0, 255, 0), 2);
    cv::line(image, cv::Point(0, height/2), cv::Point(width, height/2), 
            cv::Scalar(0, 255, 0), 2);
    
    // 添加坐标轴标签
    cv::putText(image, "X", cv::Point(width - 30, height/2 - 10),
                cv::FONT_HERSHEY_SIMPLEX, 0.7, cv::Scalar(0, 255, 0), 2);
    cv::putText(image, "Y", cv::Point(width/2 + 10, 30),
                cv::FONT_HERSHEY_SIMPLEX, 0.7, cv::Scalar(0, 255, 0), 2);
    
    // 添加各种形状
    // 矩形
    cv::rectangle(image, cv::Rect(width/4, height/4, 100, 80), 
                 cv::Scalar(255, 0, 0), 3);
    
    // 圆形
    cv::circle(image, cv::Point(width*3/4, height/4), 50, 
              cv::Scalar(0, 0, 255), 3);
    
    // 三角形
    std::vector<cv::Point> triangle = {
        cv::Point(width/2, height*3/4),
        cv::Point(width/2 + 60, height*3/4 + 80),
        cv::Point(width/2 - 60, height*3/4 + 80)
    };
    cv::polylines(image, std::vector<std::vector<cv::Point>>{triangle}, 
                 true, cv::Scalar(0, 255, 255), 3);
    
    // 添加文字
    cv::putText(image, "Geometry Transform", cv::Point(width/2 - 150, 50),
                cv::FONT_HERSHEY_SIMPLEX, 1.2, cv::Scalar(255, 255, 255), 2);
    
    return image;
}

int main() {
    std::cout << "=== OpenCV 图像几何变换 ===\n" << std::endl;
    
    // ============================================
    // 1. 创建测试图像
    // ============================================
    
    std::cout << "1. 创建测试图像..." << std::endl;
    cv::Mat original = createTestImage(800, 600);
    showImageInfo(original, "原始图像");
    
    // ============================================
    // 2. 平移变换
    // ============================================
    
    std::cout << "\n2. 平移变换 (Translation)" << std::endl;
    
    cv::Mat translated;
    cv::Mat translate_mat = (cv::Mat_<float>(2, 3) << 1, 0, 100,  // 向右平移100像素
                                                     0, 1, 50);   // 向下平移50像素
    
    cv::warpAffine(original, translated, translate_mat, original.size());
    std::cout << "   平移矩阵: [1, 0, 100; 0, 1, 50]" << std::endl;
    std::cout << "   向右平移100像素，向下平移50像素" << std::endl;
    
    // 不同方向的平移
    cv::Mat translated_left, translated_up;
    cv::Mat mat_left = (cv::Mat_<float>(2, 3) << 1, 0, -100, 0, 1, 0);
    cv::Mat mat_up = (cv::Mat_<float>(2, 3) << 1, 0, 0, 0, 1, -80);
    
    cv::warpAffine(original, translated_left, mat_left, original.size());
    cv::warpAffine(original, translated_up, mat_up, original.size());
    
    // ============================================
    // 3. 旋转变换
    // ============================================
    
    std::cout << "\n3. 旋转变换 (Rotation)" << std::endl;
    
    cv::Point2f center(original.cols / 2.0f, original.rows / 2.0f);
    
    // 3.1 旋转30度
    cv::Mat rotated_30;
    cv::Mat rotate_mat_30 = cv::getRotationMatrix2D(center, 30.0, 1.0);
    cv::warpAffine(original, rotated_30, rotate_mat_30, original.size());
    std::cout << "   旋转30度 (中心旋转)" << std::endl;
    
    // 3.2 旋转45度并缩放
    cv::Mat rotated_45_scaled;
    cv::Mat rotate_mat_45 = cv::getRotationMatrix2D(center, 45.0, 0.8);
    cv::warpAffine(original, rotated_45_scaled, rotate_mat_45, original.size());
    std::cout << "   旋转45度并缩放0.8倍" << std::endl;
    
    // 3.3 旋转90度（使用rotate函数）
    cv::Mat rotated_90;
    cv::rotate(original, rotated_90, cv::ROTATE_90_CLOCKWISE);
    std::cout << "   顺时针旋转90度 (使用rotate函数)" << std::endl;
    
    // ============================================
    // 4. 缩放变换
    // ============================================
    
    std::cout << "\n4. 缩放变换 (Scaling)" << std::endl;
    
    // 4.1 使用resize函数
    cv::Mat scaled_half, scaled_double;
    cv::resize(original, scaled_half, cv::Size(400, 300), 0, 0, cv::INTER_LINEAR);
    cv::resize(original, scaled_double, cv::Size(1600, 1200), 0, 0, cv::INTER_LINEAR);
    std::cout << "   缩小到一半: 800×600 -> 400×300" << std::endl;
    std::cout << "   放大到两倍: 800×600 -> 1600×1200" << std::endl;
    
    // 4.2 使用仿射变换实现缩放
    cv::Mat scaled_affine;
    cv::Mat scale_mat = (cv::Mat_<float>(2, 3) << 0.7, 0, 0,  // x方向缩放0.7
                                                  0, 1.2, 0); // y方向缩放1.2
    cv::warpAffine(original, scaled_affine, scale_mat, original.size());
    std::cout << "   非均匀缩放: X方向0.7倍, Y方向1.2倍" << std::endl;
    
    // ============================================
    // 5. 错切变换
    // ============================================
    
    std::cout << "\n5. 错切变换 (Shearing)" << std::endl;
    
    cv::Mat sheared_x, sheared_y, sheared_xy;
    
    // 5.1 X方向错切
    cv::Mat shear_x_mat = (cv::Mat_<float>(2, 3) << 1, 0.3, 0,
                                                    0, 1, 0);
    cv::warpAffine(original, sheared_x, shear_x_mat, original.size());
    std::cout << "   X方向错切: 水平偏移" << std::endl;
    
    // 5.2 Y方向错切
    cv::Mat shear_y_mat = (cv::Mat_<float>(2, 3) << 1, 0, 0,
                                                    0.3, 1, 0);
    cv::warpAffine(original, sheared_y, shear_y_mat, original.size());
    std::cout << "   Y方向错切: 垂直偏移" << std::endl;
    
    // 5.3 双向错切
    cv::Mat shear_xy_mat = (cv::Mat_<float>(2, 3) << 1, 0.2, 0,
                                                     0.2, 1, 0);
    cv::warpAffine(original, sheared_xy, shear_xy_mat, original.size());
    std::cout << "   双向错切: 水平和垂直偏移" << std::endl;
    
    // ============================================
    // 6. 仿射变换（三点法）
    // ============================================
    
    std::cout << "\n6. 仿射变换 (三点法)" << std::endl;
    
    // 6.1 定义原始图像中的三个点
    std::vector<cv::Point2f> src_points = {
        cv::Point2f(50, 50),
        cv::Point2f(200, 50),
        cv::Point2f(50, 200)
    };
    
    // 6.2 定义变换后的三个点
    std::vector<cv::Point2f> dst_points = {
        cv::Point2f(10, 100),     // 点1移动
        cv::Point2f(200, 20),     // 点2移动
        cv::Point2f(100, 250)     // 点3移动
    };
    
    // 6.3 计算仿射变换矩阵
    cv::Mat affine_mat = cv::getAffineTransform(src_points, dst_points);
    cv::Mat affine_result;
    cv::warpAffine(original, affine_result, affine_mat, original.size());
    
    std::cout << "   三点法仿射变换矩阵:" << std::endl;
    std::cout << affine_mat << std::endl;
    
    // 在图像上标记点
    cv::Mat marked_affine = original.clone();
    for (size_t i = 0; i < src_points.size(); i++) {
        cv::circle(marked_affine, src_points[i], 5, cv::Scalar(0, 0, 255), -1);
        cv::putText(marked_affine, std::to_string(i+1), 
                   cv::Point(src_points[i].x + 10, src_points[i].y - 10),
                   cv::FONT_HERSHEY_SIMPLEX, 0.6, cv::Scalar(0, 0, 255), 2);
    }
    
    // ============================================
    // 7. 透视变换
    // ============================================
    
    std::cout << "\n7. 透视变换 (四点法)" << std::endl;
    
    // 7.1 定义原始图像的四个角点
    std::vector<cv::Point2f> src_corners = {
        cv::Point2f(100, 100),
        cv::Point2f(700, 100),
        cv::Point2f(700, 500),
        cv::Point2f(100, 500)
    };
    
    // 7.2 定义透视变换后的四个点
    std::vector<cv::Point2f> dst_corners = {
        cv::Point2f(50, 150),      // 左上角
        cv::Point2f(750, 50),      // 右上角
        cv::Point2f(650, 450),     // 右下角
        cv::Point2f(150, 550)      // 左下角
    };
    
    // 7.3 计算透视变换矩阵
    cv::Mat perspective_mat = cv::getPerspectiveTransform(src_corners, dst_corners);
    cv::Mat perspective_result;
    cv::warpPerspective(original, perspective_result, perspective_mat, original.size());
    
    std::cout << "   四点法透视变换矩阵:" << std::endl;
    std::cout << perspective_mat << std::endl;
    std::cout << "   模拟3D透视效果" << std::endl;
    
    // 在图像上标记点
    cv::Mat marked_perspective = original.clone();
    for (size_t i = 0; i < src_corners.size(); i++) {
        cv::circle(marked_perspective, src_corners[i], 8, cv::Scalar(255, 0, 0), -1);
        cv::putText(marked_perspective, std::to_string(i+1), 
                   cv::Point(src_corners[i].x + 15, src_corners[i].y - 15),
                   cv::FONT_HERSHEY_SIMPLEX, 0.7, cv::Scalar(255, 0, 0), 2);
    }
    
    // ============================================
    // 8. 复合变换
    // ============================================
    
    std::cout << "\n8. 复合变换 (组合变换)" << std::endl;
    
    // 8.1 创建复合变换矩阵（平移 + 旋转 + 缩放）
    cv::Mat composite_result;
    
    // 先创建缩放矩阵（3×3）
    cv::Mat scale_mat_3x3 = cv::Mat::eye(3, 3, CV_32F);
    scale_mat_3x3.at<float>(0, 0) = 0.8f;  // x方向缩放
    scale_mat_3x3.at<float>(1, 1) = 0.8f;  // y方向缩放
    
    // 创建旋转矩阵（3×3）
    float angle = 20.0f * CV_PI / 180.0f;  // 转换为弧度
    cv::Mat rotate_mat_3x3 = cv::Mat::eye(3, 3, CV_32F);
    rotate_mat_3x3.at<float>(0, 0) = cos(angle);
    rotate_mat_3x3.at<float>(0, 1) = -sin(angle);
    rotate_mat_3x3.at<float>(1, 0) = sin(angle);
    rotate_mat_3x3.at<float>(1, 1) = cos(angle);
    
    // 创建平移矩阵（3×3）
    cv::Mat translate_mat_3x3 = cv::Mat::eye(3, 3, CV_32F);
    translate_mat_3x3.at<float>(0, 2) = 50.0f;  // x方向平移
    translate_mat_3x3.at<float>(1, 2) = 30.0f;  // y方向平移
    
    // 组合变换：先缩放，再旋转，最后平移
    cv::Mat composite_mat_3x3 = translate_mat_3x3 * rotate_mat_3x3 * scale_mat_3x3;
    
    // 提取仿射变换部分（前2行）
    cv::Mat composite_mat_2x3 = composite_mat_3x3(cv::Rect(0, 0, 3, 2));
    
    cv::warpAffine(original, composite_result, composite_mat_2x3, original.size());
    std::cout << "   复合变换: 缩放0.8 + 旋转20° + 平移(50,30)" << std::endl;
    
    // ============================================
    // 9. 透视矫正应用
    // ============================================
    
    std::cout << "\n9. 透视矫正应用" << std::endl;
    
    // 创建一个倾斜的文档图像（模拟）
    cv::Mat document(400, 600, CV_8UC3, cv::Scalar(240, 240, 240));
    
    // 添加文档内容
    cv::putText(document, "OpenCV Geometry Transform", cv::Point(50, 80),
                cv::FONT_HERSHEY_SIMPLEX, 1.2, cv::Scalar(0, 0, 0), 2);
    
    cv::putText(document, "1. Translation - Move image", cv::Point(50, 150),
                cv::FONT_HERSHEY_SIMPLEX, 0.7, cv::Scalar(0, 0, 0), 1);
    cv::putText(document, "2. Rotation - Rotate image", cv::Point(50, 200),
                cv::FONT_HERSHEY_SIMPLEX, 0.7, cv::Scalar(0, 0, 0), 1);
    cv::putText(document, "3. Scaling - Resize image", cv::Point(50, 250),
                cv::FONT_HERSHEY_SIMPLEX, 0.7, cv::Scalar(0, 0, 0), 1);
    cv::putText(document, "4. Affine - Linear transform", cv::Point(50, 300),
                cv::FONT_HERSHEY_SIMPLEX, 0.7, cv::Scalar(0, 0, 0), 1);
    cv::putText(document, "5. Perspective - 3D effect", cv::Point(50, 350),
                cv::FONT_HERSHEY_SIMPLEX, 0.7, cv::Scalar(0, 0, 0), 1);
    
    // 添加边框
    cv::rectangle(document, cv::Rect(20, 20, 560, 360), cv::Scalar(0, 0, 0), 2);
    
    // 对文档进行透视变换，使其倾斜
    std::vector<cv::Point2f> doc_src = {
        cv::Point2f(0, 0),
        cv::Point2f(document.cols - 1, 0),
        cv::Point2f(document.cols - 1, document.rows - 1),
        cv::Point2f(0, document.rows - 1)
    };
    
    std::vector<cv::Point2f> doc_dst = {
        cv::Point2f(50, 80),
        cv::Point2f(document.cols - 50, 30),
        cv::Point2f(document.cols - 80, document.rows - 50),
        cv::Point2f(80, document.rows - 30)
    };
    
    cv::Mat skewed_doc;
    cv::Mat doc_perspective_mat = cv::getPerspectiveTransform(doc_src, doc_dst);
    cv::warpPerspective(document, skewed_doc, doc_perspective_mat, 
                       cv::Size(700, 500), cv::INTER_LINEAR, cv::BORDER_CONSTANT, 
                       cv::Scalar(200, 200, 200));
    
    // 透视矫正（将倾斜的文档矫正回矩形）
    cv::Mat corrected_doc;
    cv::Mat inverse_perspective_mat = cv::getPerspectiveTransform(doc_dst, doc_src);
    cv::warpPerspective(skewed_doc, corrected_doc, inverse_perspective_mat, 
                       document.size(), cv::INTER_LINEAR, cv::BORDER_CONSTANT, 
                       cv::Scalar(200, 200, 200));
    
    std::cout << "   创建倾斜文档并矫正" << std::endl;
    
    // ============================================
    // 10. 创建显示面板
    // ============================================
    
    std::cout << "\n10. 创建结果显示面板..." << std::endl;
    
    int panel_width = 1600;
    int panel_height = 1400;
    cv::Mat display_panel(panel_height, panel_width, CV_8UC3, cv::Scalar(40, 40, 40));
    
    // 10.1 定义缩略图尺寸
    int thumb_width = 350;
    int thumb_height = 260;
    
    // 10.2 准备所有图像
    struct DisplayItem {
        cv::Mat image;
        std::string label;
    };
    
    std::vector<DisplayItem> display_items = {
        {original, "原始图像"},
        {translated, "平移变换"},
        {rotated_30, "旋转30°"},
        {rotated_45_scaled, "旋转45°+缩放"},
        {scaled_half, "缩放一半"},
        {scaled_affine, "非均匀缩放"},
        {sheared_x, "X方向错切"},
        {sheared_y, "Y方向错切"},
        {sheared_xy, "双向错切"},
        {marked_affine, "三点法标记"},
        {affine_result, "仿射变换"},
        {marked_perspective, "四点法标记"},
        {perspective_result, "透视变换"},
        {composite_result, "复合变换"},
        {document, "原始文档"},
        {skewed_doc, "倾斜文档"},
        {corrected_doc, "矫正文档"}
    };
    
    // 10.3 排列图像
    int cols = 4;
    for (size_t i = 0; i < display_items.size(); i++) {
        int row = i / cols;
        int col = i % cols;
        
        int x = col * (thumb_width + 20) + 20;
        int y = row * (thumb_height + 40) + 40;
        
        // 检查边界
        if (y + thumb_height >= panel_height) {
            // 扩展面板
            panel_height += thumb_height + 100;
            cv::Mat new_panel(panel_height, panel_width, CV_8UC3, cv::Scalar(40, 40, 40));
            display_panel.copyTo(new_panel(cv::Rect(0, 0, display_panel.cols, display_panel.rows)));
            display_panel = new_panel;
        }
        
        // 调整图像尺寸
        cv::Mat thumb;
        cv::resize(display_items[i].image, thumb, cv::Size(thumb_width, thumb_height));
        
        // 复制到面板
        cv::Rect roi(x, y, thumb_width, thumb_height);
        thumb.copyTo(display_panel(roi));
        
        // 添加边框
        cv::rectangle(display_panel, roi, cv::Scalar(180, 180, 180), 2);
        
        // 添加标签
        cv::putText(display_panel, display_items[i].label,
                   cv::Point(x + 10, y + thumb_height + 25),
                   cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(220, 220, 220), 1);
    }
    
    // 10.4 添加标题和说明
    cv::putText(display_panel, "OpenCV 图像几何变换演示",
               cv::Point(panel_width / 2 - 250, 30),
               cv::FONT_HERSHEY_SIMPLEX, 0.9, cv::Scalar(0, 255, 255), 2);
    
    cv::putText(display_panel, "基本变换: 平移, 旋转, 缩放, 错切",
               cv::Point(20, panel_height - 100),
               cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(200, 200, 200), 1);
    
    cv::putText(display_panel, "复杂变换: 仿射变换(三点法), 透视变换(四点法)",
               cv::Point(20, panel_height - 80),
               cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(200, 200, 200), 1);
    
    cv::putText(display_panel, "应用: 复合变换, 透视矫正",
               cv::Point(20, panel_height - 60),
               cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(200, 200, 200), 1);
    
    cv::putText(display_panel, "按ESC退出, 按's'保存结果",
               cv::Point(panel_width - 300, panel_height - 20),
               cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(200, 200, 200), 1);
    
    // ============================================
    // 11. 交互演示：实时几何变换调整
    // ============================================
    
    std::cout << "\n11. 交互演示：实时几何变换调整" << std::endl;
    
    cv::namedWindow("几何变换调整", cv::WINDOW_NORMAL);
    cv::resizeWindow("几何变换调整", 800, 600);
    
    cv::namedWindow("控制面板", cv::WINDOW_NORMAL);
    cv::resizeWindow("控制面板", 400, 500);
    
    // 控制参数
    int transform_type = 0;  // 0:平移, 1:旋转, 2:缩放, 3:错切, 4:仿射, 5:透视
    float tx = 100.0f;       // 平移X
    float ty = 50.0f;        // 平移Y
    float angle_val = 30.0f; // 旋转角度
    float scale_x = 1.0f;    // 缩放X
    float scale_y = 1.0f;    // 缩放Y
    float shear_x = 0.0f;    // 错切X
    float shear_y = 0.0f;    // 错切Y
    
    // 创建控制面板
    cv::Mat control_panel(500, 400, CV_8UC3, cv::Scalar(50, 50, 50));
    
    // 更新控制面板和变换效果
    auto updateGeometryDemo = [&]() {
        control_panel.setTo(cv::Scalar(50, 50, 50));
        
        // 标题
        cv::putText(control_panel, "=== 几何变换控制面板 ===",
                   cv::Point(20, 30), cv::FONT_HERSHEY_SIMPLEX,
                   0.7, cv::Scalar(0, 255, 255), 2);
        
        // 当前参数
        std::vector<std::string> transform_names = {"平移", "旋转", "缩放", "错切", "仿射", "透视"};
        cv::putText(control_panel, "变换类型: " + transform_names[transform_type],
                   cv::Point(20, 70), cv::FONT_HERSHEY_SIMPLEX,
                   0.6, cv::Scalar(200, 200, 200), 1);
        
        if (transform_type == 0) {  // 平移
            cv::putText(control_panel, "平移X: " + std::to_string(static_cast<int>(tx)),
                       cv::Point(20, 100), cv::FONT_HERSHEY_SIMPLEX,
                       0.6, cv::Scalar(200, 200, 200), 1);
            cv::putText(control_panel, "平移Y: " + std::to_string(static_cast<int>(ty)),
                       cv::Point(20, 130), cv::FONT_HERSHEY_SIMPLEX,
                       0.6, cv::Scalar(200, 200, 200), 1);
        } else if (transform_type == 1) {  // 旋转
            cv::putText(control_panel, "角度: " + std::to_string(static_cast<int>(angle_val)) + "°",
                       cv::Point(20, 100), cv::FONT_HERSHEY_SIMPLEX,
                       0.6, cv::Scalar(200, 200, 200), 1);
        } else if (transform_type == 2) {  // 缩放
            cv::putText(control_panel, "缩放X: " + std::to_string(scale_x),
                       cv::Point(20, 100), cv::FONT_HERSHEY_SIMPLEX,
                       0.6, cv::Scalar(200, 200, 200), 1);
            cv::putText(control_panel, "缩放Y: " + std::to_string(scale_y),
                       cv::Point(20, 130), cv::FONT_HERSHEY_SIMPLEX,
                       0.6, cv::Scalar(200, 200, 200), 1);
        } else if (transform_type == 3) {  // 错切
            cv::putText(control_panel, "错切X: " + std::to_string(shear_x),
                       cv::Point(20, 100), cv::FONT_HERSHEY_SIMPLEX,
                       0.6, cv::Scalar(200, 200, 200), 1);
            cv::putText(control_panel, "错切Y: " + std::to_string(shear_y),
                       cv::Point(20, 130), cv::FONT_HERSHEY_SIMPLEX,
                       0.6, cv::Scalar(200, 200, 200), 1);
        }
        
        // 操作说明
        cv::putText(control_panel, "按键控制:", cv::Point(20, 180),
                   cv::FONT_HERSHEY_SIMPLEX, 0.6, cv::Scalar(0, 255, 0), 1);
        
        std::vector<std::string> instructions = {
            "1-6: 选择变换类型",
            "A/D: 调整参数1",
            "W/S: 调整参数2",
            "Q/E: 调整参数3",
            "R/F: 调整参数4",
            "空格: 重置参数",
            "ESC: 退出"
        };
        
        for (size_t i = 0; i < instructions.size(); i++) {
            cv::putText(control_panel, instructions[i],
                       cv::Point(30, 210 + i * 25),
                       cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(200, 200, 200), 1);
        }
        
        // 应用当前变换
        cv::Mat transformed;
        cv::Mat transform_mat;
        
        cv::Point2f center_point(original.cols / 2.0f, original.rows / 2.0f);
        
        switch (transform_type) {
            case 0:  // 平移
                transform_mat = (cv::Mat_<float>(2, 3) << 1, 0, tx, 0, 1, ty);
                cv::warpAffine(original, transformed, transform_mat, original.size());
                break;
                
            case 1:  // 旋转
                transform_mat = cv::getRotationMatrix2D(center_point, angle_val, 1.0);
                cv::warpAffine(original, transformed, transform_mat, original.size());
                break;
                
            case 2:  // 缩放
                transform_mat = (cv::Mat_<float>(2, 3) << scale_x, 0, 0, 0, scale_y, 0);
                cv::warpAffine(original, transformed, transform_mat, original.size());
                break;
                
            case 3:  // 错切
                transform_mat = (cv::Mat_<float>(2, 3) << 1, shear_x, 0, shear_y, 1, 0);
                cv::warpAffine(original, transformed, transform_mat, original.size());
                break;
                
            case 4:  // 仿射（三点法）
                {
                    std::vector<cv::Point2f> src_pts = {
                        cv::Point2f(100, 100),
                        cv::Point2f(200, 100),
                        cv::Point2f(100, 200)
                    };
                    
                    std::vector<cv::Point2f> dst_pts = {
                        cv::Point2f(100 + tx, 100 + ty),
                        cv::Point2f(200 + tx * 0.5f, 100 + ty * 0.5f),
                        cv::Point2f(100 + tx * 1.5f, 200 + ty * 1.5f)
                    };
                    
                    transform_mat = cv::getAffineTransform(src_pts, dst_pts);
                    cv::warpAffine(original, transformed, transform_mat, original.size());
                }
                break;
                
            case 5:  // 透视
                {
                    std::vector<cv::Point2f> src_corners = {
                        cv::Point2f(100, 100),
                        cv::Point2f(700, 100),
                        cv::Point2f(700, 500),
                        cv::Point2f(100, 500)
                    };
                    
                    std::vector<cv::Point2f> dst_corners = {
                        cv::Point2f(100 + tx, 100 + ty),
                        cv::Point2f(700 - tx, 100 + ty * 0.5f),
                        cv::Point2f(700 - tx * 1.5f, 500 - ty),
                        cv::Point2f(100 + tx * 0.5f, 500 - ty * 1.5f)
                    };
                    
                    transform_mat = cv::getPerspectiveTransform(src_corners, dst_corners);
                    cv::warpPerspective(original, transformed, transform_mat, original.size());
                }
                break;
        }
        
        // 创建对比图像（左右并排）
        cv::Mat comparison(original.rows, original.cols * 2, CV_8UC3);
        original.copyTo(comparison(cv::Rect(0, 0, original.cols, original.rows)));
        transformed.copyTo(comparison(cv::Rect(original.cols, 0, original.cols, original.rows)));
        
        // 添加标签
        cv::putText(comparison, "原始图像", cv::Point(20, 40),
                   cv::FONT_HERSHEY_SIMPLEX, 1.0, cv::Scalar(0, 255, 0), 2);
        cv::putText(comparison, "变换后图像", cv::Point(original.cols + 20, 40),
                   cv::FONT_HERSHEY_SIMPLEX, 1.0, cv::Scalar(0, 255, 0), 2);
        
        // 添加变换信息
        std::string info = transform_names[transform_type] + " 变换";
        if (transform_type == 0) {
            info += " (tx=" + std::to_string(static_cast<int>(tx)) + 
                   ", ty=" + std::to_string(static_cast<int>(ty)) + ")";
        } else if (transform_type == 1) {
            info += " (角度=" + std::to_string(static_cast<int>(angle_val)) + "°)";
        } else if (transform_type == 2) {
            info += " (sx=" + std::to_string(scale_x) + 
                   ", sy=" + std::to_string(scale_y) + ")";
        } else if (transform_type == 3) {
            info += " (shx=" + std::to_string(shear_x) + 
                   ", shy=" + std::to_string(shear_y) + ")";
        }
        
        cv::putText(comparison, info, cv::Point(original.cols / 2 - 150, original.rows - 20),
                   cv::FONT_HERSHEY_SIMPLEX, 0.7, cv::Scalar(255, 255, 255), 2);
        
        cv::imshow("几何变换调整", comparison);
        cv::imshow("控制面板", control_panel);
    };
    
    // 初始显示
    updateGeometryDemo();
    
    // 主循环
    while (true) {
        int key = cv::waitKey(0);
        
        if (key == 27) {  // ESC
            break;
        } else if (key >= '1' && key <= '6') {
            transform_type = key - '1';
            updateGeometryDemo();
        } else if (key == 'a' || key == 'A') {
            if (transform_type == 0) tx = std::max(-200.0f, tx - 10.0f);
            else if (transform_type == 1) angle_val = std::max(-180.0f, angle_val - 5.0f);
            else if (transform_type == 2) scale_x = std::max(0.1f, scale_x - 0.1f);
            else if (transform_type == 3) shear_x = std::max(-1.0f, shear_x - 0.1f);
            updateGeometryDemo();
        } else if (key == 'd' || key == 'D') {
            if (transform_type == 0) tx = std::min(200.0f, tx + 10.0f);
            else if (transform_type == 1) angle_val = std::min(180.0f, angle_val + 5.0f);
            else if (transform_type == 2) scale_x = std::min(3.0f, scale_x + 0.1f);
            else if (transform_type == 3) shear_x = std::min(1.0f, shear_x + 0.1f);
            updateGeometryDemo();
        } else if (key == 'w' || key == 'W') {
            if (transform_type == 0) ty = std::max(-200.0f, ty - 10.0f);
            else if (transform_type == 2) scale_y = std::max(0.1f, scale_y - 0.1f);
            else if (transform_type == 3) shear_y = std::max(-1.0f, shear_y - 0.1f);
            updateGeometryDemo();
        } else if (key == 's' || key == 'S') {
            if (transform_type == 0) ty = std::min(200.0f, ty + 10.0f);
            else if (transform_type == 2) scale_y = std::min(3.0f, scale_y + 0.1f);
            else if (transform_type == 3) shear_y = std::min(1.0f, shear_y + 0.1f);
            updateGeometryDemo();
        } else if (key == 'q' || key == 'Q') {
            if (transform_type == 4 || transform_type == 5) {
                tx = std::max(-100.0f, tx - 10.0f);
                updateGeometryDemo();
            }
        } else if (key == 'e' || key == 'E') {
            if (transform_type == 4 || transform_type == 5) {
                tx = std::min(100.0f, tx + 10.0f);
                updateGeometryDemo();
            }
        } else if (key == 'r' || key == 'R') {
            if (transform_type == 4 || transform_type == 5) {
                ty = std::max(-100.0f, ty - 10.0f);
                updateGeometryDemo();
            }
        } else if (key == 'f' || key == 'F') {
            if (transform_type == 4 || transform_type == 5) {
                ty = std::min(100.0f, ty + 10.0f);
                updateGeometryDemo();
            }
        } else if (key == ' ') {
            // 重置所有参数
            tx = 100.0f; ty = 50.0f;
            angle_val = 30.0f;
            scale_x = 1.0f; scale_y = 1.0f;
            shear_x = 0.0f; shear_y = 0.0f;
            updateGeometryDemo();
        } else if (key == 'm' || key == 'M') {
            // 切换到文档矫正演示
            cv::Mat doc_comparison(document.rows, document.cols * 2, CV_8UC3);
            document.copyTo(doc_comparison(cv::Rect(0, 0, document.cols, document.rows)));
            corrected_doc.copyTo(doc_comparison(cv::Rect(document.cols, 0, document.cols, document.rows)));
            
            cv::putText(doc_comparison, "原始文档", cv::Point(20, 40),
                       cv::FONT_HERSHEY_SIMPLEX, 1.0, cv::Scalar(0, 255, 0), 2);
            cv::putText(doc_comparison, "矫正后文档", cv::Point(document.cols + 20, 40),
                       cv::FONT_HERSHEY_SIMPLEX, 1.0, cv::Scalar(0, 255, 0), 2);
            
            cv::namedWindow("文档矫正演示", cv::WINDOW_NORMAL);
            cv::resizeWindow("文档矫正演示", 1000, 500);
            cv::imshow("文档矫正演示", doc_comparison);
        } else if (key == 's' || key == 'S') {
            cv::imwrite("geometry_transform_demo.jpg", display_panel);
            std::cout << "已保存结果到 geometry_transform_demo.jpg" << std::endl;
        }
    }
    
    cv::destroyAllWindows();
    
    std::cout << "\n=== 图像几何变换演示完成 ===" << std::endl;
    std::cout << "总结：" << std::endl;
    std::cout << "1. 掌握了基本几何变换：平移、旋转、缩放、错切" << std::endl;
    std::cout << "2. 学会了仿射变换（三点法）和透视变换（四点法）" << std::endl;
    std::cout << "3. 理解了变换矩阵的计算和应用" << std::endl;
    std::cout << "4. 实现了复合变换和透视矫正等应用" << std::endl;
    
    return 0;
}
```

## 总结

本系列笔记涵盖了OpenCV图像处理的核心内容，从基础的像素操作到高级的几何变换，具体包括：

### 已涵盖内容：
1. **图像读写与显示** - 基础I/O操作，窗口管理
2. **像素运算与位操作** - 算术运算，逻辑运算，像素值处理
3. **色彩空间与通道操作** - RGB/HSV/Lab转换，通道拆分合并
4. **图像滤波与降噪** - 线性/非线性滤波，噪声去除
5. **图像阈值处理** - 多种阈值方法，自适应阈值，文字提取
6. **形态学操作** - 腐蚀膨胀，开闭运算，形状处理
7. **边缘检测与轮廓提取** - Canny/Sobel/Laplacian，轮廓分析
8. **图像几何变换** - 仿射变换，透视变换，复合变换

### 核心知识点总结：
1. **选择合适的工具**：不同问题需要不同的处理方法
2. **参数调节很重要**：大多数算法都有可调节参数
3. **理解算法原理**：理解原理才能正确应用
4. **实践应用导向**：所有知识都要结合实际应用

每个部分都提供了详细的代码示例和交互演示，帮助深入理解和掌握OpenCV图像处理技术。建议按照顺序学习，从基础开始逐步深入，并通过实践项目巩固所学知识。