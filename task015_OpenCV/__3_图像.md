# OpenCV 图像与视频处理

## 一、图像处理

### 1.1 图像读写与显示

#### 讲解
图像处理的第一步是加载、显示和保存图像。OpenCV提供了强大的I/O功能，支持多种图像格式。掌握正确的读写方式能避免常见的内存泄漏和编码问题。

#### 核心类与方法

| 类/方法 | 说明 | 关键参数 |
|---------|------|----------|
| `imread()` | 读取图像 | `filename`, `flags`（加载模式） |
| `imshow()` | 显示图像 | `winname`, `mat` |
| `imwrite()` | 保存图像 | `filename`, `img`, `params` |
| `namedWindow()` | 创建窗口 | `winname`, `flags` |
| `destroyWindow()` | 销毁窗口 | `winname` |
| `waitKey()` | 等待按键 | `delay`（毫秒） |
| `moveWindow()` | 移动窗口 | `winname`, `x`, `y` |
| `resizeWindow()` | 调整窗口大小 | `winname`, `width`, `height` |

#### 图像加载模式

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>
#include <vector>

int main() {
    std::cout << "=== 图像读写显示高级操作 ===\n" << std::endl;
    
    // ============================================
    // 1. 多种方式读取图像
    // ============================================
    
    // 1.1 常用加载模式
    cv::Mat img_color = cv::imread("test.jpg", cv::IMREAD_COLOR);        // 彩色图像 (BGR)
    cv::Mat img_grayscale = cv::imread("test.jpg", cv::IMREAD_GRAYSCALE); // 灰度图像
    cv::Mat img_unchanged = cv::imread("test.jpg", cv::IMREAD_UNCHANGED); // 包含Alpha通道
    
    // 1.2 其他加载模式
    cv::Mat img_anycolor = cv::imread("test.jpg", cv::IMREAD_ANYCOLOR);   // 任意颜色
    cv::Mat img_anydepth = cv::imread("test.jpg", cv::IMREAD_ANYDEPTH);   // 任意深度
    
    // 1.3 加载模式组合
    cv::Mat img_red_blue = cv::imread("test.jpg", cv::IMREAD_REDUCED_COLOR_2); // 降低颜色分辨率
    
    // 检查图像是否加载成功
    if (img_color.empty()) {
        std::cout << "错误：无法加载图像！" << std::endl;
        std::cout << "请检查：" << std::endl;
        std::cout << "1. 文件路径是否正确" << std::endl;
        std::cout << "2. 文件是否存在" << std::endl;
        std::cout << "3. 文件权限" << std::endl;
        return -1;
    }
    
    std::cout << "1. 图像加载成功！" << std::endl;
    std::cout << "   彩色图像尺寸: " << img_color.cols << "×" << img_color.rows << std::endl;
    std::cout << "   灰度图像尺寸: " << img_grayscale.cols << "×" << img_grayscale.rows << std::endl;
    
    // ============================================
    // 2. 高级窗口管理
    // ============================================
    
    // 2.1 创建可调整大小的窗口
    cv::namedWindow("彩色图像", cv::WINDOW_NORMAL);
    cv::namedWindow("灰度图像", cv::WINDOW_AUTOSIZE);
    cv::namedWindow("原始尺寸", cv::WINDOW_KEEPRATIO);
    
    // 2.2 设置窗口位置
    cv::moveWindow("彩色图像", 100, 100);
    cv::moveWindow("灰度图像", 600, 100);
    
    // 2.3 调整窗口大小
    cv::resizeWindow("彩色图像", 400, 300);
    
    // 2.4 全屏显示
    cv::namedWindow("全屏显示", cv::WINDOW_FULLSCREEN);
    
    // 显示图像
    cv::imshow("彩色图像", img_color);
    cv::imshow("灰度图像", img_grayscale);
    
    // ============================================
    // 3. 等待按键的高级用法
    // ============================================
    
    std::cout << "\n2. 窗口控制指令：" << std::endl;
    std::cout << "   ESC - 退出程序" << std::endl;
    std::cout << "   s   - 保存图像" << std::endl;
    std::cout << "   c   - 转换为灰度并显示" << std::endl;
    std::cout << "   r   - 重置为原始图像" << std::endl;
    
    bool show_color = true;
    cv::Mat current_img = img_color.clone();
    
    while (true) {
        if (show_color) {
            cv::imshow("彩色图像", current_img);
        } else {
            cv::Mat gray;
            cv::cvtColor(current_img, gray, cv::COLOR_BGR2GRAY);
            cv::imshow("彩色图像", gray);
        }
        
        int key = cv::waitKey(30);  // 等待30ms
        
        if (key == 27) {  // ESC键
            std::cout << "程序退出" << std::endl;
            break;
        } else if (key == 's' || key == 'S') {
            // 保存图像
            std::string filename = "saved_image_" + 
                                  std::to_string(time(0)) + ".jpg";
            
            // 设置保存参数
            std::vector<int> compression_params;
            compression_params.push_back(cv::IMWRITE_JPEG_QUALITY);
            compression_params.push_back(95);  // 质量95%
            
            bool success = cv::imwrite(filename, current_img, compression_params);
            
            if (success) {
                std::cout << "图像已保存: " << filename << std::endl;
            } else {
                std::cout << "保存失败！" << std::endl;
            }
            
        } else if (key == 'c' || key == 'C') {
            show_color = false;
            std::cout << "显示灰度图像" << std::endl;
            
        } else if (key == 'r' || key == 'R') {
            show_color = true;
            current_img = img_color.clone();
            std::cout << "重置为原始彩色图像" << std::endl;
            
        } else if (key == 'g' || key == 'G') {
            // 应用高斯模糊
            cv::GaussianBlur(current_img, current_img, cv::Size(15, 15), 0);
            std::cout << "应用高斯模糊" << std::endl;
            
        } else if (key >= 0) {
            std::cout << "按键: " << char(key) << " (ASCII: " << key << ")" << std::endl;
        }
    }
    
    // ============================================
    // 4. 图像保存高级选项
    // ============================================
    
    std::cout << "\n3. 图像保存测试：" << std::endl;
    
    // 4.1 JPEG保存（支持质量参数）
    std::vector<int> jpeg_params;
    jpeg_params.push_back(cv::IMWRITE_JPEG_QUALITY);
    jpeg_params.push_back(90);  // 质量90%
    jpeg_params.push_back(cv::IMWRITE_JPEG_PROGRESSIVE);
    jpeg_params.push_back(1);   // 渐进式JPEG
    jpeg_params.push_back(cv::IMWRITE_JPEG_OPTIMIZE);
    jpeg_params.push_back(1);   // 优化编码
    
    cv::imwrite("output_high_quality.jpg", img_color, jpeg_params);
    std::cout << "   已保存高质量JPEG" << std::endl;
    
    // 4.2 PNG保存（支持压缩级别）
    std::vector<int> png_params;
    png_params.push_back(cv::IMWRITE_PNG_COMPRESSION);
    png_params.push_back(6);  // 压缩级别0-9
    png_params.push_back(cv::IMWRITE_PNG_STRATEGY);
    png_params.push_back(cv::IMWRITE_PNG_STRATEGY_DEFAULT);
    
    cv::imwrite("output_compressed.png", img_color, png_params);
    std::cout << "   已保存PNG图像" << std::endl;
    
    // 4.3 WebP保存（现代格式）
    std::vector<int> webp_params;
    webp_params.push_back(cv::IMWRITE_WEBP_QUALITY);
    webp_params.push_back(90);  // 质量0-100
    
    cv::imwrite("output_modern.webp", img_color, webp_params);
    std::cout << "   已保存WebP图像" << std::endl;
    
    // 4.4 多页TIFF保存
    std::vector<cv::Mat> tiff_pages;
    tiff_pages.push_back(img_color);
    tiff_pages.push_back(img_grayscale);
    
    cv::imwrite("output_multi_page.tiff", tiff_pages);
    std::cout << "   已保存多页TIFF" << std::endl;
    
    // ============================================
    // 5. 图像批量处理
    // ============================================
    
    // 5.1 读取文件夹中所有图像（需要额外的库如dirent.h）
    // 这里演示多个图像文件的处理
    
    std::cout << "\n4. 图像批量处理示例：" << std::endl;
    
    // 创建示例图像
    std::vector<cv::Mat> image_batch;
    for (int i = 0; i < 5; i++) {
        cv::Mat synthetic_img(300, 400, CV_8UC3);
        cv::randu(synthetic_img, cv::Scalar(0, 0, 0), cv::Scalar(255, 255, 255));
        image_batch.push_back(synthetic_img);
        
        // 保存到临时文件
        std::string batch_name = "batch_img_" + std::to_string(i) + ".png";
        cv::imwrite(batch_name, synthetic_img);
    }
    
    // 批量读取和处理
    std::cout << "   处理批量图像：" << std::endl;
    for (int i = 0; i < 5; i++) {
        std::string filename = "batch_img_" + std::to_string(i) + ".png";
        cv::Mat img = cv::imread(filename);
        
        if (!img.empty()) {
            // 简单的处理：调整大小和添加文字
            cv::Mat resized;
            cv::resize(img, resized, cv::Size(200, 150));
            
            std::string text = "Image " + std::to_string(i + 1);
            cv::putText(resized, text, cv::Point(10, 20),
                       cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 255, 255), 1);
            
            std::string output_name = "processed_" + std::to_string(i) + ".jpg";
            cv::imwrite(output_name, resized);
            
            std::cout << "     已处理: " << output_name << std::endl;
        }
    }
    
    // ============================================
    // 6. 清理临时文件
    // ============================================
    
    // 在实际应用中，可能需要删除临时文件
    for (int i = 0; i < 5; i++) {
        std::string temp_name = "batch_img_" + std::to_string(i) + ".png";
        remove(temp_name.c_str());
    }
    
    std::cout << "\n5. 清理完成，程序结束。" << std::endl;
    
    cv::destroyAllWindows();
    return 0;
}
```

### 1.2 图像属性获取与像素遍历

#### 讲解
深入了解图像的内在属性对于图像处理至关重要。OpenCV提供了多种获取图像信息和遍历像素的方法，各有优劣，适用于不同场景。

#### 核心属性与方法

| 方法 | 说明 | 时间复杂度 | 适用场景 |
|------|------|------------|----------|
| `size()` | 获取图像尺寸 | O(1) | 快速获取尺寸 |
| `type()` | 获取图像类型 | O(1) | 检查数据类型 |
| `channels()` | 获取通道数 | O(1) | 颜色空间判断 |
| `depth()` | 获取深度 | O(1) | 精度检查 |
| `at<T>()` | 安全访问 | O(1) | 随机访问 |
| `ptr<T>()` | 指针访问 | O(1) | 逐行处理 |
| `forEach()` | 并行遍历 | O(n)/多线程 | 批量处理 |
| `data` | 原始指针 | O(1) | 连续内存操作 |

#### 属性获取与遍历

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>
#include <chrono>
#include <vector>

// 像素处理函数类型
typedef void (*PixelProcessor)(cv::Mat&, void*);

// 1. 使用at<>()访问像素 - 最安全但较慢
void processWithAt(cv::Mat& image, void* params) {
    double* factor = static_cast<double*>(params);
    
    if (image.channels() == 3) {
        // 彩色图像处理
        for (int y = 0; y < image.rows; y++) {
            for (int x = 0; x < image.cols; x++) {
                cv::Vec3b& pixel = image.at<cv::Vec3b>(y, x);
                pixel[0] = cv::saturate_cast<uchar>(pixel[0] * factor[0]); // B
                pixel[1] = cv::saturate_cast<uchar>(pixel[1] * factor[1]); // G
                pixel[2] = cv::saturate_cast<uchar>(pixel[2] * factor[2]); // R
            }
        }
    } else if (image.channels() == 1) {
        // 灰度图像处理
        for (int y = 0; y < image.rows; y++) {
            for (int x = 0; x < image.cols; x++) {
                uchar& pixel = image.at<uchar>(y, x);
                pixel = cv::saturate_cast<uchar>(pixel * factor[0]);
            }
        }
    }
}

// 2. 使用ptr<>()访问像素 - 速度较快
void processWithPtr(cv::Mat& image, void* params) {
    double* factor = static_cast<double*>(params);
    int channels = image.channels();
    
    for (int y = 0; y < image.rows; y++) {
        uchar* row = image.ptr<uchar>(y);
        
        if (channels == 3) {
            for (int x = 0; x < image.cols; x++) {
                row[x * 3] = cv::saturate_cast<uchar>(row[x * 3] * factor[0]);     // B
                row[x * 3 + 1] = cv::saturate_cast<uchar>(row[x * 3 + 1] * factor[1]); // G
                row[x * 3 + 2] = cv::saturate_cast<uchar>(row[x * 3 + 2] * factor[2]); // R
            }
        } else if (channels == 1) {
            for (int x = 0; x < image.cols; x++) {
                row[x] = cv::saturate_cast<uchar>(row[x] * factor[0]);
            }
        }
    }
}

// 3. 使用data指针 - 最快但需要确保连续内存
void processWithData(cv::Mat& image, void* params) {
    double* factor = static_cast<double*>(params);
    
    if (image.isContinuous()) {
        int total = image.rows * image.cols * image.channels();
        uchar* data = image.data;
        
        if (image.channels() == 3) {
            for (int i = 0; i < total; i += 3) {
                data[i] = cv::saturate_cast<uchar>(data[i] * factor[0]);     // B
                data[i + 1] = cv::saturate_cast<uchar>(data[i + 1] * factor[1]); // G
                data[i + 2] = cv::saturate_cast<uchar>(data[i + 2] * factor[2]); // R
            }
        } else if (image.channels() == 1) {
            for (int i = 0; i < total; i++) {
                data[i] = cv::saturate_cast<uchar>(data[i] * factor[0]);
            }
        }
    } else {
        // 如果不是连续内存，回退到ptr方法
        processWithPtr(image, params);
    }
}

// 4. 使用forEach并行处理 - 现代OpenCV推荐
void processWithForEach(cv::Mat& image, void* params) {
    double* factor = static_cast<double*>(params);
    
    if (image.channels() == 3) {
        image.forEach<cv::Vec3b>([factor](cv::Vec3b& pixel, const int* position) {
            pixel[0] = cv::saturate_cast<uchar>(pixel[0] * factor[0]);
            pixel[1] = cv::saturate_cast<uchar>(pixel[1] * factor[1]);
            pixel[2] = cv::saturate_cast<uchar>(pixel[2] * factor[2]);
        });
    } else if (image.channels() == 1) {
        image.forEach<uchar>([factor](uchar& pixel, const int* position) {
            pixel = cv::saturate_cast<uchar>(pixel * factor[0]);
        });
    }
}

// 5. 使用迭代器 - STL风格
void processWithIterator(cv::Mat& image, void* params) {
    double* factor = static_cast<double*>(params);
    
    if (image.channels() == 3) {
        cv::MatIterator_<cv::Vec3b> it = image.begin<cv::Vec3b>();
        cv::MatIterator_<cv::Vec3b> end = image.end<cv::Vec3b>();
        
        for (; it != end; ++it) {
            (*it)[0] = cv::saturate_cast<uchar>((*it)[0] * factor[0]);
            (*it)[1] = cv::saturate_cast<uchar>((*it)[1] * factor[1]);
            (*it)[2] = cv::saturate_cast<uchar>((*it)[2] * factor[2]);
        }
    } else if (image.channels() == 1) {
        cv::MatIterator_<uchar> it = image.begin<uchar>();
        cv::MatIterator_<uchar> end = image.end<uchar>();
        
        for (; it != end; ++it) {
            *it = cv::saturate_cast<uchar>(*it * factor[0]);
        }
    }
}

// 性能测试函数
void benchmarkPixelAccess(cv::Mat& image, const std::string& method_name, 
                         PixelProcessor processor, void* params) {
    // 创建副本进行测试
    cv::Mat test_image = image.clone();
    
    auto start = std::chrono::high_resolution_clock::now();
    processor(test_image, params);
    auto end = std::chrono::high_resolution_clock::now();
    
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
    
    std::cout << "  " << method_name << ": " << duration.count() << " ms" << std::endl;
}

// 显示图像信息
void displayImageInfo(const cv::Mat& image, const std::string& name) {
    std::cout << "\n[" << name << " 信息]" << std::endl;
    std::cout << "  - 尺寸: " << image.cols << " × " << image.rows << " 像素" << std::endl;
    std::cout << "  - 通道数: " << image.channels() << std::endl;
    std::cout << "  - 类型: ";
    
    int type = image.type();
    switch(type) {
        case CV_8UC1: std::cout << "CV_8UC1 (8位无符号单通道)"; break;
        case CV_8UC3: std::cout << "CV_8UC3 (8位无符号三通道)"; break;
        case CV_32FC1: std::cout << "CV_32FC1 (32位浮点单通道)"; break;
        case CV_32FC3: std::cout << "CV_32FC3 (32位浮点三通道)"; break;
        default: std::cout << "类型: " << type; break;
    }
    
    std::cout << "\n  - 深度: " << image.depth() << "位" << std::endl;
    std::cout << "  - 总像素: " << image.total() << std::endl;
    std::cout << "  - 连续存储: " << (image.isContinuous() ? "是" : "否") << std::endl;
    
    // 计算内存占用
    size_t memory = image.total() * image.elemSize();
    if (memory < 1024) {
        std::cout << "  - 内存: " << memory << " 字节" << std::endl;
    } else if (memory < 1024 * 1024) {
        std::cout << "  - 内存: " << memory / 1024.0 << " KB" << std::endl;
    } else {
        std::cout << "  - 内存: " << memory / (1024.0 * 1024.0) << " MB" << std::endl;
    }
    
    // 获取统计信息
    cv::Scalar mean, stddev;
    cv::meanStdDev(image, mean, stddev);
    
    std::cout << "  - 均值: " << mean << std::endl;
    std::cout << "  - 标准差: " << stddev << std::endl;
}

int main() {
    std::cout << "=== 图像属性获取与像素遍历优化 ===\n" << std::endl;
    
    // ============================================
    // 1. 创建测试图像
    // ============================================
    
    std::cout << "1. 创建测试图像..." << std::endl;
    
    // 1.1 彩色图像
    cv::Mat color_image(800, 1200, CV_8UC3);
    
    // 创建渐变效果
    for (int y = 0; y < color_image.rows; y++) {
        for (int x = 0; x < color_image.cols; x++) {
            cv::Vec3b& pixel = color_image.at<cv::Vec3b>(y, x);
            pixel[0] = static_cast<uchar>(255.0 * x / color_image.cols);      // 蓝色渐变
            pixel[1] = static_cast<uchar>(255.0 * y / color_image.rows);      // 绿色渐变
            pixel[2] = static_cast<uchar>(255.0 * (1.0 - x / (double)color_image.cols)); // 红色渐变
        }
    }
    
    // 1.2 灰度图像
    cv::Mat gray_image(800, 1200, CV_8UC1);
    for (int y = 0; y < gray_image.rows; y++) {
        for (int x = 0; x < gray_image.cols; x++) {
            gray_image.at<uchar>(y, x) = static_cast<uchar>(
                128 + 127 * sin(x * 0.01) * cos(y * 0.01)
            );
        }
    }
    
    // 1.3 浮点图像（用于精度计算）
    cv::Mat float_image(400, 600, CV_32FC3);
    cv::randu(float_image, 0.0, 1.0);
    
    // ============================================
    // 2. 显示图像信息
    // ============================================
    
    displayImageInfo(color_image, "彩色测试图像");
    displayImageInfo(gray_image, "灰度测试图像");
    displayImageInfo(float_image, "浮点测试图像");
    
    // ============================================
    // 3. 像素访问性能基准测试
    // ============================================
    
    std::cout << "\n2. 像素访问方法性能对比" << std::endl;
    std::cout << "   图像尺寸: " << color_image.cols << "×" << color_image.rows << std::endl;
    
    // 测试参数：调整亮度
    double color_factors[3] = {1.2, 1.0, 0.8};  // B, G, R
    double gray_factor[1] = {1.5};
    
    std::cout << "\n彩色图像处理：" << std::endl;
    benchmarkPixelAccess(color_image, "at<>()方法", processWithAt, color_factors);
    benchmarkPixelAccess(color_image, "ptr<>()方法", processWithPtr, color_factors);
    benchmarkPixelAccess(color_image, "data指针方法", processWithData, color_factors);
    benchmarkPixelAccess(color_image, "forEach方法", processWithForEach, color_factors);
    benchmarkPixelAccess(color_image, "迭代器方法", processWithIterator, color_factors);
    
    std::cout << "\n灰度图像处理：" << std::endl;
    benchmarkPixelAccess(gray_image, "at<>()方法", processWithAt, gray_factor);
    benchmarkPixelAccess(gray_image, "ptr<>()方法", processWithPtr, gray_factor);
    benchmarkPixelAccess(gray_image, "data指针方法", processWithData, gray_factor);
    benchmarkPixelAccess(gray_image, "forEach方法", processWithForEach, gray_factor);
    benchmarkPixelAccess(gray_image, "迭代器方法", processWithIterator, gray_factor);
    
    // ============================================
    // 4. 像素级操作实战
    // ============================================
    
    std::cout << "\n3. 像素级操作实战" << std::endl;
    
    // 4.1 创建ROI（感兴趣区域）
    cv::Rect roi_rect(200, 150, 400, 300);
    cv::Mat roi = color_image(roi_rect);
    
    std::cout << "   ROI区域: (" << roi_rect.x << ", " << roi_rect.y 
              << ", " << roi_rect.width << ", " << roi_rect.height << ")" << std::endl;
    
    // 4.2 在ROI上绘制渐变
    for (int y = 0; y < roi.rows; y++) {
        uchar* row = roi.ptr<uchar>(y);
        for (int x = 0; x < roi.cols * 3; x += 3) {
            // 创建彩虹渐变
            int index = x / 3;
            row[x] = static_cast<uchar>(255 * (1.0 - (double)index / roi.cols));     // B
            row[x + 1] = static_cast<uchar>(255 * (double)y / roi.rows);           // G
            row[x + 2] = static_cast<uchar>(255 * (double)index / roi.cols);       // R
        }
    }
    
    // 4.3 像素值统计
    cv::Mat roi_gray;
    cv::cvtColor(roi, roi_gray, cv::COLOR_BGR2GRAY);
    
    double min_val, max_val;
    cv::Point min_loc, max_loc;
    cv::minMaxLoc(roi_gray, &min_val, &max_val, &min_loc, &max_loc);
    
    std::cout << "\n   ROI统计信息：" << std::endl;
    std::cout << "     最小值: " << min_val << " 在位置 (" << min_loc.x << ", " << min_loc.y << ")" << std::endl;
    std::cout << "     最大值: " << max_val << " 在位置 (" << max_loc.x << ", " << max_loc.y << ")" << std::endl;
    
    // 4.4 创建直方图（简化版）
    std::cout << "     像素值分布: ";
    int bins[10] = {0};
    for (int y = 0; y < roi_gray.rows; y++) {
        const uchar* row = roi_gray.ptr<uchar>(y);
        for (int x = 0; x < roi_gray.cols; x++) {
            int bin = row[x] / 26;  // 256/10 ≈ 26
            if (bin >= 10) bin = 9;
            bins[bin]++;
        }
    }
    
    for (int i = 0; i < 10; i++) {
        std::cout << bins[i] << " ";
    }
    std::cout << std::endl;
    
    // ============================================
    // 5. 显示结果
    // ============================================
    
    // 5.1 创建显示窗口
    cv::namedWindow("原始彩色图像", cv::WINDOW_NORMAL);
    cv::namedWindow("ROI区域", cv::WINDOW_NORMAL);
    cv::namedWindow("灰度图像", cv::WINDOW_NORMAL);
    cv::namedWindow("处理对比", cv::WINDOW_NORMAL);
    
    // 5.2 调整窗口大小
    cv::resizeWindow("原始彩色图像", 600, 400);
    cv::resizeWindow("ROI区域", 400, 300);
    cv::resizeWindow("灰度图像", 600, 400);
    
    // 5.3 在图像上标记信息
    cv::Mat annotated = color_image.clone();
    
    // 标记ROI区域
    cv::rectangle(annotated, roi_rect, cv::Scalar(0, 255, 255), 2);
    
    // 标记最大值位置
    cv::Point global_max_loc(max_loc.x + roi_rect.x, max_loc.y + roi_rect.y);
    cv::circle(annotated, global_max_loc, 10, cv::Scalar(0, 0, 255), 2);
    cv::putText(annotated, "Max: " + std::to_string(int(max_val)), 
                cv::Point(global_max_loc.x + 15, global_max_loc.y - 10),
                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(0, 0, 255), 1);
    
    // 标记最小值位置
    cv::Point global_min_loc(min_loc.x + roi_rect.x, min_loc.y + roi_rect.y);
    cv::circle(annotated, global_min_loc, 10, cv::Scalar(255, 0, 0), 2);
    cv::putText(annotated, "Min: " + std::to_string(int(min_val)), 
                cv::Point(global_min_loc.x + 15, global_min_loc.y - 10),
                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 0, 0), 1);
    
    // 添加图像信息文本
    std::string info_text = "Size: " + std::to_string(color_image.cols) + 
                          "x" + std::to_string(color_image.rows) +
                          "  Channels: " + std::to_string(color_image.channels());
    cv::putText(annotated, info_text, cv::Point(10, 30),
                cv::FONT_HERSHEY_SIMPLEX, 0.7, cv::Scalar(255, 255, 255), 2);
    
    // 5.4 显示处理对比
    cv::Mat processed;
    cv::cvtColor(color_image, processed, cv::COLOR_BGR2GRAY);
    cv::cvtColor(processed, processed, cv::COLOR_GRAY2BGR);
    
    // 创建并排显示
    cv::Mat side_by_side(color_image.rows, color_image.cols * 2, CV_8UC3);
    color_image.copyTo(side_by_side(cv::Rect(0, 0, color_image.cols, color_image.rows)));
    processed.copyTo(side_by_side(cv::Rect(color_image.cols, 0, color_image.cols, color_image.rows)));
    
    // 添加标签
    cv::putText(side_by_side, "Original", cv::Point(20, 40),
                cv::FONT_HERSHEY_SIMPLEX, 1.2, cv::Scalar(0, 255, 255), 2);
    cv::putText(side_by_side, "Processed", cv::Point(color_image.cols + 20, 40),
                cv::FONT_HERSHEY_SIMPLEX, 1.2, cv::Scalar(0, 255, 255), 2);
    
    // 5.5 显示所有窗口
    cv::imshow("原始彩色图像", annotated);
    cv::imshow("ROI区域", roi);
    cv::imshow("灰度图像", gray_image);
    cv::imshow("处理对比", side_by_side);
    
    // 5.6 等待按键
    std::cout << "\n4. 显示窗口中..." << std::endl;
    std::cout << "   按ESC键退出，按's'保存图像" << std::endl;
    
    while (true) {
        int key = cv::waitKey(0);
        
        if (key == 27) {  // ESC
            break;
        } else if (key == 's' || key == 'S') {
            cv::imwrite("annotated_result.jpg", annotated);
            cv::imwrite("side_by_side.jpg", side_by_side);
            cv::imwrite("roi_region.jpg", roi);
            std::cout << "   图像已保存！" << std::endl;
        }
    }
    
    cv::destroyAllWindows();
    std::cout << "\n程序结束。" << std::endl;
    
    return 0;
}
```

### 1.3 图像基础变换与几何操作

#### 讲解
图像变换是图像处理的核心，包括缩放、旋转、翻转、裁剪等操作。这些变换在计算机视觉、图像编辑和显示中都有广泛应用。

#### 核心变换方法

| 方法 | 说明 | 主要参数 |
|------|------|----------|
| `resize()` | 调整图像尺寸 | `src`, `dst`, `dsize`, `fx`, `fy`, `interpolation` |
| `rotate()` | 旋转图像 | `src`, `dst`, `rotateCode` |
| `flip()` | 翻转图像 | `src`, `dst`, `flipCode` |
| `warpAffine()` | 仿射变换 | `src`, `dst`, `M`, `dsize` |
| `warpPerspective()` | 透视变换 | `src`, `dst`, `M`, `dsize` |
| `getRotationMatrix2D()` | 获取旋转矩阵 | `center`, `angle`, `scale` |
| `getAffineTransform()` | 获取仿射变换矩阵 | `src`, `dst` |
| `getPerspectiveTransform()` | 获取透视变换矩阵 | `src`, `dst` |

#### 插值方法说明

| 插值方法 | 说明 | 速度 | 质量 |
|----------|------|------|------|
| `INTER_NEAREST` | 最近邻插值 | 最快 | 低 |
| `INTER_LINEAR` | 双线性插值 | 快 | 中等 |
| `INTER_CUBIC` | 双三次插值 | 较慢 | 高 |
| `INTER_LANCZOS4` | Lanczos插值 | 慢 | 很高 |
| `INTER_AREA` | 区域插值 | 中等 | 适合缩小 |

#### 变换操作实战

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>
#include <vector>

// 显示图像信息
void showImageInfo(const cv::Mat& img, const std::string& name) {
    std::cout << name << ": " << img.cols << "×" << img.rows 
              << " (" << img.channels() << " channels)" << std::endl;
}

int main() {
    std::cout << "=== 图像基础变换与几何操作 ===\n" << std::endl;
    
    // ============================================
    // 1. 创建测试图像
    // ============================================
    
    std::cout << "1. 创建测试图像..." << std::endl;
    cv::Mat original(400, 600, CV_8UC3);
    
    // 创建棋盘图案
    int square_size = 50;
    for (int y = 0; y < original.rows; y++) {
        for (int x = 0; x < original.cols; x++) {
            int square_x = x / square_size;
            int square_y = y / square_size;
            
            if ((square_x + square_y) % 2 == 0) {
                original.at<cv::Vec3b>(y, x) = cv::Vec3b(255, 255, 255); // 白色
            } else {
                original.at<cv::Vec3b>(y, x) = cv::Vec3b(0, 0, 0);       // 黑色
            }
        }
    }
    
    // 在中心添加彩色圆形
    cv::Point center(original.cols / 2, original.rows / 2);
    cv::circle(original, center, 100, cv::Scalar(0, 0, 255), -1);  // 红色圆形
    cv::circle(original, center, 80, cv::Scalar(0, 255, 0), -1);   // 绿色圆形
    cv::circle(original, center, 60, cv::Scalar(255, 0, 0), -1);   // 蓝色圆形
    
    showImageInfo(original, "原始图像");
    
    // ============================================
    // 2. 图像缩放（resize）
    // ============================================
    
    std::cout << "\n2. 图像缩放操作" << std::endl;
    
    cv::Mat resized_nearest, resized_linear, resized_cubic, resized_area;
    
    // 2.1 指定目标尺寸
    cv::resize(original, resized_nearest, cv::Size(300, 200), 0, 0, cv::INTER_NEAREST);
    cv::resize(original, resized_linear, cv::Size(300, 200), 0, 0, cv::INTER_LINEAR);
    cv::resize(original, resized_cubic, cv::Size(300, 200), 0, 0, cv::INTER_CUBIC);
    cv::resize(original, resized_area, cv::Size(300, 200), 0, 0, cv::INTER_AREA);
    
    // 2.2 使用缩放因子
    cv::Mat scaled_half, scaled_double;
    cv::resize(original, scaled_half, cv::Size(), 0.5, 0.5, cv::INTER_LINEAR);
    cv::resize(original, scaled_double, cv::Size(), 2.0, 2.0, cv::INTER_LINEAR);
    
    showImageInfo(resized_linear, "   缩放至300×200");
    showImageInfo(scaled_half, "   缩放至一半尺寸");
    showImageInfo(scaled_double, "   放大至两倍尺寸");
    
    // 2.3 非均匀缩放（不同的x,y缩放因子）
    cv::Mat scaled_nonuniform;
    cv::resize(original, scaled_nonuniform, cv::Size(), 0.7, 1.5, cv::INTER_LINEAR);
    showImageInfo(scaled_nonuniform, "   非均匀缩放(0.7×1.5)");
    
    // ============================================
    // 3. 图像翻转（flip）
    // ============================================
    
    std::cout << "\n3. 图像翻转操作" << std::endl;
    
    cv::Mat flipped_horizontal, flipped_vertical, flipped_both;
    
    // 3.1 水平翻转（镜像）
    cv::flip(original, flipped_horizontal, 1);  // flipCode > 0: 水平翻转
    
    // 3.2 垂直翻转
    cv::flip(original, flipped_vertical, 0);    // flipCode = 0: 垂直翻转
    
    // 3.3 同时水平和垂直翻转
    cv::flip(original, flipped_both, -1);       // flipCode < 0: 两者都翻转
    
    std::cout << "   水平翻转: flipCode = 1" << std::endl;
    std::cout << "   垂直翻转: flipCode = 0" << std::endl;
    std::cout << "   双向翻转: flipCode = -1" << std::endl;
    
    // ============================================
    // 4. 图像旋转（rotate）
    // ============================================
    
    std::cout << "\n4. 图像旋转操作" << std::endl;
    
    cv::Mat rotated_90, rotated_180, rotated_270;
    
    // 4.1 使用rotate函数（仅支持90度的倍数）
    cv::rotate(original, rotated_90, cv::ROTATE_90_CLOCKWISE);        // 顺时针90度
    cv::rotate(original, rotated_180, cv::ROTATE_180);                // 180度
    cv::rotate(original, rotated_270, cv::ROTATE_90_COUNTERCLOCKWISE); // 逆时针90度
    
    // 4.2 任意角度旋转（使用warpAffine）
    cv::Mat rotated_45;
    cv::Point2f center_point(original.cols / 2.0f, original.rows / 2.0f);
    cv::Mat rot_mat = cv::getRotationMatrix2D(center_point, 45.0, 1.0);
    cv::warpAffine(original, rotated_45, rot_mat, original.size());
    
    // 4.3 旋转并缩放
    cv::Mat rotated_scaled;
    cv::Mat rot_mat_scaled = cv::getRotationMatrix2D(center_point, 30.0, 0.7);
    cv::warpAffine(original, rotated_scaled, rot_mat_scaled, original.size());
    
    std::cout << "   90度旋转: 尺寸 " << rotated_90.cols << "×" << rotated_90.rows << std::endl;
    std::cout << "   45度旋转: 尺寸不变" << std::endl;
    std::cout << "   30度旋转+缩放0.7倍" << std::endl;
    
    // ============================================
    // 5. 图像裁剪（使用Rect）
    // ============================================
    
    std::cout << "\n5. 图像裁剪操作" << std::endl;
    
    // 5.1 直接指定矩形区域
    cv::Rect crop_rect(150, 100, 300, 200);  // (x, y, width, height)
    cv::Mat cropped = original(crop_rect);
    
    // 5.2 使用Range裁剪
    cv::Mat cropped_range = original(cv::Range(100, 300), cv::Range(150, 450));
    
    // 5.3 保持宽高比的裁剪
    int crop_size = std::min(original.cols, original.rows);
    cv::Rect square_crop((original.cols - crop_size) / 2, 
                         (original.rows - crop_size) / 2, 
                         crop_size, crop_size);
    cv::Mat cropped_square = original(square_crop);
    
    showImageInfo(cropped, "   矩形裁剪");
    showImageInfo(cropped_range, "   Range裁剪");
    showImageInfo(cropped_square, "   方形裁剪");
    
    // ============================================
    // 6. 仿射变换
    // ============================================
    
    std::cout << "\n6. 仿射变换" << std::endl;
    
    // 6.1 定义源点（原始图像的三个点）
    std::vector<cv::Point2f> src_points;
    src_points.push_back(cv::Point2f(0, 0));
    src_points.push_back(cv::Point2f(original.cols - 1, 0));
    src_points.push_back(cv::Point2f(0, original.rows - 1));
    
    // 6.2 定义目标点（变换后的三个点）
    std::vector<cv::Point2f> dst_points;
    dst_points.push_back(cv::Point2f(50, 50));                        // 左上角向右下移动
    dst_points.push_back(cv::Point2f(original.cols - 50, 100));       // 右上角
    dst_points.push_back(cv::Point2f(100, original.rows - 50));       // 左下角
    
    // 6.3 计算仿射变换矩阵
    cv::Mat affine_mat = cv::getAffineTransform(src_points, dst_points);
    
    // 6.4 应用仿射变换
    cv::Mat affine_result;
    cv::warpAffine(original, affine_result, affine_mat, original.size());
    
    std::cout << "   仿射变换矩阵:" << std::endl;
    std::cout << affine_mat << std::endl;
    
    // ============================================
    // 7. 透视变换
    // ============================================
    
    std::cout << "\n7. 透视变换（模拟3D效果）" << std::endl;
    
    // 7.1 定义源图像的四个角点
    std::vector<cv::Point2f> src_corners;
    src_corners.push_back(cv::Point2f(0, 0));
    src_corners.push_back(cv::Point2f(original.cols - 1, 0));
    src_corners.push_back(cv::Point2f(original.cols - 1, original.rows - 1));
    src_corners.push_back(cv::Point2f(0, original.rows - 1));
    
    // 7.2 定义透视变换后的四个点（模拟3D倾斜）
    std::vector<cv::Point2f> dst_corners;
    dst_corners.push_back(cv::Point2f(0, 0));
    dst_corners.push_back(cv::Point2f(original.cols - 1, 50));
    dst_corners.push_back(cv::Point2f(original.cols - 50, original.rows - 1));
    dst_corners.push_back(cv::Point2f(50, original.rows - 1));
    
    // 7.3 计算透视变换矩阵
    cv::Mat perspective_mat = cv::getPerspectiveTransform(src_corners, dst_corners);
    
    // 7.4 应用透视变换
    cv::Mat perspective_result;
    cv::warpPerspective(original, perspective_result, perspective_mat, original.size());
    
    // ============================================
    // 8. 复合变换
    // ============================================
    
    std::cout << "\n8. 复合变换（缩放+旋转+平移）" << std::endl;
    
    cv::Mat composite_result;
    
    // 8.1 创建缩放矩阵
    cv::Mat scale_mat = cv::Mat::eye(3, 3, CV_64F);
    scale_mat.at<double>(0, 0) = 0.8;  // x方向缩放
    scale_mat.at<double>(1, 1) = 0.8;  // y方向缩放
    
    // 8.2 创建旋转矩阵
    double angle = 20.0 * CV_PI / 180.0;  // 转换为弧度
    cv::Mat rotate_mat = cv::Mat::eye(3, 3, CV_64F);
    rotate_mat.at<double>(0, 0) = cos(angle);
    rotate_mat.at<double>(0, 1) = -sin(angle);
    rotate_mat.at<double>(1, 0) = sin(angle);
    rotate_mat.at<double>(1, 1) = cos(angle);
    
    // 8.3 创建平移矩阵
    cv::Mat translate_mat = cv::Mat::eye(3, 3, CV_64F);
    translate_mat.at<double>(0, 2) = 50;  // x方向平移
    translate_mat.at<double>(1, 2) = 30;  // y方向平移
    
    // 8.4 组合变换矩阵（注意顺序：先缩放，再旋转，最后平移）
    cv::Mat transform_mat = translate_mat * rotate_mat * scale_mat;
    
    // 8.5 应用组合变换（取前2行用于仿射变换）
    cv::Mat affine_transform = transform_mat(cv::Rect(0, 0, 3, 2));
    cv::warpAffine(original, composite_result, affine_transform, original.size());
    
    // ============================================
    // 9. 创建显示面板
    // ============================================
    
    std::cout << "\n9. 创建结果显示面板..." << std::endl;
    
    // 9.1 创建主显示面板
    int panel_width = 1200;
    int panel_height = 800;
    cv::Mat display_panel(panel_height, panel_width, CV_8UC3, cv::Scalar(40, 40, 40));
    
    // 9.2 将各个结果缩放到统一尺寸
    int thumb_width = 280;
    int thumb_height = 210;
    
    std::vector<cv::Mat> thumbnails;
    std::vector<std::string> labels;
    
    // 原始图像
    cv::Mat thumb_original;
    cv::resize(original, thumb_original, cv::Size(thumb_width, thumb_height));
    thumbnails.push_back(thumb_original);
    labels.push_back("Original");
    
    // 缩放结果
    cv::Mat thumb_resized;
    cv::resize(resized_linear, thumb_resized, cv::Size(thumb_width, thumb_height));
    thumbnails.push_back(thumb_resized);
    labels.push_back("Resized");
    
    // 翻转结果
    cv::Mat thumb_flipped;
    cv::resize(flipped_horizontal, thumb_flipped, cv::Size(thumb_width, thumb_height));
    thumbnails.push_back(thumb_flipped);
    labels.push_back("Flipped");
    
    // 旋转结果
    cv::Mat thumb_rotated;
    cv::resize(rotated_45, thumb_rotated, cv::Size(thumb_width, thumb_height));
    thumbnails.push_back(thumb_rotated);
    labels.push_back("Rotated 45");
    
    // 裁剪结果
    cv::Mat thumb_cropped;
    cv::resize(cropped, thumb_cropped, cv::Size(thumb_width, thumb_height));
    thumbnails.push_back(thumb_cropped);
    labels.push_back("Cropped");
    
    // 仿射变换
    cv::Mat thumb_affine;
    cv::resize(affine_result, thumb_affine, cv::Size(thumb_width, thumb_height));
    thumbnails.push_back(thumb_affine);
    labels.push_back("Affine");
    
    // 透视变换
    cv::Mat thumb_perspective;
    cv::resize(perspective_result, thumb_perspective, cv::Size(thumb_width, thumb_height));
    thumbnails.push_back(thumb_perspective);
    labels.push_back("Perspective");
    
    // 复合变换
    cv::Mat thumb_composite;
    cv::resize(composite_result, thumb_composite, cv::Size(thumb_width, thumb_height));
    thumbnails.push_back(thumb_composite);
    labels.push_back("Composite");
    
    // 9.3 在面板上排列缩略图
    int cols = 3;
    int rows = (thumbnails.size() + cols - 1) / cols;
    
    for (size_t i = 0; i < thumbnails.size(); i++) {
        int row = i / cols;
        int col = i % cols;
        
        int x = col * (thumb_width + 20) + 20;
        int y = row * (thumb_height + 40) + 20;
        
        // 复制缩略图到面板
        cv::Rect roi(x, y, thumb_width, thumb_height);
        thumbnails[i].copyTo(display_panel(roi));
        
        // 添加边框
        cv::rectangle(display_panel, roi, cv::Scalar(200, 200, 200), 2);
        
        // 添加标签
        cv::putText(display_panel, labels[i], 
                   cv::Point(x + 10, y + thumb_height + 30),
                   cv::FONT_HERSHEY_SIMPLEX, 0.6, cv::Scalar(255, 255, 255), 1);
    }
    
    // 9.4 添加标题和说明
    cv::putText(display_panel, "OpenCV Image Transformations Demo", 
               cv::Point(panel_width / 2 - 250, 30),
               cv::FONT_HERSHEY_SIMPLEX, 0.8, cv::Scalar(0, 255, 255), 2);
    
    std::string info_text = "Original: " + std::to_string(original.cols) + 
                          "x" + std::to_string(original.rows);
    cv::putText(display_panel, info_text, 
               cv::Point(panel_width - 300, panel_height - 20),
               cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(180, 180, 180), 1);
    
    // ============================================
    // 10. 插值方法比较
    // ============================================
    
    std::cout << "\n10. 插值方法比较（放大4倍）" << std::endl;
    
    // 创建一个小图像用于测试插值
    cv::Mat small(50, 50, CV_8UC3);
    cv::randu(small, cv::Scalar(0, 0, 0), cv::Scalar(255, 255, 255));
    
    cv::Mat interpolations[4];
    cv::InterpolationFlags methods[4] = {
        cv::INTER_NEAREST,
        cv::INTER_LINEAR,
        cv::INTER_CUBIC,
        cv::INTER_LANCZOS4
    };
    
    std::string method_names[4] = {
        "Nearest Neighbor",
        "Bilinear",
        "Bicubic",
        "Lanczos4"
    };
    
    for (int i = 0; i < 4; i++) {
        cv::resize(small, interpolations[i], cv::Size(200, 200), 0, 0, methods[i]);
    }
    
    // 创建插值比较面板
    cv::Mat interpolation_panel(250, 900, CV_8UC3, cv::Scalar(40, 40, 40));
    
    for (int i = 0; i < 4; i++) {
        int x = i * 220 + 20;
        
        // 复制图像
        cv::Rect roi(x, 20, 200, 200);
        interpolations[i].copyTo(interpolation_panel(roi));
        
        // 添加标签
        cv::putText(interpolation_panel, method_names[i], 
                   cv::Point(x + 10, 240),
                   cv::FONT_HERSHEY_SIMPLEX, 0.6, cv::Scalar(255, 255, 255), 1);
    }
    
    cv::putText(interpolation_panel, "Interpolation Methods Comparison (50x50 -> 200x200)", 
               cv::Point(150, 15),
               cv::FONT_HERSHEY_SIMPLEX, 0.7, cv::Scalar(0, 255, 255), 1);
    
    // ============================================
    // 11. 显示结果
    // ============================================
    
    std::cout << "\n11. 显示结果..." << std::endl;
    std::cout << "    按ESC退出，按's'保存结果" << std::endl;
    
    cv::namedWindow("Image Transformations", cv::WINDOW_NORMAL);
    cv::namedWindow("Interpolation Comparison", cv::WINDOW_NORMAL);
    
    cv::resizeWindow("Image Transformations", 1200, 800);
    cv::resizeWindow("Interpolation Comparison", 900, 250);
    
    cv::imshow("Image Transformations", display_panel);
    cv::imshow("Interpolation Comparison", interpolation_panel);
    
    while (true) {
        int key = cv::waitKey(0);
        
        if (key == 27) {  // ESC
            break;
        } else if (key == 's' || key == 'S') {
            cv::imwrite("transformations_result.jpg", display_panel);
            cv::imwrite("interpolation_comparison.jpg", interpolation_panel);
            std::cout << "    结果已保存！" << std::endl;
        } else if (key == '1') {
            // 显示原始图像
            cv::imshow("Original Image", original);
        } else if (key == '2') {
            // 显示透视变换
            cv::imshow("Perspective Transform", perspective_result);
        }
    }
    
    cv::destroyAllWindows();
    std::cout << "\n程序结束。" << std::endl;
    
    return 0;
}
```

## 二、视频处理

### 2.1 视频捕获与基础操作

#### 讲解
视频处理是OpenCV的重要应用领域，包括从摄像头或视频文件读取帧、处理帧、显示结果以及保存视频。理解视频的基本属性（如FPS、编解码器）对于视频处理至关重要。

#### 核心类与方法

| 类/方法 | 说明 | 关键参数/属性 |
|---------|------|---------------|
| `VideoCapture` | 视频捕获类 | `open()`, `isOpened()`, `read()`, `get()`, `set()` |
| `VideoWriter` | 视频写入类 | `open()`, `isOpened()`, `write()`, `get()`, `set()` |
| `CAP_PROP_*` | 视频属性 | `CAP_PROP_FPS`, `CAP_PROP_FRAME_COUNT`, `CAP_PROP_POS_FRAMES` |
| `CAP_*` | 捕获后端 | `CAP_ANY`, `CAP_V4L2`, `CAP_MSMF`, `CAP_FFMPEG` |

#### 视频属性常量

| 属性常量 | 说明 | 值 |
|----------|------|-----|
| `CAP_PROP_FPS` | 帧率（帧/秒） | 5 |
| `CAP_PROP_FRAME_COUNT` | 总帧数 | 7 |
| `CAP_PROP_FRAME_WIDTH` | 帧宽度 | 3 |
| `CAP_PROP_FRAME_HEIGHT` | 帧高度 | 4 |
| `CAP_PROP_POS_FRAMES` | 当前帧位置 | 1 |
| `CAP_PROP_POS_MSEC` | 当前时间（毫秒） | 0 |
| `CAP_PROP_BRIGHTNESS` | 亮度（摄像头） | 10 |
| `CAP_PROP_CONTRAST` | 对比度（摄像头） | 11 |

#### 视频捕获实战

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>
#include <chrono>
#include <iomanip>
#include <thread>

// 视频信息结构体
struct VideoInfo {
    double fps;
    int frame_count;
    int width;
    int height;
    double duration;  // 秒
    std::string codec;
    std::string backend;
};

// 获取视频信息
VideoInfo getVideoInfo(cv::VideoCapture& cap) {
    VideoInfo info;
    
    info.fps = cap.get(cv::CAP_PROP_FPS);
    info.frame_count = static_cast<int>(cap.get(cv::CAP_PROP_FRAME_COUNT));
    info.width = static_cast<int>(cap.get(cv::CAP_PROP_FRAME_WIDTH));
    info.height = static_cast<int>(cap.get(cv::CAP_PROP_FRAME_HEIGHT));
    info.duration = info.frame_count / info.fps;
    
    // 尝试获取编解码器（四字符代码）
    int fourcc = static_cast<int>(cap.get(cv::CAP_PROP_FOURCC));
    info.codec = std::string(reinterpret_cast<char*>(&fourcc), 4);
    
    // 获取后端名称
    int backend_id = static_cast<int>(cap.get(cv::CAP_PROP_BACKEND));
    switch(backend_id) {
        case cv::CAP_ANY: info.backend = "CAP_ANY"; break;
        case cv::CAP_V4L2: info.backend = "CAP_V4L2 (Linux)"; break;
        case cv::CAP_MSMF: info.backend = "CAP_MSMF (Windows)"; break;
        case cv::CAP_FFMPEG: info.backend = "CAP_FFMPEG"; break;
        default: info.backend = "Unknown (" + std::to_string(backend_id) + ")";
    }
    
    return info;
}

// 显示视频信息
void displayVideoInfo(const VideoInfo& info, const std::string& source) {
    std::cout << "\n=== 视频信息 [" << source << "] ===" << std::endl;
    std::cout << "  尺寸: " << info.width << " × " << info.height << std::endl;
    std::cout << "  帧率: " << std::fixed << std::setprecision(2) << info.fps << " FPS" << std::endl;
    std::cout << "  总帧数: " << info.frame_count << " 帧" << std::endl;
    std::cout << "  时长: " << std::setprecision(1) << info.duration << " 秒" << std::endl;
    std::cout << "  编解码器: " << info.codec << std::endl;
    std::cout << "  后端: " << info.backend << std::endl;
}

// 摄像头控制类
class CameraController {
private:
    cv::VideoCapture cap;
    bool is_camera;
    int camera_id;
    VideoInfo info;
    
public:
    CameraController(int id = 0) : camera_id(id), is_camera(true) {
        // 尝试以不同方式打开摄像头
        std::cout << "尝试打开摄像头 #" << id << "..." << std::endl;
        
        // 方法1：默认方式
        cap.open(id, cv::CAP_ANY);
        
        if (!cap.isOpened()) {
            std::cout << "默认方式失败，尝试其他后端..." << std::endl;
            
            // 尝试不同后端
#ifdef _WIN32
            cap.open(id, cv::CAP_MSMF);  // Windows Media Foundation
#elif __linux__
            cap.open(id, cv::CAP_V4L2);  // Linux Video4Linux2
#else
            cap.open(id, cv::CAP_ANY);   // 其他系统
#endif
            
            if (!cap.isOpened()) {
                std::cerr << "错误：无法打开摄像头 #" << id << std::endl;
                return;
            }
        }
        
        std::cout << "摄像头 #" << id << " 打开成功！" << std::endl;
        
        // 获取摄像头信息
        updateInfo();
        
        // 设置摄像头参数
        setCameraProperties();
    }
    
    void updateInfo() {
        info = getVideoInfo(cap);
        info.frame_count = -1;  // 摄像头是实时流，没有总帧数
        info.duration = -1;
    }
    
    void setCameraProperties() {
        if (is_camera) {
            // 设置摄像头参数
            cap.set(cv::CAP_PROP_FRAME_WIDTH, 640);
            cap.set(cv::CAP_PROP_FRAME_HEIGHT, 480);
            cap.set(cv::CAP_PROP_FPS, 30);
            cap.set(cv::CAP_PROP_AUTOFOCUS, 1);  // 启用自动对焦
            cap.set(cv::CAP_PROP_AUTO_EXPOSURE, 1); // 自动曝光
            
            // 更新信息
            updateInfo();
        }
    }
    
    bool isOpened() const {
        return cap.isOpened();
    }
    
    VideoInfo getInfo() const {
        return info;
    }
    
    bool readFrame(cv::Mat& frame) {
        return cap.read(frame);
    }
    
    void release() {
        cap.release();
    }
    
    ~CameraController() {
        release();
    }
};

int main() {
    std::cout << "=== OpenCV 视频处理全面指南 ===\n" << std::endl;
    
    // ============================================
    // 1. 测试摄像头
    // ============================================
    
    std::cout << "1. 摄像头测试" << std::endl;
    
    CameraController camera(0);
    if (!camera.isOpened()) {
        std::cerr << "摄像头不可用，将使用测试视频" << std::endl;
        
        // 创建虚拟摄像头画面
        cv::Mat test_frame(480, 640, CV_8UC3);
        cv::randu(test_frame, cv::Scalar(0, 0, 0), cv::Scalar(255, 255, 255));
        
        // 显示测试画面
        cv::putText(test_frame, "No Camera Available", 
                   cv::Point(100, 240), cv::FONT_HERSHEY_SIMPLEX, 
                   1.0, cv::Scalar(0, 0, 255), 2);
        
        cv::imshow("Camera Test", test_frame);
        cv::waitKey(2000);
    } else {
        std::cout << "摄像头测试成功！" << std::endl;
        displayVideoInfo(camera.getInfo(), "摄像头");
        
        // 预览摄像头
        cv::namedWindow("摄像头预览", cv::WINDOW_NORMAL);
        cv::resizeWindow("摄像头预览", 640, 480);
        
        std::cout << "\n摄像头预览中..." << std::endl;
        std::cout << "按ESC退出预览" << std::endl;
        
        cv::Mat frame;
        auto start_time = std::chrono::steady_clock::now();
        int frame_count = 0;
        
        while (true) {
            if (!camera.readFrame(frame)) {
                std::cerr << "无法读取帧" << std::endl;
                break;
            }
            
            frame_count++;
            
            // 计算实时FPS
            auto current_time = std::chrono::steady_clock::now();
            double elapsed = std::chrono::duration<double>(current_time - start_time).count();
            double fps = frame_count / elapsed;
            
            // 在帧上添加信息
            std::string fps_text = "FPS: " + std::to_string(static_cast<int>(fps));
            cv::putText(frame, fps_text, cv::Point(10, 30), 
                       cv::FONT_HERSHEY_SIMPLEX, 0.8, cv::Scalar(0, 255, 0), 2);
            
            std::string size_text = "Size: " + std::to_string(frame.cols) + 
                                   "x" + std::to_string(frame.rows);
            cv::putText(frame, size_text, cv::Point(10, 60), 
                       cv::FONT_HERSHEY_SIMPLEX, 0.6, cv::Scalar(0, 255, 0), 1);
            
            cv::imshow("摄像头预览", frame);
            
            int key = cv::waitKey(1);
            if (key == 27) {  // ESC
                break;
            } else if (key == 's' || key == 'S') {
                // 保存当前帧
                std::string filename = "camera_frame_" + 
                                     std::to_string(time(0)) + ".jpg";
                cv::imwrite(filename, frame);
                std::cout << "已保存帧: " << filename << std::endl;
            }
        }
        
        camera.release();
    }
    
    cv::destroyAllWindows();
    
    // ============================================
    // 2. 视频文件处理
    // ============================================
    
    std::cout << "\n\n2. 视频文件处理" << std::endl;
    
    // 创建测试视频（如果没有现成的）
    std::string test_video = "test_video.mp4";
    
    // 检查文件是否存在
    FILE* file_check = fopen(test_video.c_str(), "r");
    if (!file_check) {
        std::cout << "创建测试视频..." << std::endl;
        
        // 创建视频写入器
        cv::VideoWriter writer;
        int fourcc = cv::VideoWriter::fourcc('H', '2', '6', '4');  // H.264编码
        bool is_color = true;
        double fps = 25.0;
        cv::Size frame_size(640, 480);
        
        writer.open(test_video, fourcc, fps, frame_size, is_color);
        
        if (!writer.isOpened()) {
            std::cout << "无法创建视频，尝试其他编码..." << std::endl;
            fourcc = cv::VideoWriter::fourcc('X', 'V', 'I', 'D');  // XVID编码
            writer.open(test_video, fourcc, fps, frame_size, is_color);
        }
        
        if (writer.isOpened()) {
            std::cout << "生成测试视频..." << std::endl;
            
            // 生成60帧测试视频
            for (int i = 0; i < 60; i++) {
                cv::Mat frame(480, 640, CV_8UC3);
                
                // 创建渐变背景
                for (int y = 0; y < frame.rows; y++) {
                    for (int x = 0; x < frame.cols; x++) {
                        cv::Vec3b& pixel = frame.at<cv::Vec3b>(y, x);
                        pixel[0] = static_cast<uchar>((x + i * 10) % 256);      // 蓝色
                        pixel[1] = static_cast<uchar>((y + i * 5) % 256);       // 绿色
                        pixel[2] = static_cast<uchar>((x + y + i * 3) % 256);   // 红色
                    }
                }
                
                // 添加移动的圆形
                cv::Point center(320 + 200 * sin(i * 0.1), 
                                240 + 150 * cos(i * 0.1));
                cv::circle(frame, center, 30, cv::Scalar(255, 255, 255), -1);
                
                // 添加帧号
                cv::putText(frame, "Frame: " + std::to_string(i + 1), 
                           cv::Point(20, 40), cv::FONT_HERSHEY_SIMPLEX, 
                           0.8, cv::Scalar(255, 255, 255), 2);
                
                // 添加时间戳
                double timestamp = i / fps;
                cv::putText(frame, "Time: " + std::to_string(timestamp) + "s", 
                           cv::Point(20, 70), cv::FONT_HERSHEY_SIMPLEX, 
                           0.6, cv::Scalar(200, 200, 200), 1);
                
                writer.write(frame);
            }
            
            writer.release();
            std::cout << "测试视频已创建: " << test_video << std::endl;
        } else {
            std::cerr << "无法创建测试视频" << std::endl;
            test_video = "";  // 使用空字符串表示失败
        }
    } else {
        fclose(file_check);
        std::cout << "找到现有视频文件: " << test_video << std::endl;
    }
    
    // ============================================
    // 3. 视频播放与控制
    // ============================================
    
    if (!test_video.empty()) {
        cv::VideoCapture video_cap(test_video);
        
        if (video_cap.isOpened()) {
            VideoInfo video_info = getVideoInfo(video_cap);
            displayVideoInfo(video_info, test_video);
            
            // 创建视频播放窗口
            cv::namedWindow("视频播放器", cv::WINDOW_NORMAL);
            cv::resizeWindow("视频播放器", 800, 600);
            
            // 创建控制面板
            cv::namedWindow("控制面板", cv::WINDOW_NORMAL);
            cv::resizeWindow("控制面板", 400, 300);
            
            cv::Mat control_panel(300, 400, CV_8UC3, cv::Scalar(50, 50, 50));
            
            // 控制变量
            bool is_playing = true;
            bool loop_video = false;
            double playback_speed = 1.0;
            int current_frame = 0;
            int frame_delay = static_cast<int>(1000.0 / video_info.fps);
            
            // 处理参数
            bool apply_filter = false;
            bool show_info = true;
            bool save_frames = false;
            
            std::cout << "\n3. 视频播放控制" << std::endl;
            std::cout << "   空格键: 播放/暂停" << std::endl;
            std::cout << "   →: 下一帧" << std::endl;
            std::cout << "   ←: 上一帧" << std::endl;
            std::cout << "   R: 重置到开始" << std::endl;
            std::cout << "   L: 循环播放" << std::endl;
            std::cout << "   +: 加快播放" << std::endl;
            std::cout << "   -: 减慢播放" << std::endl;
            std::cout << "   F: 应用滤镜" << std::endl;
            std::cout << "   I: 显示/隐藏信息" << std::endl;
            std::cout << "   S: 保存当前帧" << std::endl;
            std::cout << "   ESC: 退出" << std::endl;
            
            cv::Mat frame;
            auto playback_start = std::chrono::steady_clock::now();
            
            while (true) {
                // 更新控制面板
                control_panel.setTo(cv::Scalar(50, 50, 50));
                
                // 绘制控制信息
                cv::putText(control_panel, "=== 视频控制面板 ===", 
                           cv::Point(20, 30), cv::FONT_HERSHEY_SIMPLEX, 
                           0.7, cv::Scalar(0, 255, 255), 2);
                
                cv::putText(control_panel, "状态: " + std::string(is_playing ? "播放中" : "已暂停"), 
                           cv::Point(20, 70), cv::FONT_HERSHEY_SIMPLEX, 
                           0.6, cv::Scalar(0, 255, 0), 1);
                
                cv::putText(control_panel, "帧: " + std::to_string(current_frame) + 
                           "/" + std::to_string(video_info.frame_count), 
                           cv::Point(20, 100), cv::FONT_HERSHEY_SIMPLEX, 
                           0.6, cv::Scalar(200, 200, 200), 1);
                
                double progress = static_cast<double>(current_frame) / video_info.frame_count;
                cv::putText(control_panel, "进度: " + std::to_string(static_cast<int>(progress * 100)) + "%", 
                           cv::Point(20, 130), cv::FONT_HERSHEY_SIMPLEX, 
                           0.6, cv::Scalar(200, 200, 200), 1);
                
                cv::putText(control_panel, "速度: " + std::to_string(playback_speed) + "x", 
                           cv::Point(20, 160), cv::FONT_HERSHEY_SIMPLEX, 
                           0.6, cv::Scalar(200, 200, 200), 1);
                
                cv::putText(control_panel, "滤镜: " + std::string(apply_filter ? "开" : "关"), 
                           cv::Point(20, 190), cv::FONT_HERSHEY_SIMPLEX, 
                           0.6, cv::Scalar(apply_filter ? cv::Scalar(0, 255, 0) : cv::Scalar(200, 200, 200)), 1);
                
                cv::putText(control_panel, "循环: " + std::string(loop_video ? "开" : "关"), 
                           cv::Point(20, 220), cv::FONT_HERSHEY_SIMPLEX, 
                           0.6, cv::Scalar(loop_video ? cv::Scalar(0, 255, 0) : cv::Scalar(200, 200, 200)), 1);
                
                // 绘制进度条
                int bar_width = 360;
                int bar_height = 10;
                int bar_x = 20;
                int bar_y = 250;
                
                // 背景条
                cv::rectangle(control_panel, 
                            cv::Rect(bar_x, bar_y, bar_width, bar_height),
                            cv::Scalar(100, 100, 100), -1);
                
                // 进度条
                int progress_width = static_cast<int>(bar_width * progress);
                cv::rectangle(control_panel, 
                            cv::Rect(bar_x, bar_y, progress_width, bar_height),
                            cv::Scalar(0, 200, 0), -1);
                
                // 边框
                cv::rectangle(control_panel, 
                            cv::Rect(bar_x, bar_y, bar_width, bar_height),
                            cv::Scalar(200, 200, 200), 1);
                
                // 处理视频帧
                if (is_playing) {
                    if (!video_cap.read(frame)) {
                        if (loop_video) {
                            // 循环播放：重置到开始
                            video_cap.set(cv::CAP_PROP_POS_FRAMES, 0);
                            video_cap.read(frame);
                            current_frame = 0;
                        } else {
                            // 播放结束
                            is_playing = false;
                            continue;
                        }
                    } else {
                        current_frame = static_cast<int>(video_cap.get(cv::CAP_PROP_POS_FRAMES)) - 1;
                    }
                } else {
                    // 暂停状态：保持当前帧
                    video_cap.set(cv::CAP_PROP_POS_FRAMES, current_frame);
                    video_cap.read(frame);
                }
                
                // 应用滤镜（如果启用）
                if (apply_filter && !frame.empty()) {
                    cv::Mat filtered;
                    
                    // 根据帧号选择不同的滤镜效果
                    int effect = current_frame / 15 % 4;  // 每15帧切换效果
                    
                    switch(effect) {
                        case 0:  // 灰度化
                            cv::cvtColor(frame, filtered, cv::COLOR_BGR2GRAY);
                            cv::cvtColor(filtered, filtered, cv::COLOR_GRAY2BGR);
                            break;
                        case 1:  // 边缘检测
                            cv::Mat gray, edges;
                            cv::cvtColor(frame, gray, cv::COLOR_BGR2GRAY);
                            cv::Canny(gray, edges, 50, 150);
                            cv::cvtColor(edges, filtered, cv::COLOR_GRAY2BGR);
                            break;
                        case 2:  // 高斯模糊
                            cv::GaussianBlur(frame, filtered, cv::Size(15, 15), 0);
                            break;
                        case 3:  // 颜色反转
                            cv::bitwise_not(frame, filtered);
                            break;
                        default:
                            frame.copyTo(filtered);
                    }
                    
                    frame = filtered;
                }
                
                // 添加信息覆盖层
                if (show_info && !frame.empty()) {
                    // 创建信息覆盖层
                    cv::Mat overlay = frame.clone();
                    
                    // 半透明背景
                    cv::rectangle(overlay, cv::Rect(10, 10, 300, 100), 
                                 cv::Scalar(0, 0, 0), -1);
                    
                    // 半透明效果
                    double alpha = 0.6;
                    cv::addWeighted(overlay, alpha, frame, 1 - alpha, 0, frame);
                    
                    // 添加文本信息
                    cv::putText(frame, "帧: " + std::to_string(current_frame), 
                               cv::Point(20, 40), cv::FONT_HERSHEY_SIMPLEX, 
                               0.7, cv::Scalar(255, 255, 255), 2);
                    
                    double current_time = current_frame / video_info.fps;
                    cv::putText(frame, "时间: " + std::to_string(current_time) + "s", 
                               cv::Point(20, 70), cv::FONT_HERSHEY_SIMPLEX, 
                               0.6, cv::Scalar(255, 255, 255), 1);
                    
                    cv::putText(frame, "FPS: " + std::to_string(static_cast<int>(video_info.fps)), 
                               cv::Point(20, 100), cv::FONT_HERSHEY_SIMPLEX, 
                               0.6, cv::Scalar(255, 255, 255), 1);
                }
                
                // 显示帧
                if (!frame.empty()) {
                    cv::imshow("视频播放器", frame);
                }
                
                cv::imshow("控制面板", control_panel);
                
                // 处理按键输入
                int key = cv::waitKey(static_cast<int>(frame_delay / playback_speed));
                
                switch(key) {
                    case 27:  // ESC - 退出
                        std::cout << "退出视频播放" << std::endl;
                        goto end_video_playback;
                        
                    case 32:  // 空格键 - 播放/暂停
                        is_playing = !is_playing;
                        std::cout << (is_playing ? "播放" : "暂停") << std::endl;
                        break;
                        
                    case 'r': case 'R':  // R - 重置
                        video_cap.set(cv::CAP_PROP_POS_FRAMES, 0);
                        current_frame = 0;
                        std::cout << "重置到开始" << std::endl;
                        break;
                        
                    case 'l': case 'L':  // L - 循环切换
                        loop_video = !loop_video;
                        std::cout << "循环: " << (loop_video ? "开" : "关") << std::endl;
                        break;
                        
                    case 'f': case 'F':  // F - 滤镜切换
                        apply_filter = !apply_filter;
                        std::cout << "滤镜: " << (apply_filter ? "开" : "关") << std::endl;
                        break;
                        
                    case 'i': case 'I':  // I - 信息显示切换
                        show_info = !show_info;
                        std::cout << "信息显示: " << (show_info ? "开" : "关") << std::endl;
                        break;
                        
                    case 's': case 'S':  // S - 保存当前帧
                        if (!frame.empty()) {
                            std::string filename = "frame_" + std::to_string(current_frame) + 
                                                 "_" + std::to_string(time(0)) + ".jpg";
                            cv::imwrite(filename, frame);
                            std::cout << "已保存帧: " << filename << std::endl;
                        }
                        break;
                        
                    case '=': case '+':  // + - 加快播放
                        playback_speed = std::min(playback_speed * 1.5, 10.0);
                        std::cout << "播放速度: " << playback_speed << "x" << std::endl;
                        break;
                        
                    case '-': case '_':  // - - 减慢播放
                        playback_speed = std::max(playback_speed / 1.5, 0.1);
                        std::cout << "播放速度: " << playback_speed << "x" << std::endl;
                        break;
                        
                    case 83:  // 右箭头 - 下一帧
                        if (!is_playing) {
                            current_frame = std::min(current_frame + 1, video_info.frame_count - 1);
                            video_cap.set(cv::CAP_PROP_POS_FRAMES, current_frame);
                        }
                        break;
                        
                    case 81:  // 左箭头 - 上一帧
                        if (!is_playing) {
                            current_frame = std::max(current_frame - 1, 0);
                            video_cap.set(cv::CAP_PROP_POS_FRAMES, current_frame);
                        }
                        break;
                        
                    default:
                        if (key >= 0) {
                            std::cout << "按键: " << key << " (" << char(key) << ")" << std::endl;
                        }
                }
                
                // 自动保存帧（如果启用）
                if (save_frames && !frame.empty()) {
                    static int auto_save_counter = 0;
                    if (current_frame % 10 == 0) {  // 每10帧保存一次
                        std::string auto_filename = "auto_frame_" + 
                                                  std::to_string(auto_save_counter++) + ".jpg";
                        cv::imwrite(auto_filename, frame);
                    }
                }
            }
            
            end_video_playback:
            video_cap.release();
        } else {
            std::cerr << "无法打开视频文件: " << test_video << std::endl;
        }
    }
    
    cv::destroyAllWindows();
    
    // ============================================
    // 4. 视频处理管道
    // ============================================
    
    std::cout << "\n\n4. 视频处理管道示例" << std::endl;
    
    // 创建处理管道
    cv::VideoCapture pipeline_cap;
    cv::VideoWriter pipeline_writer;
    
    // 输入源：摄像头或测试视频
    if (camera.isOpened()) {
        // 重新打开摄像头
        camera = CameraController(0);
        std::cout << "使用摄像头作为输入源" << std::endl;
    } else if (!test_video.empty()) {
        pipeline_cap.open(test_video);
        std::cout << "使用视频文件作为输入源" << std::endl;
    } else {
        std::cout << "创建合成视频作为输入源" << std::endl;
        
        // 创建合成视频
        cv::VideoWriter synthetic_writer;
        int fourcc = cv::VideoWriter::fourcc('M', 'J', 'P', 'G');
        synthetic_writer.open("synthetic_input.avi", fourcc, 30, cv::Size(640, 480), true);
        
        if (synthetic_writer.isOpened()) {
            for (int i = 0; i < 100; i++) {
                cv::Mat synth_frame(480, 640, CV_8UC3);
                cv::randu(synth_frame, cv::Scalar(0, 0, 0), cv::Scalar(255, 255, 255));
                
                // 添加移动对象
                cv::circle(synth_frame, 
                          cv::Point(320 + 100 * sin(i * 0.1), 240 + 80 * cos(i * 0.1)),
                          20, cv::Scalar(0, 0, 255), -1);
                
                synthetic_writer.write(synth_frame);
            }
            synthetic_writer.release();
            
            pipeline_cap.open("synthetic_input.avi");
            test_video = "synthetic_input.avi";
        }
    }
    
    if (pipeline_cap.isOpened() || camera.isOpened()) {
        std::cout << "输入源准备就绪" << std::endl;
        
        // 创建输出视频
        std::string output_video = "processed_output_" + 
                                 std::to_string(time(0)) + ".avi";
        
        int output_fourcc = cv::VideoWriter::fourcc('M', 'J', 'P', 'G');
        double output_fps = 25.0;
        cv::Size output_size(640, 480);
        
        pipeline_writer.open(output_video, output_fourcc, output_fps, output_size, true);
        
        if (pipeline_writer.isOpened()) {
            std::cout << "开始视频处理管道..." << std::endl;
            std::cout << "输出文件: " << output_video << std::endl;
            
            cv::namedWindow("处理管道", cv::WINDOW_NORMAL);
            cv::resizeWindow("处理管道", 800, 600);
            
            int processed_frames = 0;
            auto start_time = std::chrono::steady_clock::now();
            
            while (true) {
                cv::Mat input_frame;
                bool success = false;
                
                if (camera.isOpened()) {
                    success = camera.readFrame(input_frame);
                } else {
                    success = pipeline_cap.read(input_frame);
                }
                
                if (!success) {
                    std::cout << "输入结束或读取失败" << std::endl;
                    break;
                }
                
                processed_frames++;
                
                // 步骤1: 调整尺寸
                cv::Mat resized_frame;
                cv::resize(input_frame, resized_frame, output_size);
                
                // 步骤2: 转换为灰度（用于处理）
                cv::Mat gray_frame;
                cv::cvtColor(resized_frame, gray_frame, cv::COLOR_BGR2GRAY);
                
                // 步骤3: 边缘检测
                cv::Mat edges_frame;
                cv::Canny(gray_frame, edges_frame, 50, 150);
                
                // 步骤4: 转换为彩色用于显示
                cv::Mat color_edges;
                cv::cvtColor(edges_frame, color_edges, cv::COLOR_GRAY2BGR);
                
                // 步骤5: 与原始图像混合
                cv::Mat blended_frame;
                double blend_alpha = 0.7;
                cv::addWeighted(resized_frame, blend_alpha, color_edges, 1 - blend_alpha, 0, blended_frame);
                
                // 步骤6: 添加时间戳和信息
                auto current_time = std::chrono::steady_clock::now();
                double elapsed = std::chrono::duration<double>(current_time - start_time).count();
                double fps = processed_frames / elapsed;
                
                std::string info_text = "Frame: " + std::to_string(processed_frames) + 
                                      " | FPS: " + std::to_string(static_cast<int>(fps)) +
                                      " | Time: " + std::to_string(static_cast<int>(elapsed)) + "s";
                
                cv::putText(blended_frame, info_text, cv::Point(10, 30), 
                           cv::FONT_HERSHEY_SIMPLEX, 0.6, cv::Scalar(0, 255, 0), 2);
                
                // 步骤7: 写入输出视频
                pipeline_writer.write(blended_frame);
                
                // 步骤8: 显示处理结果
                cv::imshow("处理管道", blended_frame);
                
                // 检查退出条件
                int key = cv::waitKey(1);
                if (key == 27) {  // ESC
                    std::cout << "用户中断处理" << std::endl;
                    break;
                }
                
                // 限制处理帧数（用于演示）
                if (processed_frames >= 200 && !camera.isOpened()) {
                    std::cout << "达到最大处理帧数" << std::endl;
                    break;
                }
            }
            
            std::cout << "处理完成！" << std::endl;
            std::cout << "总处理帧数: " << processed_frames << std::endl;
            std::cout << "输出文件: " << output_video << std::endl;
            
            pipeline_writer.release();
            
            // 显示处理后的视频
            std::cout << "\n播放处理后的视频..." << std::endl;
            cv::VideoCapture result_cap(output_video);
            
            if (result_cap.isOpened()) {
                cv::namedWindow("处理结果", cv::WINDOW_NORMAL);
                
                while (true) {
                    cv::Mat result_frame;
                    if (!result_cap.read(result_frame)) break;
                    
                    cv::imshow("处理结果", result_frame);
                    if (cv::waitKey(30) == 27) break;
                }
                
                result_cap.release();
            }
            
        } else {
            std::cerr << "无法创建输出视频" << std::endl;
        }
        
        pipeline_cap.release();
    }
    
    cv::destroyAllWindows();
    
    // ============================================
    // 5. 清理临时文件
    // ============================================
    
    // 删除测试视频文件（可选）
    /*
    if (!test_video.empty() && test_video != "test_video.mp4") {
        remove(test_video.c_str());
        std::cout << "已清理临时文件: " << test_video << std::endl;
    }
    */
    
    std::cout << "\n=== 视频处理演示完成 ===" << std::endl;
    std::cout << "总结：" << std::endl;
    std::cout << "1. 掌握了视频捕获的多种方式" << std::endl;
    std::cout << "2. 学会了视频属性和控制方法" << std::endl;
    std::cout << "3. 实现了完整的视频播放器" << std::endl;
    std::cout << "4. 构建了视频处理管道" << std::endl;
    
    return 0;
}
```
# 像素运算

## 三、像素运算与位操作

### 3.1 像素运算基础

#### 讲解
像素运算是图像处理中最基本的操作之一，包括算术运算（加、减、乘、除）和逻辑运算（与、或、非、异或）。这些操作常用于图像融合、对比度调整、掩膜处理等应用。

#### 核心概念

| 概念 | 说明 | 数学表示 | OpenCV 实现 |
|------|------|----------|-------------|
| **像素值范围** | 8位图像：0-255<br>16位图像：0-65535<br>浮点图像：0.0-1.0 | [0, 255] | `CV_8U`, `CV_16U`, `CV_32F` |
| **溢出处理** | 超出范围的值如何处理 | - | `cv::saturate_cast<>()` |
| **图像融合** | 加权合并两张图像 | dst = α×src1 + β×src2 + γ | `cv::addWeighted()` |

#### 运算方法对比

| 运算类型 | OpenCV函数 | 运算符 | 特点 |
|----------|------------|--------|------|
| **加法** | `cv::add()` | `+` | 避免溢出（饱和） |
| **减法** | `cv::subtract()` | `-` | 避免下溢 |
| **乘法** | `cv::multiply()` | `*` | 标量或矩阵乘法 |
| **除法** | `cv::divide()` | `/` | 避免除零 |
| **加权和** | `cv::addWeighted()` | - | 线性混合 |

#### 位运算方法

| 位运算 | OpenCV函数 | 用途 |
|--------|------------|------|
| **与** | `cv::bitwise_and()` | 掩膜操作，提取ROI |
| **或** | `cv::bitwise_or()` | 图像合并 |
| **非** | `cv::bitwise_not()` | 图像取反 |
| **异或** | `cv::bitwise_xor()` | 差异检测，加密 |

### 3.2 像素运算实战代码

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>
#include <vector>
#include <cmath>

// 显示图像信息
void showImageInfo(const cv::Mat& img, const std::string& name) {
    std::cout << name << ": " << img.cols << "×" << img.rows 
              << " (" << img.channels() << " channels, " 
              << img.depth() << " depth)" << std::endl;
}

// 像素值范围检查
void checkPixelRange(const cv::Mat& img) {
    double min_val, max_val;
    cv::minMaxLoc(img, &min_val, &max_val);
    std::cout << "  像素值范围: [" << min_val << ", " << max_val << "]" << std::endl;
}

int main() {
    std::cout << "=== OpenCV 像素运算与位操作 ===\n" << std::endl;
    
    // ============================================
    // 1. 创建测试图像
    // ============================================
    
    std::cout << "1. 创建测试图像..." << std::endl;
    
    // 1.1 基础图像
    cv::Mat img1(300, 400, CV_8UC3, cv::Scalar(100, 100, 100));
    cv::Mat img2(300, 400, CV_8UC3, cv::Scalar(200, 200, 200));
    
    // 1.2 创建渐变图像
    cv::Mat gradient(300, 400, CV_8UC3);
    for (int y = 0; y < gradient.rows; y++) {
        for (int x = 0; x < gradient.cols; x++) {
            gradient.at<cv::Vec3b>(y, x) = cv::Vec3b(
                static_cast<uchar>(255.0 * x / gradient.cols),      // 蓝色渐变
                static_cast<uchar>(255.0 * y / gradient.rows),      // 绿色渐变
                static_cast<uchar>(128 + 127 * sin(x * 0.05))       // 红色正弦
            );
        }
    }
    
    // 1.3 创建掩膜图像
    cv::Mat mask(300, 400, CV_8UC1, cv::Scalar(0));
    cv::circle(mask, cv::Point(200, 150), 100, cv::Scalar(255), -1);
    
    showImageInfo(img1, "图像1 (100,100,100)");
    showImageInfo(img2, "图像2 (200,200,200)");
    showImageInfo(gradient, "渐变图像");
    showImageInfo(mask, "掩膜图像");
    
    // ============================================
    // 2. 算术运算：加法
    // ============================================
    
    std::cout << "\n2. 算术运算：加法" << std::endl;
    
    // 2.1 使用cv::add() - 饱和加法（推荐）
    cv::Mat add_saturated;
    cv::add(img1, img2, add_saturated);
    std::cout << "   cv::add(): 饱和加法" << std::endl;
    checkPixelRange(add_saturated);
    
    // 2.2 使用+运算符 - 模加法（可能溢出）
    cv::Mat add_modulo = img1 + img2;
    std::cout << "   +运算符: 模加法（溢出会回绕）" << std::endl;
    checkPixelRange(add_modulo);
    
    // 2.3 标量加法
    cv::Mat add_scalar;
    cv::add(img1, cv::Scalar(50, 30, 10), add_scalar);
    std::cout << "   标量加法: 每个通道加不同值" << std::endl;
    
    // 2.4 演示溢出问题
    cv::Mat img_high(300, 400, CV_8UC3, cv::Scalar(200, 200, 200));
    cv::Mat add_overflow;
    cv::add(img_high, img_high, add_overflow);  // 200+200=400，但饱和到255
    
    // 提取一个像素进行比较
    cv::Vec3b pixel_high = img_high.at<cv::Vec3b>(0, 0);
    cv::Vec3b pixel_add = add_overflow.at<cv::Vec3b>(0, 0);
    std::cout << "   溢出演示: 200+200 = (" 
              << (int)pixel_add[0] << "," << (int)pixel_add[1] << "," 
              << (int)pixel_add[2] << ") [饱和到255]" << std::endl;
    
    // ============================================
    // 3. 算术运算：减法
    // ============================================
    
    std::cout << "\n3. 算术运算：减法" << std::endl;
    
    // 3.1 使用cv::subtract()
    cv::Mat subtract_result;
    cv::subtract(img2, img1, subtract_result);
    std::cout << "   cv::subtract(): 200-100 = 100" << std::endl;
    checkPixelRange(subtract_result);
    
    // 3.2 下溢演示
    cv::Mat img_low(300, 400, CV_8UC3, cv::Scalar(50, 50, 50));
    cv::Mat underflow;
    cv::subtract(img_low, img2, underflow);  // 50-200=-150，但饱和到0
    
    cv::Vec3b pixel_low = img_low.at<cv::Vec3b>(0, 0);
    cv::Vec3b pixel_sub = underflow.at<cv::Vec3b>(0, 0);
    std::cout << "   下溢演示: 50-200 = (" 
              << (int)pixel_sub[0] << "," << (int)pixel_sub[1] << "," 
              << (int)pixel_sub[2] << ") [饱和到0]" << std::endl;
    
    // ============================================
    // 4. 算术运算：乘法
    // ============================================
    
    std::cout << "\n4. 算术运算：乘法" << std::endl;
    
    // 4.1 图像乘法（逐元素）
    cv::Mat multiply_result;
    cv::multiply(img1, img2, multiply_result, 1.0/255.0);  // 归一化因子
    std::cout << "   cv::multiply(): 100×200 = 20000/255≈78" << std::endl;
    checkPixelRange(multiply_result);
    
    // 4.2 标量乘法（对比度调整）
    cv::Mat contrast_low, contrast_high;
    cv::multiply(gradient, 0.5, contrast_low);   // 降低对比度
    cv::multiply(gradient, 1.5, contrast_high);  // 提高对比度
    
    std::cout << "   对比度调整: ×0.5 和 ×1.5" << std::endl;
    checkPixelRange(contrast_low);
    checkPixelRange(contrast_high);
    
    // ============================================
    // 5. 算术运算：除法
    // ============================================
    
    std::cout << "\n5. 算术运算：除法" << std::endl;
    
    // 5.1 避免除零
    cv::Mat img_nonzero = img2.clone();
    img_nonzero.setTo(cv::Scalar(1, 1, 1), img_nonzero == 0);  // 确保没有0值
    
    cv::Mat divide_result;
    cv::divide(img2, img_nonzero, divide_result);
    std::cout << "   cv::divide(): 200/1 = 200" << std::endl;
    checkPixelRange(divide_result);
    
    // 5.2 带缩放因子的除法
    cv::Mat divide_scaled;
    cv::divide(img2, img_nonzero, divide_scaled, 2.0);  // 结果×2
    std::cout << "   带缩放除法: (200/1)×2 = 400 [饱和到255]" << std::endl;
    checkPixelRange(divide_scaled);
    
    // ============================================
    // 6. 加权和（图像融合）
    // ============================================
    
    std::cout << "\n6. 加权和：图像融合" << std::endl;
    
    cv::Mat blended;
    double alpha = 0.3;  // img1的权重
    double beta = 0.7;   // img2的权重
    double gamma = 0.0;  // 额外的常数
    
    cv::addWeighted(img1, alpha, img2, beta, gamma, blended);
    
    std::cout << "   cv::addWeighted(): 0.3×img1 + 0.7×img2" << std::endl;
    std::cout << "   理论值: 0.3×100 + 0.7×200 = 170" << std::endl;
    
    cv::Vec3b pixel_blend = blended.at<cv::Vec3b>(0, 0);
    std::cout << "   实际值: (" << (int)pixel_blend[0] << "," 
              << (int)pixel_blend[1] << "," << (int)pixel_blend[2] << ")" << std::endl;
    
    // 渐变融合演示
    cv::Mat gradient_blend;
    cv::addWeighted(gradient, 0.6, img2, 0.4, 0, gradient_blend);
    
    // ============================================
    // 7. 位运算：与操作
    // ============================================
    
    std::cout << "\n7. 位运算：与操作 (AND)" << std::endl;
    
    // 7.1 创建二进制图像
    cv::Mat binary1(300, 400, CV_8UC1, cv::Scalar(0));
    cv::Mat binary2(300, 400, CV_8UC1, cv::Scalar(0));
    
    cv::rectangle(binary1, cv::Rect(50, 50, 200, 200), cv::Scalar(255), -1);
    cv::rectangle(binary2, cv::Rect(150, 150, 200, 200), cv::Scalar(255), -1);
    
    // 7.2 位与操作
    cv::Mat bitwise_and_result;
    cv::bitwise_and(binary1, binary2, bitwise_and_result);
    
    std::cout << "   cv::bitwise_and(): 矩形交集" << std::endl;
    
    // 7.3 使用掩膜
    cv::Mat masked_gradient;
    cv::bitwise_and(gradient, gradient, masked_gradient, mask);  // 应用圆形掩膜
    
    // ============================================
    // 8. 位运算：或操作
    // ============================================
    
    std::cout << "\n8. 位运算：或操作 (OR)" << std::endl;
    
    cv::Mat bitwise_or_result;
    cv::bitwise_or(binary1, binary2, bitwise_or_result);
    
    std::cout << "   cv::bitwise_or(): 矩形并集" << std::endl;
    
    // ============================================
    // 9. 位运算：非操作
    // ============================================
    
    std::cout << "\n9. 位运算：非操作 (NOT)" << std::endl;
    
    cv::Mat bitwise_not_result;
    cv::bitwise_not(binary1, bitwise_not_result);
    
    std::cout << "   cv::bitwise_not(): 图像取反" << std::endl;
    
    // 彩色图像取反
    cv::Mat gradient_inverse;
    cv::bitwise_not(gradient, gradient_inverse);
    
    // ============================================
    // 10. 位运算：异或操作
    // ============================================
    
    std::cout << "\n10. 位运算：异或操作 (XOR)" << std::endl;
    
    cv::Mat bitwise_xor_result;
    cv::bitwise_xor(binary1, binary2, bitwise_xor_result);
    
    std::cout << "   cv::bitwise_xor(): 矩形差异" << std::endl;
    
    // ============================================
    // 11. 综合应用：图像水印
    // ============================================
    
    std::cout << "\n11. 综合应用：图像水印" << std::endl;
    
    // 11.1 创建水印图像
    cv::Mat watermark(300, 400, CV_8UC3, cv::Scalar(0));
    cv::putText(watermark, "OPENCV", cv::Point(100, 150),
                cv::FONT_HERSHEY_SIMPLEX, 2.0, cv::Scalar(255, 255, 255), 3);
    
    // 11.2 创建水印掩膜
    cv::Mat watermark_gray, watermark_mask;
    cv::cvtColor(watermark, watermark_gray, cv::COLOR_BGR2GRAY);
    cv::threshold(watermark_gray, watermark_mask, 10, 255, cv::THRESH_BINARY);
    
    // 11.3 应用水印（使用位运算）
    cv::Mat watermarked;
    gradient.copyTo(watermarked);
    
    // 方法1：直接设置水印区域
    watermark.copyTo(watermarked, watermark_mask);
    
    // 方法2：混合水印（半透明效果）
    cv::Mat watermarked_blend;
    cv::addWeighted(gradient, 0.7, watermark, 0.3, 0, watermarked_blend);
    
    std::cout << "   创建文字水印并应用到图像" << std::endl;
    
    // ============================================
    // 12. 综合应用：图像差异检测
    // ============================================
    
    std::cout << "\n12. 综合应用：图像差异检测" << std::endl;
    
    // 12.1 创建两个相似但有差异的图像
    cv::Mat scene1 = gradient.clone();
    cv::Mat scene2 = gradient.clone();
    
    // 在scene2中添加一个矩形
    cv::rectangle(scene2, cv::Rect(250, 100, 80, 60), cv::Scalar(0, 0, 255), -1);
    
    // 12.2 计算绝对差异
    cv::Mat diff_abs;
    cv::absdiff(scene1, scene2, diff_abs);
    
    // 12.3 转换为灰度并二值化
    cv::Mat diff_gray, diff_binary;
    cv::cvtColor(diff_abs, diff_gray, cv::COLOR_BGR2GRAY);
    cv::threshold(diff_gray, diff_binary, 30, 255, cv::THRESH_BINARY);
    
    std::cout << "   使用absdiff()检测图像差异" << std::endl;
    
    // ============================================
    // 13. 像素值饱和处理
    // ============================================
    
    std::cout << "\n13. 像素值饱和处理" << std::endl;
    
    // 13.1 手动饱和处理
    cv::Mat high_values(100, 100, CV_32FC1);
    cv::randu(high_values, 0.0, 3.0);  // 生成0-3的值
    
    cv::Mat saturated_manual = high_values.clone();
    saturated_manual.setTo(1.0, saturated_manual > 1.0);
    saturated_manual.setTo(0.0, saturated_manual < 0.0);
    
    // 13.2 使用saturate_cast
    cv::Mat float_image(100, 100, CV_32FC1);
    cv::randu(float_image, -0.5, 1.5);
    
    cv::Mat uchar_image(float_image.size(), CV_8UC1);
    for (int y = 0; y < float_image.rows; y++) {
        for (int x = 0; x < float_image.cols; x++) {
            float pixel = float_image.at<float>(y, x);
            // 饱和转换：<0变为0，>1变为255，其他线性映射
            uchar_image.at<uchar>(y, x) = cv::saturate_cast<uchar>(pixel * 255);
        }
    }
    
    std::cout << "   saturate_cast<uchar>: 自动处理溢出" << std::endl;
    
    // 13.3 不同数据类型的转换
    cv::Mat float_src(100, 100, CV_32FC3);
    cv::randu(float_src, 0.0, 1.0);
    
    cv::Mat uchar_dst;
    float_src.convertTo(uchar_dst, CV_8UC3, 255.0);  // 缩放并转换
    
    // ============================================
    // 14. 创建显示面板
    // ============================================
    
    std::cout << "\n14. 创建结果显示面板..." << std::endl;
    
    // 14.1 创建主显示面板
    int panel_width = 1200;
    int panel_height = 900;
    cv::Mat display_panel(panel_height, panel_width, CV_8UC3, cv::Scalar(30, 30, 30));
    
    // 14.2 定义缩略图尺寸
    int thumb_width = 280;
    int thumb_height = 210;
    
    // 14.3 准备所有结果图像
    std::vector<cv::Mat> all_results;
    std::vector<std::string> all_labels;
    
    // 原始图像
    cv::Mat thumb_original;
    cv::resize(gradient, thumb_original, cv::Size(thumb_width, thumb_height));
    all_results.push_back(thumb_original);
    all_labels.push_back("Original");
    
    // 算术运算结果
    std::vector<cv::Mat> arithmetic_results = {
        add_saturated, subtract_result, multiply_result, blended
    };
    std::vector<std::string> arithmetic_labels = {
        "Add", "Subtract", "Multiply", "Blend"
    };
    
    for (size_t i = 0; i < arithmetic_results.size(); i++) {
        cv::Mat thumb;
        cv::resize(arithmetic_results[i], thumb, cv::Size(thumb_width, thumb_height));
        all_results.push_back(thumb);
        all_labels.push_back(arithmetic_labels[i]);
    }
    
    // 位运算结果（转换为彩色显示）
    std::vector<cv::Mat> bitwise_results = {
        binary1, binary2, bitwise_and_result, 
        bitwise_or_result, bitwise_not_result, bitwise_xor_result
    };
    std::vector<std::string> bitwise_labels = {
        "Binary1", "Binary2", "AND", "OR", "NOT", "XOR"
    };
    
    for (size_t i = 0; i < bitwise_results.size(); i++) {
        cv::Mat thumb;
        cv::Mat color_bitwise;
        if (bitwise_results[i].channels() == 1) {
            cv::cvtColor(bitwise_results[i], color_bitwise, cv::COLOR_GRAY2BGR);
        } else {
            color_bitwise = bitwise_results[i];
        }
        cv::resize(color_bitwise, thumb, cv::Size(thumb_width, thumb_height));
        all_results.push_back(thumb);
        all_labels.push_back(bitwise_labels[i]);
    }
    
    // 应用结果
    all_results.push_back(watermarked);
    all_labels.push_back("Watermarked");
    
    all_results.push_back(diff_abs);
    all_labels.push_back("Difference");
    
    // 14.4 在面板上排列所有结果
    int cols = 4;
    int thumb_index = 0;
    
    for (size_t i = 0; i < all_results.size(); i++) {
        int row = thumb_index / cols;
        int col = thumb_index % cols;
        
        int x = col * (thumb_width + 20) + 20;
        int y = row * (thumb_height + 40) + 40;
        
        // 确保位置在面板范围内
        if (y + thumb_height < panel_height) {
            // 复制缩略图
            cv::Rect roi(x, y, thumb_width, thumb_height);
            cv::Mat thumb_resized;
            cv::resize(all_results[i], thumb_resized, cv::Size(thumb_width, thumb_height));
            thumb_resized.copyTo(display_panel(roi));
            
            // 添加边框
            cv::rectangle(display_panel, roi, cv::Scalar(180, 180, 180), 1);
            
            // 添加标签
            cv::putText(display_panel, all_labels[i], 
                       cv::Point(x + 5, y + thumb_height + 20),
                       cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(220, 220, 220), 1);
            
            thumb_index++;
        }
    }
    
    // 14.5 添加标题
    cv::putText(display_panel, "OpenCV Pixel Operations Demo", 
               cv::Point(panel_width / 2 - 200, 30),
               cv::FONT_HERSHEY_SIMPLEX, 0.9, cv::Scalar(0, 255, 255), 2);
    
    // 添加分类标签
    cv::putText(display_panel, "Arithmetic Operations", 
               cv::Point(20, 20),
               cv::FONT_HERSHEY_SIMPLEX, 0.6, cv::Scalar(0, 200, 255), 1);
    
    cv::putText(display_panel, "Bitwise Operations", 
               cv::Point(20, 280),
               cv::FONT_HERSHEY_SIMPLEX, 0.6, cv::Scalar(0, 200, 255), 1);
    
    cv::putText(display_panel, "Applications", 
               cv::Point(20, 540),
               cv::FONT_HERSHEY_SIMPLEX, 0.6, cv::Scalar(0, 200, 255), 1);
    
    // ============================================
    // 15. 交互演示
    // ============================================
    
    std::cout << "\n15. 交互演示：动态调整参数" << std::endl;
    
    cv::namedWindow("像素运算演示", cv::WINDOW_NORMAL);
    cv::resizeWindow("像素运算演示", panel_width, panel_height);
    cv::imshow("像素运算演示", display_panel);
    
    // 创建控制窗口
    cv::namedWindow("控制面板", cv::WINDOW_NORMAL);
    cv::resizeWindow("控制面板", 400, 300);
    
    // 创建控制参数
    int alpha_slider = 50;  // 0-100，对应0.0-1.0
    int beta_slider = 50;
    int operation_type = 0;  // 0:加法, 1:减法, 2:乘法, 3:融合
    
    // 创建控制面板图像
    cv::Mat control_panel(300, 400, CV_8UC3, cv::Scalar(50, 50, 50));
    
    // 更新控制面板函数
    auto updateControlPanel = [&]() {
        control_panel.setTo(cv::Scalar(50, 50, 50));
        
        // 标题
        cv::putText(control_panel, "=== 像素运算控制 ===",
                   cv::Point(20, 30), cv::FONT_HERSHEY_SIMPLEX,
                   0.7, cv::Scalar(0, 255, 255), 2);
        
        // 操作类型
        std::vector<std::string> operations = {"加法", "减法", "乘法", "融合"};
        cv::putText(control_panel, "操作: " + operations[operation_type],
                   cv::Point(20, 70), cv::FONT_HERSHEY_SIMPLEX,
                   0.6, cv::Scalar(200, 200, 200), 1);
        
        // 参数显示
        double alpha_val = alpha_slider / 100.0;
        double beta_val = beta_slider / 100.0;
        
        cv::putText(control_panel, "参数1: " + std::to_string(alpha_val),
                   cv::Point(20, 100), cv::FONT_HERSHEY_SIMPLEX,
                   0.6, cv::Scalar(200, 200, 200), 1);
        
        if (operation_type == 3) {  // 融合操作
            cv::putText(control_panel, "参数2: " + std::to_string(beta_val),
                       cv::Point(20, 130), cv::FONT_HERSHEY_SIMPLEX,
                       0.6, cv::Scalar(200, 200, 200), 1);
        }
        
        // 操作说明
        cv::putText(control_panel, "按键控制:", cv::Point(20, 180),
                   cv::FONT_HERSHEY_SIMPLEX, 0.6, cv::Scalar(0, 255, 0), 1);
        
        cv::putText(control_panel, "A/D: 调整参数1", cv::Point(30, 210),
                   cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(200, 200, 200), 1);
        
        cv::putText(control_panel, "W/S: 调整参数2", cv::Point(30, 235),
                   cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(200, 200, 200), 1);
        
        cv::putText(control_panel, "数字1-4: 选择操作", cv::Point(30, 260),
                   cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(200, 200, 200), 1);
        
        cv::putText(control_panel, "ESC: 退出", cv::Point(30, 285),
                   cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(200, 200, 200), 1);
    };
    
    updateControlPanel();
    cv::imshow("控制面板", control_panel);
    
    // 创建动态演示窗口
    cv::namedWindow("动态演示", cv::WINDOW_NORMAL);
    cv::resizeWindow("动态演示", 400, 300);
    
    std::cout << "   按键说明:" << std::endl;
    std::cout << "   A/D: 调整参数1" << std::endl;
    std::cout << "   W/S: 调整参数2（融合操作）" << std::endl;
    std::cout << "   1-4: 选择操作类型" << std::endl;
    std::cout << "   ESC: 退出程序" << std::endl;
    
    while (true) {
        // 根据当前操作类型计算结果
        cv::Mat dynamic_result;
        double alpha_val = alpha_slider / 100.0;
        double beta_val = beta_slider / 100.0;
        
        switch (operation_type) {
            case 0:  // 加法
                cv::addWeighted(img1, alpha_val, img2, 1.0 - alpha_val, 0, dynamic_result);
                break;
                
            case 1:  // 减法
                {
                    cv::Mat temp;
                    cv::multiply(img2, cv::Scalar::all(alpha_val), temp);
                    cv::subtract(temp, img1, dynamic_result);
                }
                break;
                
            case 2:  // 乘法
                cv::multiply(img1, cv::Scalar::all(alpha_val * 2.0), dynamic_result);
                break;
                
            case 3:  // 融合
                cv::addWeighted(img1, alpha_val, gradient, beta_val, 0, dynamic_result);
                break;
        }
        
        // 在结果上添加参数信息
        cv::Mat result_display;
        dynamic_result.copyTo(result_display);
        
        std::string param_text;
        if (operation_type == 3) {
            param_text = "Alpha: " + std::to_string(alpha_val) + 
                        "  Beta: " + std::to_string(beta_val);
        } else {
            param_text = "参数: " + std::to_string(alpha_val);
        }
        
        cv::putText(result_display, param_text, cv::Point(10, 30),
                   cv::FONT_HERSHEY_SIMPLEX, 0.7, cv::Scalar(0, 255, 0), 2);
        
        std::vector<std::string> op_names = {"加法", "减法", "乘法", "融合"};
        cv::putText(result_display, "操作: " + op_names[operation_type], 
                   cv::Point(10, 60), cv::FONT_HERSHEY_SIMPLEX, 
                   0.6, cv::Scalar(0, 255, 255), 1);
        
        // 显示动态结果
        cv::imshow("动态演示", result_display);
        
        // 处理按键
        int key = cv::waitKey(30);
        
        if (key == 27) {  // ESC
            break;
        } else if (key == 'a' || key == 'A') {
            alpha_slider = std::max(0, alpha_slider - 5);
            updateControlPanel();
            cv::imshow("控制面板", control_panel);
        } else if (key == 'd' || key == 'D') {
            alpha_slider = std::min(100, alpha_slider + 5);
            updateControlPanel();
            cv::imshow("控制面板", control_panel);
        } else if (key == 'w' || key == 'W') {
            beta_slider = std::min(100, beta_slider + 5);
            updateControlPanel();
            cv::imshow("控制面板", control_panel);
        } else if (key == 's' || key == 'S') {
            beta_slider = std::max(0, beta_slider - 5);
            updateControlPanel();
            cv::imshow("控制面板", control_panel);
        } else if (key >= '1' && key <= '4') {
            operation_type = key - '1';
            updateControlPanel();
            cv::imshow("控制面板", control_panel);
        } else if (key == ' ') {
            // 保存当前结果
            std::string filename = "pixel_op_result_" + 
                                 std::to_string(time(0)) + ".jpg";
            cv::imwrite(filename, result_display);
            std::cout << "已保存: " << filename << std::endl;
        }
    }
    
    cv::destroyAllWindows();
    
    std::cout << "\n=== 像素运算演示完成 ===" << std::endl;
    std::cout << "总结：" << std::endl;
    std::cout << "1. 掌握了像素算术运算（加、减、乘、除）" << std::endl;
    std::cout << "2. 学会了位运算（与、或、非、异或）" << std::endl;
    std::cout << "3. 理解了像素值范围和溢出处理" << std::endl;
    std::cout << "4. 实现了图像融合、水印、差异检测等应用" << std::endl;
    
    return 0;
}
```

### 3.3 关键知识点总结

#### 1. 像素值范围与溢出处理
- **8位图像**：像素值范围0-255，超过会自动回绕（255+1=0）
- **饱和运算**：使用`cv::add()`、`cv::subtract()`等函数避免溢出
- **类型转换**：使用`convertTo()`和`saturate_cast<>()`进行安全转换

#### 2. 算术运算的选择
- **简单运算**：使用运算符（+、-、*、/）速度快，但需注意溢出
- **安全运算**：使用OpenCV函数（add、subtract等）自动处理溢出
- **融合运算**：`addWeighted()`实现α×A + β×B + γ

#### 3. 位运算的应用场景
- **掩膜操作**：`bitwise_and()`提取感兴趣区域
- **图像合并**：`bitwise_or()`组合多个图像
- **图像取反**：`bitwise_not()`创建负片效果
- **差异检测**：`bitwise_xor()`找出两图不同之处

#### 4. 实用技巧
1. **避免除零**：在除法前检查分母是否为零
2. **归一化处理**：将浮点数转换到0-255范围显示
3. **掩膜优化**：使用位运算替代逐像素判断
4. **内存连续**：连续图像可使用指针快速遍历

