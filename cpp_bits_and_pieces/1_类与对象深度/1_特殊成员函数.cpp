// ============================================================
// 本节要学什么？
// 1. C++ 类的六大特殊成员函数：默认构造、析构、拷贝构造、拷贝赋值、移动构造、移动赋值
// 2. 每个函数的作用、语法、调用时机、底层原理、注意事项
// 3. 深拷贝 vs 浅拷贝、拷贝语义 vs 移动语义
// 4. 右值引用（&&）的本质、std::move 的作用
// 5. noexcept 在移动语义中的关键作用（容器优化的核心）
// 6. 特殊成员函数的生成规则（C++11 vs C++98）
// 7. 禁用特殊成员函数（= delete）的场景
// 8. 临时对象的生命周期与移动语义的优化
// 9. 六大函数的完整调用顺序演示
// 10. 工程最佳实践：何时手动实现，何时用默认生成
//
// 为什么要学？
// - 特殊成员函数是 C++ 面向对象的“生命周期骨架”，不懂就会写出内存泄漏、崩溃的代码
// - 移动语义（C++11）是现代 C++ 性能优化的核心，容器、算法、异步都依赖它
// - 面试必考：六大函数、深拷贝浅拷贝、移动语义、noexcept
// - 工程中大量用于资源管理、性能优化、接口设计
//
// 核心重点（必须记住）
// 1. 六大函数：构造 → 析构 → 拷贝构造 → 拷贝赋值 → 移动构造 → 移动赋值
// 2. 拷贝构造必须是 const &：避免无限递归、兼容 const/临时对象
// 3. 移动构造/移动赋值必须是 &&：接收右值，转移资源
// 4. 移动操作必须加 noexcept：容器扩容才敢用移动，否则降级为拷贝
// 5. 拷贝赋值必须做自赋值检查：防止释放自己的内存后再拷贝
// 6. 移动后源对象必须置空：避免析构时重复释放资源
// ============================================================

#include <iostream>
#include <cstring>
#include <utility>
#include <vector>

// ============================================================
// 演示类：带动态内存的字符串类，完整实现六大特殊成员函数
// ============================================================
class MyString {
private:
  char* m_data;   // 动态分配的字符串
  size_t m_len;   // 字符串长度

  // --- 辅助函数：释放资源 ---
  void clear() noexcept {
    if (m_data) {
      delete[] m_data;
      m_data = nullptr;
    }
    m_len = 0;
  }

public:
  // ==========================================================
  // 1. 默认构造函数
  // ==========================================================
  MyString() : m_data(nullptr), m_len(0) {
    std::cout << "【默认构造】空字符串" << std::endl;
  }
  // - 解释：
  // - 作用：创建空对象，初始化成员变量
  // - 调用时机：MyString s; 或当其他构造委托时
  // - 注意：如果没有手动定义任何构造函数，编译器会自动生成默认构造
  // - 如果手动定义了其他构造，编译器不会自动生成默认构造

  // ==========================================================
  // 带参构造（非特殊，但常用）
  // ==========================================================
  MyString(const char* str) {
    if (str) {
      m_len = std::strlen(str);
      m_data = new char[m_len + 1];
      std::strcpy(m_data, str);
    } else {
      m_data = nullptr;
      m_len = 0;
    }
    std::cout << "【带参构造】: " << (m_data ? m_data : "空") << std::endl;
  }

  // ==========================================================
  // 2. 析构函数
  // ==========================================================
  ~MyString() {
    std::cout << "【析构】: " << (m_data ? m_data : "空") << std::endl;
    clear();
  }
  // - 解释：
  // - 作用：释放动态内存，避免泄漏
  // - 调用时机：对象生命周期结束时（离开作用域、delete 时）
  // - 注意：
  //   1. 析构函数不能有参数、不能重载
  //   2. 如果类有动态内存，必须手动实现析构
  //   3. 析构函数默认是 noexcept(true)，绝对不要在析构中抛异常

  // ==========================================================
  // 3. 拷贝构造函数（左值引用版）
  // ==========================================================
  MyString(const MyString& other) {
    m_len = other.m_len;
    if (other.m_data) {
      m_data = new char[m_len + 1];
      std::strcpy(m_data, other.m_data);
    } else {
      m_data = nullptr;
    }
    std::cout << "【拷贝构造】: " << (m_data ? m_data : "空") << std::endl;
  }
  // - 解释：
  // - 作用：用已有对象创建新对象（深拷贝）
  // - 调用时机：MyString s2(s1); 或 MyString s2 = s1; 或函数传值参数
  // - 为什么必须是 const &？
  //   1. 必须加 &：传值会触发拷贝构造，导致无限递归；引用是别名，不创建新对象
  //   2. 必须加 const：保证不修改源对象，兼容 const 对象和临时对象（右值）
  // - 深拷贝：复制资源（如 new 新内存），每个对象有独立的资源
  // - 浅拷贝：只复制指针，多个对象共享同一份资源，会导致重复释放崩溃

  // ==========================================================
  // 4. 拷贝赋值运算符（左值引用版）
  // ==========================================================
  MyString& operator=(const MyString& other) {
    std::cout << "【拷贝赋值】: " << (other.m_data ? other.m_data : "空") << std::endl;

    if (this == &other) { // 自赋值检查，防止释放自己的内存后再拷贝
      return *this;
    }

    clear(); // 释放当前对象的旧资源

    // 深拷贝新资源
    m_len = other.m_len;
    if (other.m_data) {
      m_data = new char[m_len + 1];
      std::strcpy(m_data, other.m_data);
    }

    return *this;
  }
  // - 解释：
  // - 作用：把一个对象赋值给另一个已存在的对象（深拷贝）
  // - 调用时机：s2 = s1;
  // - 注意：
  //   1. 必须返回 *this，支持链式赋值（s1 = s2 = s3）
  //   2. 必须做自赋值检查，否则会释放自己的内存后再拷贝，导致崩溃
  //   3. 必须先释放旧资源，再拷贝新资源，避免内存泄漏

  // ==========================================================
  // 5. 移动构造函数（右值引用版，C++11）
  // ==========================================================
  MyString(MyString&& other) noexcept {
    // 直接“偷” other 的资源
    m_data = other.m_data;
    m_len = other.m_len;

    // 把 other 置空，防止它析构时释放资源
    other.m_data = nullptr;
    other.m_len = 0;

    std::cout << "【移动构造】资源转移" << std::endl;
  }
  // - 解释：
  // - 作用：从临时对象/右值偷资源，避免深拷贝，提升性能
  // - 调用时机：MyString s2(std::move(s1)); 或返回临时对象时
  // - 为什么必须是 &&？
  //   右值引用（&&）专门接收右值（临时对象、std::move 后的对象）
  // - 为什么必须加 noexcept？
  //   1. 承诺不抛异常，让编译器生成更高效的代码
  //   2. 容器（如 vector）扩容时，只有看到 noexcept 才敢用移动，否则降级为拷贝
  //   3. 移动操作只做指针转移，本身不会失败，加 noexcept 符合语义
  // - 移动语义：转移资源所有权，源对象失效（但必须处于可析构状态）

  // ==========================================================
  // 6. 移动赋值运算符（右值引用版，C++11）
  // ==========================================================
  MyString& operator=(MyString&& other) noexcept {
    std::cout << "【移动赋值】资源转移" << std::endl;

    if (this == &other) {
      return *this;
    }

    clear(); // 释放当前对象的旧资源

    // 偷资源
    m_data = other.m_data;
    m_len = other.m_len;

    // 置空源对象
    other.m_data = nullptr;
    other.m_len = 0;

    return *this;
  }
  // - 解释：
  // - 作用：从右值赋值，转移资源，避免深拷贝
  // - 调用时机：s2 = std::move(s1);
  // - 注意：
  //   1. 同样需要自赋值检查和置空源对象
  //   2. 同样需要加 noexcept，理由同移动构造

  // ==========================================================
  // 辅助函数：打印内容
  // ==========================================================
  void print() const {
    if (m_data) {
      std::cout << "内容: " << m_data << std::endl;
    } else {
      std::cout << "内容: 空" << std::endl;
    }
  }

  // ==========================================================
  // 禁用拷贝（可选，演示 = delete）
  // ==========================================================
  // MyString(const MyString&) = delete;
  // MyString& operator=(const MyString&) = delete;
  // - 解释：
  // - 用 = delete 禁用拷贝，让类只能移动，不能拷贝
  // - 适用于独占资源的类（如智能指针、文件句柄）
};

// ============================================================
// 测试函数：触发所有特殊成员函数
// ============================================================
MyString createTempString(const char* str) {
  return MyString(str); // 返回临时对象，触发移动构造（RVO 优化可能省略）
}

void testAllSpecialMembers() {
  std::cout << "\n--- 1. 默认构造 ---" << std::endl;
  MyString s1;

  std::cout << "\n--- 2. 带参构造 ---" << std::endl;
  MyString s2("Hello, World!");

  std::cout << "\n--- 3. 拷贝构造 ---" << std::endl;
  MyString s3 = s2; // 等价于 MyString s3(s2);

  std::cout << "\n--- 4. 拷贝赋值 ---" << std::endl;
  MyString s4("Initial");
  s4 = s2;

  std::cout << "\n--- 5. 移动构造（临时对象）---" << std::endl;
  MyString s5 = createTempString("Temporary String");

  std::cout << "\n--- 6. 移动赋值（std::move）---" << std::endl;
  MyString s6("Old Value");
  s6 = std::move(s2); // s2 失效，s6 获得 s2 的资源

  std::cout << "\n--- 7. 显式移动构造 ---" << std::endl;
  MyString s7 = std::move(s3); // s3 失效，s7 获得 s3 的资源

  std::cout << "\n--- 8. 容器中的移动语义 ---" << std::endl;
  std::vector<MyString> vec;
  vec.reserve(3); // 预分配空间，避免扩容
  vec.emplace_back("Vector 1");
  vec.emplace_back("Vector 2");
  vec.emplace_back("Vector 3");
  // 如果 MyString 的移动构造是 noexcept，vector 扩容时会用移动，否则用拷贝

  std::cout << "\n--- 测试结束，局部对象析构 ---" << std::endl;
}

// ============================================================
// 特殊成员函数生成规则（C++11）
// ============================================================
// 1. 如果没有手动定义任何构造函数，编译器自动生成默认构造
// 2. 如果没有手动定义析构函数，编译器自动生成默认析构
// 3. 如果没有手动定义拷贝构造/拷贝赋值，编译器自动生成默认版本（浅拷贝）
// 4. 如果没有手动定义移动构造/移动赋值，且没有手动定义拷贝构造/拷贝赋值/析构，编译器自动生成默认移动版本
// 5. 一旦手动定义了拷贝构造/拷贝赋值/析构，编译器不再自动生成移动构造/移动赋值
// 6. 一旦手动定义了移动构造/移动赋值，编译器不再自动生成拷贝构造/拷贝赋值

int main() {
  testAllSpecialMembers();
  return 0;
}

